{"author": "Rolan", "title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "content": ["小程序全局配置app.josn增加选项：\"navigationStyle\":", "\"custom\",具体如下：原生小程序开发打开", "app.json：{", "\"pages\":", "[", "\"pages/index/index\",", "\"pages/logs/index\"", "],", "\"window\":", "{", "\"backgroundTextStyle\":", "\"light\",", "\"navigationBarBackgroundColor\":", "\"#000\",", "\"navigationStyle\":", "\"custom\",", "\"navigationBarTitleText\":", "\"WeChat\"", "}}mpvue方式开发小程序>打开", "/src/main.js：export", "default", "{", "config:", "{", "pages:", "[", "'pages/logs/main',", "'^pages/index/main'", "],", "window:", "{", "backgroundTextStyle:", "'light',", "navigationBarBackgroundColor:", "'#666',", "navigationStyle:", "'custom',", "navigationBarTitleText:", "'WeChat',", "navigationBarTextStyle:", "'#fff',", "enablePullDownRefresh:", "false,", "disableScroll:", "true", "}", "}}"]}
{"author": "Rolan", "title": "小程序时间轴组件 ", "content": ["预览timeline.gif场景用于快递节点跟踪、发展历程等要点1.position作布局", "2.border-radius画圆点", "3.moment格式化时间，区分当日(HH:mm)与前日的格式(YYYY-MM-DD", "HH:mm)wxml<view", "class=\"listview-container\">", "<block", "wx:for=\"{{newsList}}\"", "wx:key=\"\">", "<view", "class=\"playlog-item\"", "bindtap=\"itemTapped\">", "<view", "class=\"dotline\">", "<!--", "竖线", "-->", "<view", "class=\"line\"></view>", "<!--", "圆点", "-->", "<view", "class=\"dot\"></view>", "<!--", "时间戳", "-->", "</view>", "<view", "class=\"content\">", "<text", "class=\"course\">{{item.time}}</text>", "<text", "class=\"chapter\">{{item.content}}</text>", "</view>", "</view>", "<ad", "unit-id=\"adunit-5abb45645905fc90\"", "wx:if=\"{{index", "%", "5", "==", "4}}\"></ad>", "</block></view>wxss/*时间轴*//*外部容器*/.listview-container", "{", "margin:", "10rpx", "10rpx;}/*行样式*/.playlog-item", "{", "display:", "flex;}/*时间轴*/.playlog-item", ".dotline", "{", "width:", "35px;", "position:", "relative;}/*竖线*/.playlog-item", ".dotline", ".line", "{", "width:", "1px;", "height:", "100%;", "background:", "#ccc;", "position:", "absolute;", "top:", "0;", "left:", "15px;}/*圆点*/.playlog-item", ".dotline", ".dot", "{", "width:", "11px;", "height:", "11px;", "background:", "#30ac63;", "position:", "absolute;", "top:", "10px;", "left:", "10px;", "border-radius:", "50%;}/*时间戳*/.playlog-item", ".dotline", ".time", "{", "width:", "100%;", "position:", "absolute;", "margin-top:", "30px;", "z-index:", "99;", "font-size:", "12px;", "color:", "#777;", "text-align:", "center;}/*右侧主体内容*/.playlog-item", ".content", "{", "width:", "100%;", "display:", "flex;", "flex-direction:", "column;", "border-bottom:", "1px", "solid", "#ddd;", "margin:", "3px", "0;}/*章节部分*/.playlog-item", ".content", ".chapter", "{", "font-size:", "30rpx;", "line-height:", "68rpx;", "color:", "#444;", "white-space:", "normal;", "padding-right:", "10px;}/*课程部分*/.playlog-item", ".content", ".course", "{", "font-size:", "28rpx;", "line-height:", "56rpx;", "color:", "#999;}jsvar", "moment", "=", "require('./moment.min');//", "格式化订单var", "formatNews", "=", "function", "(news)", "{", "return", "news.map(item", "=>", "{", "var", "time", "=", "moment(item.postTime);", "var", "zero", "=", "moment().format('YYYY-MM-DD');", "var", "after", "=", "moment(time).isAfter(zero);", "if", "(after)", "{", "item.time", "=", "moment(item.postTime).format('HH:mm');", "}", "else", "{", "item.time", "=", "moment(item.postTime).format('YYYY-MM-DD", "HH:mm');", "}", "return", "item;", "});}module.exports", "=", "{", "formatNews}源码下载", "关注订阅号【黄秀杰】或扫一扫下方二维码，回复关键字115"]}
{"author": "Rolan", "title": "小程序之图片懒加载 完美方案，你不来看看？ ", "content": ["效果图既然来了，把妹子都给你。定义懒加载，前端人都知道的一种性能优化方式，简单的来说，只有当图片出现在浏览器的可视区域内时，才设置图片正真的路径，让图片显示出来。这就是图片懒加载。实现原理监听页面的scroll事件,判读元素距离页面的top值是否是小于等于页面的可视高度判断逻辑代码如下element.getBoundingClientRect().top", "<=", "document.documentElement.clientHeight", "?", "显示", ":", "默认我们知道小程序页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件。所以关于图片懒加载就需要在数据上面做文章了。页面页面上面只需要根据数据的某一个字段来判断是否显示图片就可以了，字段为Boolean类型，当为false的时候显示默认图片就行了。代码大概长成这样<view", "wx:for=\"{{list}}\"", "class='item", "item-{{index}}'", "wx:key=\"{{index}}\">", "<image", "class=\"{{item.show", "?", "'active':", "''}}\"", "src=\"{{item.show", "?", "item.src", ":", "item.def}}\"></image>", "</view>布局跟简单，view组件里面有个图片，并循环list，有多少就展示多少image组件的src字段通过每一项的show来进行绑定，active是加了个透明的过渡样式image{", "transition:", "all", ".3s", "ease;", "opacity:", "0;", "}", ".active{", "opacity:", "1;", "}", "逻辑本位主要讲解懒加载，所以把数据写死在页面上了数据结构如下：我们使用两种方式来实现懒加载，准备好没有，一起来快乐的撸码吧。WXML节点信息小程序支持调用createSelectQuery创建一个SelectorQuery实例，并使用select方法来选择节点，并通过boundingClientRect来获取节点信息。wx.createSelectorQuery().select('.item').boundingClientRect((ret)=>{", "console.log(ret)", "}).exec()", "显示结果如下悄悄告诉你，小程序里面有个onPageScroll函数，是用来监听页面的滚动的。还有个getSystemInfo函数，可以获取获取系统信息，里面包含屏幕的高度。接下来，思路就透彻了吧。还是上面的逻辑，", "扒拉扒拉直接写代码就行了,这里只写下主要的逻辑，完整代码请戳文末githubshowImg(){", "let", "group", "=", "this.data.group", "let", "height", "=", "this.data.height", "//", "页面的可视高度", "wx.createSelectorQuery().selectAll('.item').boundingClientRect((ret)", "=>", "{", "ret.forEach((item,", "index)", "=>", "{", "if", "(item.top", "<=", "height)", "{", "判断是否在显示范围内", "group[index].show", "=", "true", "//", "根据下标改变状态", "}", "})", "this.setData({", "group", "})", "}).exec()", "}", "onPageScroll(){", "//", "滚动事件", "this.showImg()", "}至此，我们完成了一个小程序版的图片懒加载，只是思维转变了下，其实并没有改变实现方式。我们来学些新的东西吧。节点布局相交状态节点相交状态是啥？它是一个新的API，叫做IntersectionObserver,", "本文只讲解简单的使用，了解更多请猛戳没错，就是点我小程序里面给它的定义是节点布局交叉状态API可用于监听两个或多个组件节点在布局位置上的相交状态。这一组API常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。里面设计的概念主要有五个，分别为参照节点：以某参照节点的布局区域作为参照区域，参照节点可以有多个，多个话参照区域取它们的布局区域的交集目标节点：监听的目标，只能是一个节点相交区域：目标节点与参照节点的相交区域相交比例：目标节点与参照节点的相交比例阈值：可以有多个，默认为[0],", "可以理解为交叉比例，例如[0.2,", "0.5]关于它的API有五个，依次如下1、createIntersectionObserver([this],", "[options])，见名知意,创建一个IntersectionObserver实例2、intersectionObserver.relativeTo(selector,", "[margins]),", "指定节点作为参照区域，margins参数可以放大缩小参照区域，可以包含top、left、bottom、right四项3、intersectionObserver.relativeToViewport([margin])，指定页面显示区域为参照区域4、intersectionObserver.observer(targetSelector,", "callback)，参数为指定监听的节点和一个回调函数，目标元素的相交状态发生变化时就会触发此函数，callback函数包含一个result，下面再讲5、intersectionObserver.disconnect()", "停止监听，回调函数不会再触发然后说下callback函数中的result，它包含的字段为我们主要使用intersectionRatio进行判断，当它大于0时说明是相交的也就是可见的。先来波测试题，请说出下面的函数做了什么，并且log函数会执行几次1、", "wx.createIntersectionObserver().relativeToViewport().observer('.box',", "(result)", "=>", "{", "console.log('监听box组件触发的函数')", "})", "2、", "wx.createIntersectionObserver().relativeTo('.box').observer('.item',", "(result)", "=>", "{", "console.log('监听item组件触发的函数')", "})", "3、", "wx.createIntersectionObserver().relativeToViewport().observer('.box',", "(result)", "=>", "{", "if(result.intersectionRatio", ">", "0){", "console.log('.box组件是可见的')", "}", "})duang，揭晓答案。第一个以当前页面的视窗监听了.box组件，log会触发两次，一次是进入页面一次是离开页面第二个以.box节点的布局区域监听了.item组件，log会触发两次，一次是进入页面一次是离开页面第三个以当前页面的视窗监听了.box组件，log只会在节点可见的时候触发好了，题也做了，API你也掌握了，相信你已经可以使用IntersectionObserver来实现图片懒加载了吧，主要逻辑如下let", "group", "=", "this.data.group", "//", "获取图片数组数据", "for", "(let", "i", "in", "this.data.group){", "wx.createIntersectionObserver().relativeToViewport().observe('.item-'+", "i,", "(ret)", "=>", "{", "if", "(ret.intersectionRatio", ">", "0){", "group[i].show", "=", "true", "}", "this.setData({", "group", "})", "})", "}最后至此，我们使用两种方式实现了小程序版本的图片懒加载，可以发现，使用IntersectionObserver来实现不要太酸爽。本文代码请戳github"]}
{"author": "Rolan", "title": "微信小程序之动态获取元素宽高 ", "content": ["我以前一直以为微信小程序不能动态获取view元素的宽高。但是自从看到：", "wx.createSelectorQuery()", "这个api接口，以前的某些问题就能得到解决了。。。那么，这个api接口怎么用呢？首先，这个接口会返回一个对象实例。var", "obj=wx.createSelectorQuery();", "下面的就是返回的对象实例", "obj", "的所有内容。返回的", "obj", "有五个方法：obj.in(component)：没用过这个方法，多用于组件的选择器。obj.select(selector)：获取指定的节点，selector是css选择器。返回一个", "NodesRef", "对象实例，可以用于获取节点信息。obj.selectAll(selector)：获取指定的节点，selector是css选择器。返回一个", "NodesRef", "对象实例，可以用于获取节点信息。上面这两个我感觉就是", "js", "中querySelector和querySelectorAll的区别。obj.selectViewport()：我没用过这个方法。官方说是选择显示区域，可用于获取显示区域的尺寸、滚动位置等信息。也是返回一个", "NodesRef", "对象实例，可以用于获取节点信息。exec(", "function(res){}", ")：执行所有的请求，请求结果按请求次序构成数组，在callback的第一个参数中返回上面返回的", "NodesRef", "对象实例就很重要了，它有三个方法：boundingClientRect(", "function(rect){}", ")：就是这个方法，能够动态获取view元素的高度、宽度等属性。还有其它的请看官方文档scrollOffset(", "function(res)", "{}）：获取节点的水平、垂直滚动的位置等。节点必须是scroll-view或者viewportfields(fields,function(){res}", ")：这个可以获取指定元素的自定义属性和class名，具体的请看官方文档的说明。废话了这么多，真正的实例用法：wx.createSelectorQuery().selectAll('.npl-intro').boundingClientRect(function", "(rect)", "{", "console.log(rect[0].height)", "console.log(rect[0].width)}).exec()", "如果觉得这样写有点长。可以分步写。也是一样的结果。var", "obj=wx.createSelectorQuery();obj.selectAll('.npl-intro').boundingClientRect(function", "(rect)", "{", "console.log(rect[0].height)", "console.log(rect[0].width)})obj.exec()", ";当然，这方法可以写在onLoad、onReady、onShow等这些生命周期的方法，也可以写在自定义的方法里。什么时候需要，什么时候就调用。", "官方", "wx.createSelectorQuery()", "接口"]}
{"author": "Rolan", "title": "golang+json-iterator（微信小程序推送通知实例） ", "content": ["结构体如下：type", "WxPushContent", "struct", "{", "Push_record_id", "int", "`json:\"push_record_id\"`", "Template_id", "string", "`json:\"template_id\"`", "Page", "string", "`json:\"page\"`", "Data", "Data", "`json:\"data\"`", "Emphasis_keyword", "string", "`json:\"emphasis_keyword\"`", "}", "type", "Data", "struct", "{", "Keyword1", "WxKeyword", "`json:\"keyword1\"`", "Keyword2", "WxKeyword", "`json:\"keyword2\"`", "Keyword3", "WxKeyword", "`json:\"keyword3\"`", "}", "type", "WxKeyword", "struct", "{", "Value", "string", "`json:\"value\"`", "}实际代码如下：func", "ExecutePush_WX(ctx", "*gin.Context)", "{", "var", "json_iterator", "=", "jsoniter.ConfigCompatibleWithStandardLibrary", "jsonWxPushContent,", "_", ":=", "json_iterator.Marshal(models.WxPushContent{", "Push_record_id:", "note.Id,", "Template_id:", "setting.MINITemplateId,", "Page:", "\"/pages/detail?isShare=true&isFromPush=\"", "+", "strconv.Itoa(note.Id)", "+", "\"&id=\"", "+", "strconv.FormatInt(note.NewsId,", "10),", "Data:", "models.Data{", "Keyword1:models.WxKeyword{Value:", "\"热点新闻\"},", "Keyword2:models.WxKeyword{Value:", "news.Title},", "Keyword3:models.WxKeyword{Value:", "tt[0].Summary},", "},", "Emphasis_keyword:", "\"keyword1.DATA\"})", "}", "log.Println(\"小程序-加密前的参数:", "\",", "string(jsonWxPushContent))返回结果：{", "\"push_record_id\":33,", "\"template_id\":\"3OviTbpRI-7t8GJxlaoKtyQM6SuOXnROVk-jwj-T-GI\",", "\"page\":\"/pages/detail?isShare=true&isFromPush=33&id=63688\",", "\"data\":{", "\"keyword1\":{", "\"value\":\"热点新闻\"", "},", "\"keyword2\":{", "\"value\":\"人工智能是否会颠覆传统电视行业？\"", "},", "\"keyword3\":{", "\"value\":\"据了解，近日长虹再次与人工智能领先企业达观数据达成合作，将电视内容的个性化推荐引入智能电视，为用户更好的打造智慧家庭体系\"", "}", "}", "\"emphasis_keyword\":\"keyword1.DATA\"", "}之后就是请求微信小程序api地址拉！"]}
{"author": "Rolan", "title": "微信小程序-测试游戏生成六边多边形 ", "content": ["最新又接到新的活动需求啦，是一个测试类的游戏。", "大概的看了整个需求，这个活动的难点在于结果页面的六边形指标怎么实现。效果demo类似分析背景", "首先，这是用户对应六个属性值的等边六边形，等边六边形这是一个很关键的点；为什么是等边六边形呢，因为用户留个属性的峰值的一样的，起点也是一致的。中心点", "这个六边形的中心就是整个圆心的中心位置六个属性坐标位置", "我们需要各自的属性值算出对应的坐标位置绘画等边六边形我们假设要绘画边长为240长度的等边六边形；", "我们需要简单的计算下；我们把底部切成三块，一个三角形+矩形+三角形用css方式把它画出来。相信三角形的画法大家应该都很清楚了，这里就不重复讲基础的东西dom<view", "class=\"six-bg\">", "<view", "class=\"box1\"></view>", "<view", "class=\"box2\"></view>", "<view", "class=\"box3\"></view>", "</view>", "复制代码css@sixWidthRPX:", "208rpx;", "//", "240*cos30°", "@sixHeightRPX:", "120rpx;", "//", "240*sin30°", "@sixWidthBigRPX:", "416rpx;", "@sixHeightBigRPX:", "240rpx;", ".six-bg{", "padding:", "167rpx;", ".box1{", "width:0;", "border-left:", "@sixWidthRPX", "solid", "transparent;", "border-right:", "@sixWidthRPX", "solid", "transparent;", "border-bottom:", "@sixHeightRPX", "solid", "#6c6;", "}", ".box2{", "width:", "@sixWidthBigRPX;", "height:", "@sixHeightBigRPX;", "background-color:", "#6c6;", "}", ".box3{", "width:0;", "border-top:", "@sixHeightRPX", "solid", "#6c6;", "border-left:", "@sixWidthRPX", "solid", "transparent;", "border-right:", "@sixWidthRPX", "solid", "transparent;", "}", "}", "复制代码效果图根据属性值画点连线假设我们把那个属性值的峰值都定为10。我们知道等边六边形的6边长度都为240。那我们的每个单位就是24。我们先假设6个属性值都满了，那么data", "=", "{", "sixData:", "{", "one:", "10,", "two:", "10,", "three:", "10,", "four:", "10,", "five:", "10,", "six:", "10", "}", "}", "复制代码我们找下等边六边形的圆形点。X轴位置", "167+208", "=", "375Y轴位置", "167+240", "=", "4076个坐标位置第一个点的坐标和第四个点的坐标是最容易计算的，我们先把这两个点的坐标算出来；const", "unit", "=", "24", "//", "单位", "const", "centerDotX", "=", "375", "//", "中心点", "const", "centerDotY", "=", "407", "//", "中心点", "//", "第一个点", "位置", "let", "dotOne", "=", "{", "x:", "centerDotX,", "y:", "centerDotY", "-", "this.sixData.one", "*", "unit", "}", "//", "第四个点", "位置", "let", "dotFour", "=", "{", "x:", "centerDotX,", "y:", "centerDotY", "+", "this.sixData.four", "*", "unit", "}", "复制代码第二、三、五、六点的坐标我们就需要用到三角函数了；我们观察下这个图，发现", "2、3、5、6点都有30度的夹角；第二点坐标const", "lineLongTwo", "=", "unit", "*", "this.sixData.two", "x", "=", "centerDotX", "+", "lineLongTwo*cos30", "y", "=", "centerDotY", "-", "lineLongTwo*sin30", "复制代码我们的js代码并没有cos、sin的方法；这时候我们需要补一下Math函数的知识；Math.sin(x)", "x", "的正玄值。返回值在", "-1.0", "到", "1.0", "之间；Math.cos(x)", "x", "的余弦值。返回的是", "-1.0", "到", "1.0", "之间的数；这两个函数中的X", "都是指的“弧度”而非“角度”，弧度的计算公式为：(度数", "*", "Math.PI)", "/", "180；现在我们可以算出6个点的位置了const", "unit", "=", "24", "//", "单位", "const", "centerDotX", "=", "375", "//", "中心点", "const", "centerDotY", "=", "407", "//", "中心点", "//", "第一个点", "位置", "let", "dotOne", "=", "{", "x:", "centerDotX,", "y:", "centerDotY", "-", "this.sixData.one", "*", "unit", "}", "//", "第二个点", "位置", "const", "lineLongTwo", "=", "unit", "*", "this.sixData.two", "let", "dotTwo", "=", "{", "x:", "centerDotX", "+", "lineLongTwo", "*", "Math.cos((30", "*", "Math.PI)", "/", "180),", "y:", "centerDotY", "-", "lineLongTwo", "*", "Math.sin((30", "*", "Math.PI)", "/", "180)", "}", "//", "第三个点", "位置", "const", "lineLongThree", "=", "unit", "*", "this.sixData.three", "let", "dotThree", "=", "{", "x:", "centerDotX", "+", "lineLongThree", "*", "Math.cos((30", "*", "Math.PI)", "/", "180),", "y:", "centerDotY", "+", "lineLongThree", "*", "Math.sin((30", "*", "Math.PI)", "/", "180)", "}", "//", "第四个点", "位置", "let", "dotFour", "=", "{", "x:", "centerDotX,", "y:", "centerDotY", "+", "this.sixData.four", "*", "unit", "}", "//", "第五个点", "位置", "const", "lineLongFive", "=", "unit", "*", "this.sixData.five", "let", "dotFive", "=", "{", "x:", "centerDotX", "-", "lineLongFive", "*", "Math.cos((30", "*", "Math.PI)", "/", "180),", "y:", "centerDotY", "+", "lineLongFive", "*", "Math.sin((30", "*", "Math.PI)", "/", "180)", "}", "//", "第六个点", "位置", "const", "lineLongSix", "=", "unit", "*", "this.sixData.six", "let", "dotSix", "=", "{", "x:", "centerDotX", "-", "lineLongSix", "*", "Math.cos((30", "*", "Math.PI)", "/", "180),", "y:", "centerDotY", "-", "lineLongSix", "*", "Math.sin((30", "*", "Math.PI)", "/", "180)", "}", "复制代码现在我们来把点连成；我们可以采用", "微信小程序canvas", "api", "来绘制我们的六条线先建立canvas", "dom<view", "class=\"canvas-module\">", "<canvas", "canvas-id=\"myCanvas\"", "class=\"canvas-class\"/>", "</view>", "复制代码css布局.canvas-module{", "position:", "absolute;", "width:", "750rpx;", "height:", "750rpx;", "z-index:", "2;", "top:", "0;", "left:", "0;", ".canvas-class{", "width:", "750rpx;", "height:", "750rpx;", "}", "}", "复制代码canvas", "api文档", "developers.weixin.qq.com/miniprogram…绘制const", "ctx", "=", "wepy.createCanvasContext('myCanvas')", "ctx.beginPath()", "ctx.moveTo(dotOne.x", "/", "2,", "dotOne.y", "/", "2)", "ctx.lineTo(dotTwo.x", "/", "2,", "dotTwo.y", "/", "2)", "ctx.lineTo(dotThree.x", "/", "2,", "dotThree.y", "/", "2)", "ctx.lineTo(dotFour.x", "/", "2,", "dotFour.y", "/", "2)", "ctx.lineTo(dotFive.x", "/", "2,", "dotFive.y", "/", "2)", "ctx.lineTo(dotSix.x", "/", "2,", "dotSix.y", "/", "2)", "ctx.lineTo(dotOne.x", "/", "2,", "dotOne.y", "/", "2)", "ctx.stroke()", "ctx.draw()", "复制代码位置坐标为什么要除以2呢？因为canvas是以px为单位的效果图我们再给利用canvas属性，给它加上一点补一样的东西我们给线加上颜色和宽度ctx.setStrokeStyle('yellow')", "//", "线条颜色", "ctx.setLineWidth(2)", "//", "线条宽度", "复制代码填充渐变颜色const", "grd", "=", "ctx.createLinearGradient(0,", "0,", "200,", "0)", "grd.addColorStop(0,", "'red')", "grd.addColorStop(1,", "'white')", "ctx.setFillStyle(grd)", "ctx.fill()", "复制代码加上透明度ctx.setGlobalAlpha(0.7)", "复制代码效果图最后我们再加上个动画，修改属性值，完成整个效果；dom<view", "class=\"canvas-module\"", "animation=\"{{animationData}}\">", "<canvas", "canvas-id=\"myCanvas\"", "class=\"canvas-class\"/>", "</view>", "<button", "@tap=\"goStart\">开始canvas</button>", "复制代码css.canvas-module{", "position:", "absolute;", "width:", "750rpx;", "height:", "750rpx;", "z-index:", "2;", "top:", "0;", "left:", "0;", "transform:", "scale(0);", "//新增样式", ".canvas-class{", "width:", "750rpx;", "height:", "750rpx;", "}", "}", "复制代码jsdata", "=", "{", "animationData:", "{},", "sixData:", "{", "one:", "10,", "two:", "7,", "three:", "1,", "four:", "6,", "five:", "2,", "six:", "8", "}", "};", "复制代码methods", "=", "{", "goStart", "()", "{", "var", "animation", "=", "wepy.createAnimation({", "duration:", "1000,", "timingFunction:", "'ease'", "})", "animation.scale(1,", "1).step()", "this.animationData", "=", "animation.export()", "}", "}", "复制代码效果如下这样整个动画就算完成了，", "demo请前往github", "github.com/fishmankkk/…其实背景图也是可以用canvas画的，有兴趣的小伙伴可以动手自己画一下"]}
{"author": "Rolan", "title": "小程序 Canvas绘图不同尺寸设备 UI兼容的两个解决方案 ", "content": ["最近做的一个需求，遇到一个问题，小程序绘图目前只支持", "px单位，设计图一般是以", "iphone6为基准设计，如果严格", "iphone6的尺寸进行代码编写，放在其他尺寸的设备上，肯定是不行的，所以需要按照设备进行等比例兼容，这里给出两个解决方案", "先假设一个需求，下面是最终实现的效果(以", "iphone6为基准)，下面就以此为目标进行展开", "整个页面被", "canvas组件覆盖(在", "iphone6下宽高为", "375x603)，中间偏蓝色的是一张图片，图片上有一行字", "flexible", "canvas", "类", "rem", "等比例缩放单位的解决方案，也就是以一个尺寸为基准，例如", "iphone", "6，然后其他设备按照这个标准，在保证宽度铺满设备的前提下，进行等比例缩放", "绘制的代码很简单：", "const", "ctx", "=", "wx.createCanvasContext('shareCard')", "ctx.drawImage('../58a.png',", "this.remSize(85),", "this.remSize(100),", "this.remSize(205),", "this.remSize(250))", "ctx.setFontSize(this.remSize(16))", "ctx.setFillStyle('yellowgreen')", "ctx.fillText('flexible", "canvas',", "this.remSize(100),", "this.remSize(130))", "ctx.draw()", "复制代码其中，remSize", "这个方法就是用于等比例缩放尺寸", "remSize", "(num)", "{", "return", "num", "*", "scale", "}", "复制代码其中，scale就是当前设备与设计基准设备", "iphone6的宽度比例", "scale", "=", "wx.getSystemInfoSync().windowWidth", "/", "375", "复制代码当前是以铺满设备宽度为目标，所以高度不关心，即", "以宽度为参考，高度", "auto", "以上，就基本实现需求，做法很简单，这是通常一贯的解决方案", "由于示例的需求比较简单，所以看着没多大问题，很完美，但是如果实际需求，比较复杂的那种，就有点不太美好了", "哪里不美好呢？就是换算尺寸的时候，每个尺寸都要调用一遍", "remSize方法，稍微复杂点需求可能就有几十个需要换算的尺寸了，那就要写几十遍的", "remSize，当然，写是可以写的，只是总感觉哪里不太对劲", "图片代替", "这个方法不需要频繁的尺寸换算，最后统一整体换算即可，原理也很简单", "按照", "iphone6尺寸进行绘制", "首先，无论当前设备的尺寸是什么，都不用管，先认为当前设备就是", "iphone6，然后创建", "canvas，在上面进行绘图，只不过，不能让用户看到这个", "canvas，因为当前设备并不一定是", "iphone6，而你直接就认定是", "iphone6，并以", "iphone6的尺寸进行绘制，绘制出来的效果肯定跟设计的效果不一样，所以不能让用户看到，可以使用", "ccover-view组件覆盖掉", "canvas组件", "Note:", "如果想要通过给", "canvas设置例如", "opacity:", "0,", "visibility:", "hidden等样式进行隐藏，根据实测，在大部分的手机上其实无法生效，也就是依旧能看到，display:", "none;则是彻底将", "canvas从文档流中(如果也算是文档流的话)删掉，无法进行绘制，所以比较好的做法就是用一个", "cover-view进行覆盖", "将绘制好的", "canvas输出为", "图片", "canvas绘制好后，将其绘制成图片保存在本地临时存储中，可以拿到这个图片在本地的临时路径，然后将这张图片放到页面上，并给这张图片设置尺寸样式，图片的宽度等于设备的宽度，高度跟随宽度进行等比例缩放，最终让用户看到的就是这张图片，因为进行了等比例缩放，所以视觉效果就是和设计图上是一样的", "这里也有几个点需要注意下", "ctx.draw是异步操作", "一直以为这个方法是同步方法，所以调用完此方法后立即输出图片，就出现了有时候图片错误的情况，后来才发现这个是异步操作，这就是看文档不仔细的后果", "ctx.draw(false,", "()", "=>", "{", "//", "保存为本地临时文件", "this.saveImageToLocal()", "})", "复制代码", "绘制", "canvas阶段，要允许页面横向溢出", "由于一开始绘制", "canvas是按照iphone6的标准进行的，所以在有些宽度小于", "iphone6的设备上，canvas的宽度是可能会比设备的宽度要大的(如果你绘制的是整屏", "canvas)，但是小程序页面的根元素", "page，默认设置了", "overflow-x:", "hiddne;，导致绘制不完整，所以需要覆盖这个样式：", "page", "{", "overflow-x:", "scroll;", "}", "复制代码", "绘制完毕后，避免页面横向溢出", "当上一步绘制完成", "canvas后，并成功将图片绘制到页面上时，如果当前设备的宽度小于", "iphone", "6，又由于前面给", "page元素设置了", "overflow-x:", "scroll，所以此时", "canvas元素肯定会撑大页面，让页面上出现一个横向的滚动条，而用户看到的图片宽度是和设备宽度相同，不应该出现这种情况", "解决方法，一种是直接使用", "wx-if这种条件语句删掉", "canvas元素，但是在低版本的基础库上，可能会报", "e.canvasId", "is", "undefined的错误(虽然根据实测来看，似乎并不影响正常功能)", "第二种就是减少", "canvas的尺寸，反正已经绘制好图片了，后面也用不到它了，而且用户也看不到，那就可以随意减小尺寸，我的做法是干脆无论宽高通通设为", "0，免得又出现什么", "bug", "//", "避免在尺寸小的设备上溢出", "this.setData({", "canvasWidth:", "0,", "canvasHeight:", "0", "})", "复制代码以上，两种方法都可以选择，各有利弊，第一种要写很多", "rem转换，第二种需要做的操作又比较多，各有利弊，根据真实需求进行抉择即可。作者：清夜链接：https://juejin.im/post/5b95ef65e51d450e5766c7df"]}
{"author": "Rolan", "title": "小程序远程图片资源按需预加载 ", "content": ["最近做H5开发遇到个问题，为了防止页面打开时，出现大图加载缓慢的情况，写了一个图片资源管理器，今天顺便实现了一下小程序版。特别说明一下，小程序由于资源包大小限制，很多图片资源会存放到CND图片服务器上，为了实现小程序初始化时按需加载远程图片资源，实现了以下加载器，希望能解决部分小程序新人开发者预加载图片的苦恼。特别强调：本加载器为初级版本，暂未研究其他实现方式，当前实现方式需要在微信公众平台->设置->downloadFile合法域名，中添加想要加载的图片所在服务器合法域名。原理介绍：使用小程序自带API读取远程图片资源：wx.getImageInfo({", "src:", "'images/a.jpg',", "success:", "function", "(res)", "{", "console.log(res.width)", "console.log(res.height)", "}", "})", "这个接口可以创建图片组件对象并返回图片加载状态。加载器用法：1、在app.js的同级目录下创建一个ImageSource.js作为图片资源的路径管理文件（可以根据情况改为其他文件名称）。2、在utils文件夹下放入ImageLoader.js或ImageLoader.min.js（附件）。3、根据需要在对应的文件中创建ImageLoader对象（看下文）。使用示例：1、载入文件：const", "ImageLoader", "=", "require('./utils/ImageLoader.min.js');", "const", "ImageSource", "=", "require('./imageSource.js');", "ImageLoader.min.js", "为加载器源文件。imageSource.js", "为图片资源路径文件。2、创建ImageLoader对象。new", "ImageLoader({", "base:", "ImageSource.BASE,", "source:", "[ImageSource],", "loading:", "res", "=>", "{", "//", "可以做进度条动画", "console.log(res);", "},", "loaded:", "res", "=>", "{", "//", "可以加载完毕动画", "console.log(res);", "}", "});", "参数base", ":", "String", "图片资源的基础路径", "必填", "示例：", "\"https://image.example.com/static/images/\"source", ":", "Array", "需要预加载的图片资源", "必填", "示例：", "[ImageSource.banners,", "ImageSource.imageList]loading", ":", "function", "图片加载中的回调方法", "非必填", "示例：loaded", ":", "funciton", "图片记载完成后的回调", "非必填", "示例:加载器（ImageLoader.js）源码：let", "base", "=", "0;", "let", "Img", "=", "function(src)", "{", "this.src", "=", "src;", "this.status", "=", "false;", "this.fail", "=", "false;", "}", "let", "loop", "=", "(o,", "res)", "=>", "{", "let", "tem", "=", "Object.keys(o);", "tem.map(v", "=>", "{", "if", "(typeof", "o[v]", "===", "'object')", "{", "loop(o[v],", "res);", "}", "else", "{", "if(v", "===", "'BASE')", "{", "base", "=", "o[v];", "}", "else", "{", "res.push(o[v]);", "}", "}", "});", "}", "function", "ImageLoader(obj)", "{", "let", "arr", "=", "[];", "if(obj.loading)", "{", "this.loadingcallback", "=", "obj.loading;", "}", "if(obj.loaded)", "{", "this.loadedcallback", "=", "obj.loaded;", "}", "if(obj.base)", "{", "base", "=", "obj.base", "}", "this.insert", "=", "(item)", "=>", "{", "arr.push(item);", "};", "this.init", "=", "(o)", "=>", "{", "let", "res", "=", "[];", "loop(o,", "res);", "console.log(res)", "res.map((v)", "=>", "{", "this.insert(new", "Img(v));", "});", "this.load();", "};", "this.load", "=", "()", "=>", "{", "this.start", "=", "(new", "Date).getTime();", "arr.map((v)", "=>", "{", "let", "src", "=", "base", "?", "base", "+", "v.src:", "v.src;", "wx.getImageInfo({", "src:", "src,", "success:", "res", "=>", "{", "v.status", "=", "true;", "},", "fail:", "err", "=>", "{", "v.fail", "=", "true;", "}", "})", "});", "let", "timer", "=", "setInterval(()", "=>", "{", "let", "status", "=", "this.isLoaded();", "if", "(status)", "{", "clearTimeout(timer);", "}", "},", "200);", "setTimeout(()", "=>", "{", "clearTimeout(timer);", "},", "60000);", "};", "this.isLoaded", "=", "()", "=>", "{", "let", "status", "=", "true,", "count", "=", "0,", "fail", "=", "0;", "arr.map((v)", "=>", "{", "if", "(!v.status)", "{", "status", "=", "false;", "}", "else", "{", "count", "+=", "1;", "}", "if(v.fail)", "{", "status", "=", "true;", "fail", "+=", "1;", "}", "});", "if(status)", "{", "if(this.loadedcallback)", "{", "this.loadedcallback({", "status:", "true,", "timecost:", "(new", "Date).getTime()", "-", "this.start,", "success:", "count,", "fail:", "fail,", "totalcount:", "arr.length", "})", "}", "}", "else", "{", "if(this.loadingcallback)", "{", "this.loadingcallback({", "status:", "false,", "percent:", "count", "/", "arr.length", "});", "}", "}", "return", "status;", "};", "if(obj.source)", "{", "this.init(obj.source);", "}", "}", "module.exports", "=", "ImageLoader", "图片资源路径文件（imageSource.js）源码：module.exports", "=", "{", "\"BASE\":", "\"https://img.caibeitv.com/static_project/teacherTest/static/img/\",", "\"single1\":", "\"ghost.4449aa4.png\",", "\"single2\":", "\"ghost.4449aa4.png\",", "\"single3\":", "\"ghost.4449aa4.png\",", "\"single4\":", "\"ghost.4449aa4.png\",", "\"pages\":", "{", "\"index\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"],", "\"user\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"],", "\"home\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"],", "\"login\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"]", "},", "\"imageList\":", "[", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"", "],", "\"folders\":", "{", "\"page1\":", "\"ghost.4449aa4.png\",", "\"page2\":", "\"ghost.4449aa4.png\",", "\"inner\":", "[", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"", "],", "\"home\":", "{", "\"poster\":", "\"ghost.4449aa4.png\"", "}", "}", "}", "说明：BASE", "字段必填", "根据自我需要填写。其他图片资源支持：1、直接key：value形式把图片路径写入，如：\"single1\":", "\"ghost.4449aa4.png\"", "2、类似于pages目录把每个页面的远程资源写入到对应位置下，方便引用和管理，如：\"pages\":", "{", "\"index\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"],", "\"user\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"],", "\"home\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"],", "\"login\":", "[\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"]", "},", "3、直接以数组方式把图片堆放在一个数组里，如：\"imageList\":", "[", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"", "]", "4、随意的资源数组，对象嵌套，如：\"folders\":", "{", "\"page1\":", "\"ghost.4449aa4.png\",", "\"page2\":", "\"ghost.4449aa4.png\",", "\"inner\":", "[", "\"ghost.4449aa4.png\",", "\"ghost.4449aa4.png\"", "],", "\"home\":", "{", "\"poster\":", "\"ghost.4449aa4.png\"", "}", "}", "这样就完成了整个远程图片资源加载器的配置，可以在new", "ImageLoader()", "对象的", "loading,", "loaded回调中看到图片预加载的最终状态status，数量totalcount，成功加载的图片数量success，加载失败的图片数量fail,", "加载图片的总计耗时timecost（单位ms）。创建ImageLoader对象时source字段的说明：new", "ImageLoader({", "base:", "ImageSource.BASE,", "source:", "[ImageSource],", "loading:", "res", "=>", "{", "//", "可以做进度条动画", "console.log(res);", "},", "loaded:", "res", "=>", "{", "//", "可以加载完毕动画", "console.log(res);", "}", "});", "source字段接受一个Array类型的参数，以上文中imageSource.js中的配置来说，写了很多不同格式的数据，使用const", "ImageSource", "=", "require('./imageSource.js');", "引入后，可以直接使用ImageSource来读取各个部分的数据，因此在配置source字段时可以直接把整个ImageSource对象放入进去source:", "[ImageSource]", "也可以根据项目需要只加载其中一部分资源，如：source:", "[ImageSource.imageList,", "ImageSource.single2]", "这样加载器在执行时就会只载入source中写入的部分，而不是整个ImageSource。最后，在加载过程中如果过于耗时，可以选择在每个页面的onLoad里单独加载资源，做法类似于在app里调用，本文的示例是写在app.js的onLaunch中。如果加载时间过长可以做一个进度条或者加载动画，优化启动体验。预加载过的图片会在微信内存中缓存一到小程序进程被关闭，因此在随后的页面里可以直接使用图片。const", "app", "=", "getApp();", "const", "imgSource", "=", "require('../../imageSource.js');", "Page({", "data:", "{", "base:", "imgSource.BASE,", "src:", "imgSource.single1", "},", "onLoad:", "function", "()", "{", "console.log(imgSource)", "}", "})", "页面上的Image会立即显示，不需要重新发起加载图片请求。个人研究结果，如有错误、不足欢迎批评指正，相互探讨。个人QQ:", "837195936", "熊专栏作家熊晨沣（个人QQ:", "83719593）。小程序社区博主，坚持原创分享技术博文。本文原创发布于小程序社区。未经许可，禁止转载原文地址：小程序远程图片资源按需预加载-小程序社区/博主专区-微信小程序开发社区-微信小程序联盟"]}
{"author": "Rolan", "title": "实现一个扫描商品条码进行评价或留言的小程序（附源码） ", "content": ["对准上面的小程序码，扫一下，‘嘀’~地一声，扫码成功，打开小程序，进入小程序首页。因为手头上没有可乐，所以我找来了一只非常专业的猫，扮演一瓶330ml的可口可乐演示给大家看。摁住它，对准它的条码，扫一下，‘喵’~地一声，说明猫跑掉了，扫码失败了，去追如果‘嘀’~地一声，说明扫码成功了，这时页面就自动跳到商品详情页。然后你就可以看得到别人在可口可乐下写的留言，当然你也可以点击右下角的蓝色按钮就发表你的留言了；原理：因为一个商品对应唯一一个条码，所以扫描同一个商品条码就可以进入唯一一个留言列表；全国各地的可口可乐330ml的条形码都是一样的，扫码后都会进入同一个页面条形码就像一个暗号，一句口令，一个邮差..", "当然，不只是条形码，二维码也可以留言，比如说别人的微信二维码一般是长时间不会变的，你可以码上说别人坏话。接下来详细介绍一下每个页面的功能2.首页首页有三个部分：1.用户的信息：头像和昵称；2.轮播图-可以放一些平时要展示的图片；3.扫码按钮-点击即可打开扫描条码；当用户点击扫码按钮时，我们就调用小程序的扫码接口去扫描商品条码，当用户扫描好条码后，我们就得到了商品条码（barcode）；这时，我们就可以跳转到商品详情页面了，顺便把条码传过去，这样商品详情页才能知道用户扫的是什么商品：wx.navigateTo({", "url:", "\"/page/component/proDtl/proDtl?barcode=\"", "+", "barcode,", "//把商品条码传给商品详情页", "})", "复制代码3.商品详情页进入详情页后，我们的第一件事情：在生命周期onLoad中获取首页传过来商品条码，然后根据条码请求当前商品的留言列表，如果这个商品还没有人扫过的话，就可能没有留言，那我们只要显示“暂无留言”即可onLoad(options){", "var", "barcode", "=", "options.barcode", "?", "options.barcode:'';", "this.getProductInfo(barcode)", "//根据条码请求当前商品的留言列表", "},", "复制代码在getProductInfo（）方法中，我们会向后台请求商品留言列表；", "接着我们就把请求到的商品留言列表渲染到页面上:如果用户觉得请求到的商品名称是不对的，还可以点击名称进行编辑：最后，页面底部还有一个提交留言的小按钮：如果你要发表留言，你可以用你的食指点击它：点击按钮后，小程序就会跳到添加留言页面，顺便把商品条码信息传过去：turnToSubmit(){", "wx.navigateTo({", "url:", "\"/page/component/addNode/addNode?barcode=\"", "+", "this.data.barcode,", "})", "},", "复制代码4.添加留言页面如图，这时候我们就可以开始写我们的留言了。写完留言之后，你可以标注一下你的留言类型：如果你觉得你写的是一首诗，你可以选择类型为‘诗一首’；如果你觉得你写的是一封信，等待别人扫码阅读，你可以选择类型为‘鱼书’；如果你扫描的是一本书的条码，你可以选择类型为‘书摘’；类型的右边就是是上传图片功能，首先，我们点击'添加图片'小图标，这时就会使用小程序选择图片的接口打开相册或者直接拍照，得到图片之后，因为现在的手机图片拍照像素都比较高，导致图片比较大，上传会很慢，占服务器空间，请求也会很慢...所以为了优化用户体验，我们需要压缩一下图片然后再上传。wx.chooseImage({", "count:", "1,", "//", "默认9", "sizeType:", "['original'],", "//", "可以指定是原图还是压缩图，默认二者都有", "sourceType:", "['album',", "'camera'],", "//", "可以指定来源是相册还是相机，默认二者都有", "success:", "function", "(res)", "{", "//图片选择成功之后", "var", "tempFilePaths", "=", "res.tempFilePaths;", "self.compressedImg(res)", "//调用compressedImg方法，先把图片压缩一下", "}", "})", "复制代码虽然小程序的选择图片接口可以设置默认压缩，但好像没什么用，还是需要找其他的方法压缩一下，", "网上最普遍的图片压缩是使用了小程序提供的canvas画布，把用户上传的图片搞到画布上（....），然后根据画布上的图片高和宽判断图片是否过大，如果过大，就直接把画布按比例缩小：while", "(canvasWidth", ">", "220", "||", "canvasHeight", ">", "220)", "{", "//如果宽度或者高度大于220，我就认为图片要进一步压缩，你可以根据需求改成其他的数字", "//比例取整", "canvasWidth", "=", "Math.trunc(res.width", "/", "ratio)", "canvasHeight", "=", "Math.trunc(res.height", "/", "ratio)", "ratio++;", "}", "复制代码图片的压缩参考自：[微信小程序：利用canvas缩小图片][", "blog.csdn.net/akony/artic…", "]然后把canvas上这张压缩了的图片上传到后台服务器：......", "wx.uploadFile({", "//上传图片", "url:", "'https://mp.orancat.com/proImgUpload',", "filePath:", "photo.tempFilePath,", "//压缩后的图片", "name:", "'file',", "header:", "{", "'content-type':", "'multipart/form-data'", "},", "success:", "function", "(res)", "{", ".......", "复制代码图片上传成功之后，后台会返回上传图片的地址给我们，我们把图片渲染到页面上，用户就会知道图片上传成功了；最后点击'提交'按钮，就会把以下内容发送给后台，后台就会自动将留言保存到数据库；var", "data={", "authorName:", "userName,", "//用户昵称", "token:", "userId,", "//用户ID", "content:", "this.data.textContent,", "//留言文本内容", "imgUrl:", "userImg,", "//用户的头像", "code:", "this.data.barcode,", "//商品的条码", "typeIndex:", "this.data.typeIndex,", "//留言的类型", "nodeImgUrl:", "this.data.nodeImgUrl", "//用户上传的图片的地址", "}", "复制代码留言提交成功之后，页面会自动切回商品详情页面，这时，你就可以看到自己刚刚的留言了；5.排行榜页面有过留言的商品都会出现在排行榜页面，并且按照留言的数量多少进行排列，点击单个商品就查看该商品下的留言；6.其他实现的功能1.分页在商品详情页，有可能出现这种情况，比如说假设A商品有120条留言，如果一进A商品详情页就要加载120条留言的话，可能页面加载半天都没有出来；这样的话用户体验就会非常不好。所以相对理想的方式应该是，假设12条留言为一页，那么A商品的留言总共有10页，当我们进入A商品的详情页面时，先加载第一页（前12条留言），当我们往上滑动页面到底部时就自动加载下一页的内容，一页一页按需加载；我们使用小程序提供的OnReachBottom触底事件实现分页加载，当用户滑动留言列表到底部时触发加载下一页：onReachBottom:", "function", "()", "{", "//滑动到底部时触发", "this.setData({", "bottomLoading:", "true", "//", "显示loading提示", "})", "this.getRankList()", "//请求下一页数据", "}", "复制代码同理，排行榜页面也使用了分页加载；2.通过wx.login获取用户唯一凭证openId由于用户的昵称，头像什么的都可能随时会改变，当openID不会变，所以使用openId作为用户唯一凭证；虽然我获取了用户的Id，但暂时还没有使用到；如果以后要弄个用户个人主页或者留言回复等等可能就要用到openId；3.gif图片上传如上所述，在图片上传前，我们把图片压缩了一下", "如果图片是jpeg，png时没问题的", "但如果图片时gif动图的话，那可能会导致动图不会动了（可能直接变成jpeg图片？）", "所以我另外加了一个判断：如果图片时gif格式的话，就不压缩图片,直接上传：if(res.type=='gif'){", "if(res.width>666||res.height>666){", "//如果图片太大了，拒绝上传", "wx.hideLoading()", "wx.showModal({", "title:", "'提示',", "content:", "'动图太大了，请上传小一点的',", "showCancel:", "false", "})", "return", "false;", "}", "res.tempFilePath=res.path;", "_this.uploadImg(res)", "//上传图片", "return", "false;", "}", "复制代码这样在window和安卓下就可以上传gif图片了。苹果手机呢？？咳咳..苹果手机一打开相册选动图，动图就自动变成了jpeg的不动图...所以苹果手机暂时上传不了动图，似乎没有解决办法。。7.下载与本地电脑运行在本文底部的github地址下载源码，用微信开发者工具，填上你的小程序appId，打开项目即可；记得在开发者工具点击‘’详情‘’设置不校验域名：如果你要提交审核并分布小程序的话，你需要在公众号平台上的\"设置>开发设置\"页面上设置小程序的服务器域名如下：然后，由于一般电脑没有摄像头不能扫码，所以当你需要扫码时，你可以把下面这张条码图片保存在本地电脑上，点击扫码按钮时打开这张图片即可：当然，你也可以自己找其他的条码；另外，需要注意的是，当你在本地电脑调试时，由于我们都是使用同一个后台接口，所以你发的留言都会同步到我的小程序上，所以尽量不要发送太明显的测试留言，例如：可以发一些强颜欢笑，积极向上，人畜无害的留言，例如："]}
{"author": "admin", "title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "content": ["编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面", "1", "需要传递用户的当前", "userId，wx.navigateTo", "带值跳转。Manual", "为", "true", "设置用户走的是新增路线。新增名片页面", "1", "基本布局如下：取到", "userId。使用微信自带的", "input", "组件验证也非常好用，如", "maxLength", "属性，可以限制用户输入长度，如我这的姓名长度是最大", "5", "位，直接数字", "5", "即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中", "modalHidden2", "是模态框开关。另外", "proptText", "是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的", "bindsubmit", "事件组件，在", "button", "组件上添加", "formType=”submit”", "即可，还有点需注意的是使用表单提交功能时", "input", "需加上", "name", "属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页", "2", "页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用", "wx.navigateTo", "控制好一点，wx.navigateTo", "提供了给我们不同的", "3", "个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的", "bug", "吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload", "时我们请求必填与选填数据：*", "requiredGroup", "必填中文信息*", "notRequiredGroup", "选题中文信息*", "requiredGroupEn", "必填英文信息*", "notRequiredGroupEn", "选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以", "no", "开头requester.getOfflineCardInfoGroupFields(userId,", "cardId,function", "(res)", "{//debuggervar", "userName", "=", "res.card.userName;var", "mobile", "=", "res.card.mobile;var", "requiredGroup", "=", "res.requiredGroupCh;var", "notRequiredGroup", "=", "res.notRequiredGroupCh;var", "requiredGroupEn", "=", "res.requiredGroupEn;var", "notRequiredGroupEn", "=", "res.notRequiredGroupEn;var", "reqLen", "=", "requiredGroup.fields.length;var", "nreqLen", "=", "notRequiredGroup.fields.length;var", "reqLenEn", "=", "requiredGroupEn.fields.length;var", "nreqLenEn", "=", "notRequiredGroupEn.fields.length;self.setData({userName:", "userName,mobile:", "mobile,requireFields:", "requiredGroup.fields,notRequireFields:", "notRequiredGroup.fields,requireFieldsEn:", "requiredGroupEn.fields,notRequireFieldsEn:", "notRequiredGroupEn.fields,l1:", "reqLen,l2:", "nreqLen", "+", "reqLen,l3:", "reqLenEn", "+", "nreqLen", "+", "reqLen});self.forceUpdate();},", "function", "(code,", "msg)", "{console.info(\"code=\"", "+", "code", "+", "\"&msg=\"", "+", "msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页", "A、B、C", "定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据", "sort，和", "group.name", "数据一样：这里是因为", "#", "不支持设为", "id（就是", "id=”#”），故而进行了一个转化。点击事件：获取到当前", "ID，以及绑定数据", "toView", "为当前", "ID。首先名片列表，名片上的字母索引都在", "scroll-view", "里面，这个", "scroll-view", "必须设置好固定的高度，设置成", "100%", "与", "100vh", "是无效的，y", "轴的滚动开关打开，scroll-into-view", "需要跳转到它子元素的", "id", "上。可以看下：这个", "group.name==sortmsg，等于就是", "A==A,B==B", "同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter", "就是", "#", "底部）。"]}
{"author": "Rolan", "title": "新手入坑mpvue(没朋友)实战指南 ", "content": ["微信小程序微信小程序简称小程序，英文名Mini", "Program，也被称为微信应用号，不同于微信订阅号或公众号，微信小程序被赋予了应用程序的能力，它是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用；也体现了“用完即走”的理念，用户不再需要关心是否安装太多应用的问题。目前开发小程序，大多数都是通过看小程序的官网原生开发官网：https://developers.weixin.qq....Mpvue没朋友mpvue是一个使用", "Vue.js", "开发小程序的前端框架，由美团点评技术团队开发在2018年3月开源。框架基于", "Vue.js", "核心，mpvue", "修改了", "Vue.js", "的", "runtime", "和", "compiler", "实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套", "Vue.js", "开发体验。mpvue官网：http://mpvue.com/github地址：https://github.com/Meituan-Di...为啥好好的小程序原生开发需要加入vuejs？1.小程序不能使用npm,使用第三方包的方式太原始2.需要为小程序单独开发代码，不能和web系统重用3.开发效率和学习成本（小程序的特有的语法）mpvue和wepy对比最后mpvue是怎么胜出的？wepy官网：https://tencent.github.io/wepy/用一张图来简单概括下mpvue/wepy/原生小程序的区别：再多说点mpvue的介绍（内容从参加美团点评技术峰会上Get）mpvue的使用场景可以分为：1.单独使用mpvue(标准的使用方式，quickstart)2.mpvue为主，辅以其他3.mpvue做增量开发（使用mpvueSimple轻量化构建工具）更多的内容戳下面的地址：美团点评技术沙龙第35期：北京站-前端热点技术的企业级实践-回放地址：http://www.itdks.com/eventlis...如何迈出跳进mpvue的第一步官网有个五分钟教程，当然，你也可以再看一遍我搬运过来的二分钟教程#", "1.", "先检查下", "Node.js", "是否安装成功", "$", "node", "-v", "v8.9.0", "$", "npm", "-v", "5.6.0", "#", "2.", "由于众所周知的原因，可以考虑切换源为", "taobao", "源", "$", "npm", "set", "registry", "https://registry.npm.taobao.org/", "#", "3.", "全局安装", "vue-cli", "#", "一般是要", "sudo", "权限的", "$", "npm", "install", "--global", "vue-cli", "#", "4.", "创建一个基于", "mpvue-quickstart", "模板的新项目", "#", "新手一路回车选择默认就可以了", "$", "vue", "init", "mpvue/mpvue-quickstart", "my-project", "#", "5.", "安装依赖，走你", "$", "cd", "my-project", "$", "npm", "install", "$", "npm", "run", "dev执行上面的命令后，一路下来的应该长成这样子这里不要忘记npm", "install，下面该打开生成项目了，拆箱图解如下好了，接下来就是你大展身手的时候了~豆瓣读书：（一）图书扫码首先第一步你旁边要现有一本书，翻到书的B面，看到后面的条码就是即将要扫的东西开始写代码，扫码这个API肯定是用小程序的，打开小程序文档找到扫码接口：https://developers.weixin.qq....提供的示例代码，一会就能直接复制了//", "允许从相机和相册扫码", "wx.scanCode({", "success:", "(res)", "=>", "{", "console.log(res)", "}", "})", "//", "只允许从相机扫码", "wx.scanCode({", "onlyFromCamera:", "true,", "success:", "(res)", "=>", "{", "console.log(res)", "}", "})修改index.vue", "毕竟它才是主页，像平时vue一样，加点击事件只不过方法里面的内容换成了小程序的API准备就绪后，在微信开发者工具里面点击预览，就可以拿出你的手机扫一扫了，在console控制台可以看到的输出的ISBN码", "9787535732309", "，打开豆瓣读书官网搜索一下这就完成了扫码的过程，拿到图书的ISBN码之后，存数据库或者干嘛都可以了豆瓣读书：（二）图书列表图书列表的数据来源使用easy-mockeasy-mock(https://www.easy-mock.com)是...，模拟后端的接口完成数据请求绑定，其实就是把之前本地写死的JSON文件，换了一个地方写，前端不用等待后端的接口开发完成再进行工作，可以同后端协商好数据格式后就开工了下图是easy-mock创建接口后进入到的编辑页面，大刀破斧的写你的json数据吧数据写完后，地址栏的URL就是一会要访问的接口地址，回到项目中来发送请求即可，还是写在index.vue下<template>", "<div>", "<button", "@click=\"scanCode()\">", "扫描图书", "</button>", "<h3>图书列表</h3>", "<div", "v-bind:key='book.isbn'", "v-for='book", "in", "books'>{{book.title}}</div>", "</div>", "</template>", "<script>", "import", "axios", "from", "\"axios\";", "export", "default", "{", "data:{", "books:", "[]", "},", "methods:", "{", "scanCode()", "{", "wx.scanCode({", "success:", "res", "=>", "{", "console.log(res);", "}", "});", "}", "},", "mounted()", "{", "wx.request({", "url:", "\"https://www.easy-mock.com/mock/5b3ec93b119b373c0443793d/mpvuedata/list\",", "success:", "res", "=>", "{", "this.books", "=", "res.data.data;", "}", "});", "}", "};", "</script>", "<style", "scoped>", "h3{", "font-size:60rpx;", "}", "div{", "font-size:", "40rpx;", "}", "</style>", "运行后结果就会把数据动态的输出出来了最后彩蛋稍微总结下，通过上面做的两个功能（扫码、图书列表数据绑定）已经可以知道如何使用mpvue进行小程序的开发，如需调用其他的API使用方法同扫码功能，做数据请求同图书列表功能一样，希望本文帮助新入坑mpvue的小伙伴成功进坑~如果本文对你有一丢丢帮助，可以点击赞赏请我喝可乐", "~", "——来自mpvue坑里的声音"]}
{"author": "Rolan", "title": "小程序开发技巧总结 ", "content": ["最近公司要开发一款电商小程序，匆忙看了一遍文档就开始干活了。整体开发体验个人感觉不太好，特别是如果之前习惯了Vue开发，突然去开发小程序，感觉很鸡肋。以下是我在开发中遇到的一些问题以及解决方法的总结，仅供参考引入iconfont在小程序中引入字体图标要比web麻烦一些，简单说需要三步：下载iconfont，把iconfont.css复制到iconfont.wxss，在app.wxss中引入查看iconfont在unicode模式下的在线链接，替换iconfont.wxss中的链接为远程链接在wxml文件中引入对应的icon", "class<icon", "class=\"iconfont", "icon-pay\"></icon>", "复制代码使用lessvscode有一个easy", "less插件，是我感觉使用less最简单的方式vscode安装easy", "less插件创建一个less目录，用于存放less文件文件头部添加编译注释", "//", "out:", "../pages/index/index.wxss,", "compress:", "true,", "sourceMap:", "falsectrl", "+", "s保存后自动编译编译后的结果按钮重置小程序中的按钮功能强大，很多功能必须要用按钮，比如弹出用户授权，调用客服功能。默认的样式一般无法满足需求，可以把按钮样式统一重置，然后自己写样式button", "{", "padding:", "0;", "background:", "#fff;", "line-height:", "0;", "&::after", "{", "border-color:", "transparent;", "}", "}", ".button-hover", "{", "background:", "#fff;", "}", "复制代码支持async-awaitasync-await是ES7的语法，截止我写这篇文章为止，小程序还是不支持async-await语法的，所以需要使用regenerator这个库下载regenerator，并把regenerator-runtime并放到utils目录下2.", "在util.js引入", "import", "regeneratorRuntime", "from", "'./regenerator-runtime/runtime-module'封装wxRequest，让它支持async-awaitconst", "wxRequest", "=", "async", "(url,", "params", "=", "{})", "=>", "{", "Object.assign(params,", "{", "token:", "wx.getStorageSync('token')", "})", "//", "所有的请求，header默认携带token", "let", "header", "=", "params.header", "||", "{", "'Content-Type':", "'application/json',", "'token':", "params.token", "||", "''", "}", "let", "data", "=", "params.data", "||", "{}", "let", "method", "=", "params.method", "||", "'GET'", "//", "hideLoading可以控制是否显示加载状态", "if", "(!params.hideLoading)", "{", "wx.showLoading({", "title:", "'加载中...',", "})", "}", "let", "res", "=", "await", "new", "Promise((resolve,", "reject)", "=>", "{", "wx.request({", "url:", "url,", "method:", "method,", "data:", "data,", "header:", "header,", "success:", "(res)", "=>", "{", "if", "(res", "&&", "res.statusCode", "==", "200)", "{", "resolve(res.data)", "}", "else", "{", "reject(res)", "}", "},", "fail:", "(err)", "=>", "{", "reject(err)", "},", "complete:", "(e)", "=>", "{", "wx.hideLoading()", "}", "})", "})", "return", "res", "}", "export", "{", "wxRequest", "}", "复制代码使用方法：import", "regeneratorRuntime", "from", "'../../utils/regenerator-runtime/runtime-module.js'", "import", "{", "wxRequest", "}", "from", "'../../utils/util.js'", "Page({", "data:", "{", "list:[],", "count:", "0,", "page:", "1,", "limit:", "10", "},", "onLoad:", "function()", "{", "this.getList()", "//", "请求已经结束", "做其他事", "},", "getList:", "async", "function()", "{", "await", "wxRequest(app.globalData.baseUrl", "+", "'/test',{", "hideLoading:", "true,", "data:", "{", "limit:", "this.data.limit,", "page:", "this.data.page", "}", "}).then((ret)", "=>", "{", "this.setData({", "list:", "ret.data.data,", "count:", "ret.data.num", "})", "})", "}", "})", "复制代码封装之后用起来还是很爽的，扩展起来也方便动态设置data中某个值应用场景：循环出来的列表，需要根据点击项，动态改变列表中对应id的数据//", "动态传递id", "<block", "wx:for=\"{{list}}\"", "wx:key=\"{{index}}\">", "<view", "catch:tap=\"onChangeName\"", "data-id=\"{{item.id}}\"></view>", "</block>", "Page({", "data:", "{", "list:[{", "id:", "0,", "name:", "'wang'", "},{", "id:", "1,", "name:", "'li'", "}]", "},", "onChangeName:", "function(event){", "//", "拿到id", "let", "id", "=", "event.target.dataset.id", "let", "key", "=", "`list[${id}].name`,", "val", "=", "'zhang'", "//", "设置值", "this.setData({", "[key]:", "val", "})", "}", "})", "复制代码flex布局，溢出省略号无效订单列表一般都是左边一个图片，右边是标题或描述。这时候图片宽度是固定的，标题长度自适应.wrap", "{", "display:", "flex;", "}", ".sub", "{", "flex:", "1;", "width:", "0;", "//", "宽度设为0", "}", ".sub", "text", "{", "display:", "block;", "//", "一定要设置成block", "}", "<view", "calss=\"wrap\">", "<image", "src=\"i.png\"/>", "<view", "class=\"sub\">", "<text>一段文本一段文本一段文本一段文本一段文本一段文本</text>", "<view>其他</view>", "</view>", "</view>", "复制代码组件事件传递任务：父组件向子组件传递初始数据，当子组件点击以后可以triggerEvent自定义事件，父组件执行自定义事件，重新请求数据并传给子组件/*", "子组件", "*/", "<view>", "<view", "bind:tap=\"setId\"", "data-id=\"1\"></view>", "</view>", "properties:", "{", "list:", "{", "type:", "Array,", "default:", "[]", "}", "},", "methods:", "{", "setId(e)", "{", "let", "id", "=", "e.currentTarget.dataset.id", "this.triggerEvent('deleteFav',", "id)", "}", "}", "/*", "父页面", "*/", "<child", "bind:customEvent=\"deleteFav\"></child>", "data:", "{", "list:", "[]", "},", "deleteFav(e)", "{", "let", "id", "=", "e.detail", "//", "获取传递过来的数据", "//", "根据id请求数据，然后重新setData", "let", "newData", "=", "[1,2,3]", "this.setData({", "list:", "newData", "})", "}", "复制代码使用wxParse解析HTML下载", "wxParse", "，放到utils目录下在JS页面引入：", "import", "WxParse", "from", "'../../utils/wxParse/wxParse'Page({", "data:{", "contentHTML:''", "//", "解析后的HTML", "},", "onLoad:", "function()", "{", "//", "请求到的HTML数据", "let", "content", "=", "'<div>我是HTML代码</div>',", "that", "=", "this;", "WxParse.wxParse('contentHTML',", "'html',", "content,", "that,", "0);", "}", "})", "复制代码显示解析内容<import", "src=\"../../utils/wxParse/wxParse.wxml\"/>", "<view>", "<!--", "显示内容", "-->", "<template", "is=\"wxParse\"", "data=\"{{wxParseData:contentHTML.nodes}}\"", "/>", "</view>", "复制代码图片等比例image标签有个mode属性，可以设置图片如何显示，如果文档看的不仔细还真容易发现<image", "src=\"test.png\"", "mode=\"widthFix\"/>", "复制代码上拉加载和下拉刷新{", "\"onReachBottomDistance\":", "0,", "\"enablePullDownRefresh\":", "true", "}", "复制代码data:", "{", "limit:", "30,", "page:", "1,", "list:[],", "count:0", "},", "//", "下拉", "onPullDownRefresh:", "function", "()", "{", "this.setData({", "page:", "1,", "list:[]", "})", "this.getData()", "},", "//", "上拉", "onReachBottom:", "function", "()", "{", "if(this.data.list.length", ">=", "this.data.count)", "{", "return", "false", "}", "this.setData({", "page:", "this.data.page", "+", "1", "})", "this.getData()", "wx.stopPullDownRefresh()", "},", "getData:", "async", "function", "()", "{", "await", "wxRequest(app.globalData.baseUrl", "+", "'/test',", "{", "data:", "{", "page:", "this.data.page,", "limit:", "this.data.limit,", "}", "}).then((ret)", "=>", "{", "let", "list", "=", "this.data.list.concat(ret.data.list)", "this.setData({", "list:", "list,", "count:", "ret.data.count", "})", "})", "}", "复制代码上传图片任务：小程序上传图片到服务器，最多上传三张，前端可以删除图片效果图如下使用到的API有两个：wx.uploadFile", "wx.chooseImage示例WXML：<view", "class=\"sale", "after-pic\">", "<block", "wx:for=\"{{imgList}}\"", "wx:key=\"{{index}}\">", "<view", "class=\"pic\">", "<image", "src=\"{{item}}\"", "/>", "<icon", "type=\"clear\"", "size=\"20\"", "catchtap=\"clearImg\"", "data-id=\"{{index}}\"/>", "</view>", "</block>", "<image", "src=\"../../images/upload.png\"", "catchtap=\"chooseImage\"", "/>", "</view>", "<button", "catchtap=\"onSub\">提交</button>", "复制代码imgList是wx.chooseImage成功后返回的图片临时地址示例JSPage({", "data:", "{", "imgList:[]", "},", "//", "使用async", "await是因为图片上传是异步的", "onSub:", "async", "function()", "{", "//", "点击提交后，开始上传图片", "let", "imgUrls", "=", "[]", "for", "(let", "index", "=", "0;", "index", "<", "this.data.imgList.length;", "index++)", "{", "await", "this.uploadFile(this.data.imgList[index]).then((res)", "=>", "{", "//", "这里要注意把res.data", "parse一下，默认是字符串", "let", "parseData", "=", "JSON.parse(res.data)", "imgUrls.push(parseData.data)", "//", "图片地址", "})", "}", "console.log(imgUrls)", "//", "3张图片上传成功后，执行其他操作", "},", "//", "删除某张图片", "clearImg:", "function", "(params)", "{", "let", "imgList", "=", "this.data.imgList", "let", "id", "=", "params.currentTarget.dataset.id", "//", "图片索引", "imgList.splice(id,", "1)", "//", "删除", "this.setData({", "imgList:", "imgList", "})", "},", "chooseImage:", "function", "(params)", "{", "wx.chooseImage({", "count:", "3,", "//", "做多3张", "sizeType:", "['original',", "'compressed'],", "sourceType:", "['album',", "'camera'],", "success:", "(res)", "=>", "{", "//", "存储临时地址", "this.setData({", "imgList:", "res.tempFilePaths", "})", "}", "})", "},", "uploadFile:", "function", "(filePath)", "{", "//", "返回Promise是为了解决图片上传的异步问题", "return", "new", "Promise(", "(resolve,", "reject)", "=>", "{", "wx.uploadFile({", "url:", "app.globalData.baseUrl", "+", "'/file/upload',", "//", "上传地址", "filePath:", "filePath,", "name:", "'file',", "//", "这里的具体值，问后端人员", "formData:", "{},", "header:", "{", "\"Content-Type\":", "\"multipart/form-data\"", "},", "success:", "(res)", "=>{", "//", "图片上传成功后，后端会返回一个地址，可以把它存到imgUrls", "this.imgUrls.push(res.data.data)", "},", "fail:(err)", "=>", "{", "console.log(err)", "}", "})", "})", "}", "})", "复制代码动态标题onLoad的时候动态设置标题wx.setNavigationBarTitle({", "title:", "'新标题'", "})", "复制代码结语以上是仅为我个人在开发过程中遇到的一些问题，若有错误还请批评指正，感谢阅读."]}
{"author": "Rolan", "title": "微信小程序使用相机 ", "content": ["<view", "class=\"page-body\">", "<view", "class=\"page-body-wrapper\">", "<camera", "device-position=\"back\"", "flash=\"off\"", "binderror=\"error\"", "style=\"width:", "100%;", "height:", "300px;\"></camera>", "<view", "class=\"btn-area\">", "<button", "type=\"primary\"", "bindtap=\"takePhoto\">拍照</button>", "</view>", "<view", "class=\"btn-area\">", "<button", "type=\"primary\"", "bindtap=\"startRecord\">开始录像</button>", "</view>", "<view", "class=\"btn-area\">", "<button", "type=\"primary\"", "bindtap=\"stopRecord\">结束录像</button>", "</view>", "<view", "class=\"preview-tips\">预览</view>", "<image", "wx:if=\"{{src}}\"", "mode=\"widthFix\"", "src=\"{{src}}\"></image>", "<video", "wx:if=\"{{videoSrc}}\"", "class=\"video\"", "src=\"{{videoSrc}}\"></video>", "</view></view>", "onLoad()", "{", "this.ctx", "=", "wx.createCameraContext()", "},", "takePhoto()", "{", "this.ctx.takePhoto({", "quality:", "'high',", "success:", "(res)", "=>", "{", "this.setData({", "src:", "res.tempImagePath", "})", "}", "})", "},", "startRecord()", "{", "this.ctx.startRecord({", "success:", "(res)", "=>", "{", "console.log('startRecord')", "}", "})", "},", "stopRecord()", "{", "this.ctx.stopRecord({", "success:", "(res)", "=>", "{", "this.setData({", "src:", "res.tempThumbPath,", "videoSrc:", "res.tempVideoPath", "})", "}", "})", "},", "error(e)", "{", "console.log(e.detail)", "}/*", "pages/one/one.wxss", "*/.preview-tips", "{", "margin:", "20rpx", "0;", "}.video", "{", "margin:", "50px", "auto;", "width:", "100%;", "height:", "300px;}"]}
{"author": "Rolan", "title": "支付宝小程序日期选择组件 datePicker 封装 ", "content": ["项目地址", "https://github.com/iocool/antminDatePicker另博客地址", "https://www.cnblogs.com/iocool/p/9397816.html最近在做支付宝小程序(以下简称小程序)开发,发现小程序的日期选择组件很不好用,比如安卓和IOS设备上,样式明显不同,因为小程序调用该组件是调用系统原生组件,所以会有一定的差异,另外,小程序提供的日期组件并不满足我当前的业务需求:该日期为快递上门时间.用户只可选择的日期范围,当日往后", "2", "天(即", "今天", ",", "明天", ")的日期,并且时间选择为早上", "9", "点至下午", "18", "点间的", "10", "个小时整点时间.由于是快递上门,所以可选择的时间点为当前时间点", "2", "小时后(比如,现在时间是11点,用户可选择的最早时间为13点).如果当前时间晚于下午", "18", "点,则用户应该可以看到", "明天", "及", "后天", "2", "天的时间点.针对以上需求,借助小程序的", "picker-view", "组件,进行了二次封装,以下是封装后的组件.示例项目结构.", "├──", "README.md", "├──", "app.acss", "├──", "app.js", "├──", "app.json", "├──", "components", "//", "组件目录", "│", "└──", "dateTimePicker", "//", "日期组件目录", "│", "├──", "datePickerBase.js", "//", "基础", "js", "文件,需在使用文件中引入", "│", "├──", "dateTimePicker.acss", "//", "组件默认样式,除非特殊需要,一般不用修改", "│", "├──", "dateTimePicker.axml", "//", "组件默认结构", "│", "├──", "dateTimePicker.js", "//", "组件", "js", "│", "├──", "dateTimePicker.json", "//", "组件配置信息", "│", "└──", "js", "│", "├──", "handleDateArr.js", "//", "日期数组处理的", "js", ",用以生成所需的日期数组", "│", "└──", "moment.min.js", "//", "时间生成使用", "moment.js", "│", "└──", "pages", "//", "示例目录", "└──", "index", "├──", "index.acss", "├──", "index.axml", "├──", "index.js", "└──", "index.json", "复制代码使用说明支付宝小程序的组件引用方法,及使用说明,可参照", "支付宝使用自定义组件", "查看,也可参照本示例中", "pages/index", "下的使用方法.pages/index/index.json", "需配置", "usingComponents", ",", "填写组件路径{", "\"defaultTitle\":", "\"日期选择picker", "demo\",", "\"usingComponents\":", "{", "\"picker\":", "\"../../components/dateTimePicker/dateTimePicker\"", "}", "}", "复制代码pages/index/index.js", "引入基础文件,详细配置及使用说明,参照", "js", "文件内容//", "引入基础初始", "import", "datePicker", "from", "'../../components/dateTimePicker/datePickerBase'", "复制代码pages/index/index.axml", "使用", "picker", "组件<picker", "title=\"{{datePicker.title}}\"", "class=\"{{datePicker.class}}\"", "visible=\"{{datePicker.visible}}\"", "onHidePicker=\"hidePicker\"", "onConfirm=\"onConfirm\"", "pickerValue=\"{{datePicker.defaultValue}}\"", "/>", "复制代码其中title", "//", "组件标题", "class", "//", "组件样式,可以自定义", "visible", "//", "组件显示/隐藏", "onHidePicker", "//", "隐藏该组件的事件", "onConfirm", "//", "点击组件弹窗确定后的事件,onConfirm(str),其中", "str", "为最终回调的参数,可取到", "picker", "的值", "pickerValue", "//", "默认参数,用来初始的时候用,传入数据是", "picker", "的索引值,默认(0,0),即", "默认选中两列", "picker", "的第一项", "复制代码一些其他的说明组件的封装过程中,由于采用的是支付宝的", "picker-view", "所以在界面上没有花过多的时间,主要可能还是日期时间数组的生成需要处理一下,借助了", "moment.js", "库,对于时间处理上还是很方便的,以下是对处理日期数组", "handleDateArr.js", "的代码说明.//", "依赖于", "moment.js", "const", "Moment", "=", "require('./moment.min')", "/**", "*", "生成日期时间数组", "*", "@param", "dayLength", "//", "要生成的天数时长,不传的话,默认生成", "1", "天", "*", "@param", "timeSection", "//", "时间区间,默认", "10", ",", "可下单区间早上9点到下午6点,可下单时间在当前小时后2小时", "*/", "function", "getDaysArr(dayLength,", "timeSection){", "let", "_daysArr", "=", "[[],[]]", "let", "_dayLength", "=", "dayLength", "||", "1", "const", "_timeSection", "=", "timeSection", "||", "10", "const", "_nowHour", "=", "Moment().format('HH')", "//", "当前时间", "小时", "const", "_expressHour", "=", "parseInt(_nowHour)", "+", "2", "//", "可下单时间,当前时间", "+2", "const", "_earlyHour", "=", "9", "//", "最早时间", "const", "_endHour", "=", "19", "//", "截止时间", "for(let", "i", "=", "0;", "i", "<", "_dayLength;", "i++){", "//", "当天时间处理", "if(", "i", "===", "0){", "if(_expressHour", "<=", "_earlyHour", "){", "//", "早于早上", "9点时", "_daysArr[1].push(getHoursArr(_earlyHour,", "_timeSection))", "//", "处理日期", "_daysArr[0].push(Moment().add(i,", "'days').format('YYYY-MM-DD'))", "}", "else", "if(", "_expressHour", ">", "_earlyHour", "&&", "_expressHour", "<", "_endHour){", "//", "晚于早上", "9", "点,", "早于下午", "18", "点之前", "_daysArr[1].push(getHoursArr(_expressHour,", "(_endHour", "-", "_expressHour)))", "//", "处理日期", "_daysArr[0].push(Moment().add(i,", "'days').format('YYYY-MM-DD'))", "}", "else", "if", "(", "_expressHour", ">=", "_endHour", "&&", "_expressHour", "<", "24){", "//", "超过晚上", "19", "点之后,日期天数增加一天", "_dayLength++", "}", "}", "else", "{", "//", "其他日期时间处理", "//", "早于早上", "9点时", "_daysArr[1].push(getHoursArr(_earlyHour,", "_timeSection))", "//", "处理日期", "_daysArr[0].push(Moment().add(i,", "'days').format('YYYY-MM-DD'))", "}", "}", "/**", "*", "获取小时时间数组", "*", "@param", "nowHour", "//", "当前小时", "*", "@param", "hoursLength", "//", "小时区间长度", "*/", "function", "getHoursArr(nowHour,", "hoursLength)", "{", "let", "_hoursArr", "=", "[]", "for(let", "j", "=", "0", ";", "j", "<", "hoursLength;", "j++){", "_hoursArr.push(`${nowHour", "+", "j}:00:00`)", "}", "return", "_hoursArr", "}", "return", "_daysArr", "}", "module.exports", "=", "{", "getDaysArr", "}", "复制代码在", "dateTimePicker.js", "文件中使用", "handleDateArr.js", "的方法...", "const", "{", "getDaysArr", "}", "=", "require('./js/handleDateArr');", "//", "引入处理函数", "Component({", "data:", "{", "...", "},", "methods:", "{", "//", "获取日期数据", "doGetDaysArr()", "{", "this.setData({", "dateTimeData:", "getDaysArr(2)", "//", "传入参数,需返回的日期天数,2天", "});", "}", "}", "});", "...", "复制代码以上就是该组件的基本说明,代码相对比较简单,觉得可以给目前在做支付宝小程序并有相关需要的童鞋参考一下."]}
{"author": "Rolan", "title": "小程序页面效果 - 下载图片并且显示进度 ", "content": ["图片效果wxmljs", "1", "downImg:", "function(e)", "{", "2", "var", "_this", "=", "this;", "3", "4", "//", "获取图片地址(http://www.playsort.cn/...)", "5", "var", "img", "=", "e.currentTarget.dataset.src;", "6", "7", "//", "下载监听进度", "8", "const", "downloadTask", "=", "wx.downloadFile({", "9", "url:", "img,", "10", "success:", "function(res)", "{11", "//", "只要服务器有响应数据，就会把响应内容写入文件并进入", "success", "回调，业务需要自行判断是否下载到了想要的内容12", "console.log(res)13", "if", "(res.statusCode", "===", "200)", "{14", "wx.saveImageToPhotosAlbum({15", "filePath:", "res.tempFilePath,16", "success:", "function(res)", "{17", "wx.showToast({18", "title:", "'保存图片成功!~',19", "});20", "},21", "fail:", "function(res)", "{22", "wx.showToast({23", "title:", "'保存图片失败!~',24", "});25", "}26", "})27", "}28", "}29", "});30", "downloadTask.onProgressUpdate((res)", "=>", "{31", "if", "(res.progress", "===", "100)", "{32", "this.setData({33", "progress:", "''34", "});35", "}", "else", "{36", "this.setData({37", "progress:", "res.progress", "+", "'%'38", "});39", "}40", "});41", "}"]}
{"author": "Rolan", "title": "微信小程序之支付密码输入demo ", "content": ["在小程序中实现支付密码的输入，要解决几个问题：", "1、小程序要想唤起键盘，必须要借助input控件。通过input控件和其属性focus来唤起和隐藏输入键盘。2、要让input控件不可见。让光标和输入的字符都不可见，这里是把input控件定位到左边不可见范围。先看实现后的效果图：实现demo代码：1、页面代码<view", "catchtap='showInputLayer'", "class=\"btn_pay\">立即支付</view><!--", "密码输入框", "--><view", "wx:if='{{showPayPwdInput}}'>", "<view", "class='bg_layer'></view>", "<view", "class='input_main'>", "<view", "class='input_title'>", "<view", "class='input_back'", "catchtap='hidePayLayer'><text></text></view>", "<text>输入支付密码</text>", "</view>", "<view", "class='input_tip'><text>使用会员卡余额支付需要验证身份，验证通过后才可进行支付。</text></view>", "<view", "class='input_row'", "catchtap='getFocus'>", "<view", "class='pwd_item'", "wx:for='{{6}}'", "wx:key='item'", "wx:for-index='i'>", "<text", "wx:if='{{pwdVal.length>i}}'></text>", "</view>", "</view>", "<view", "class='forget_pwd'", "catchtap='hidePayLayer'>忘记密码</view>", "<input", "class='input_control'", "password", "type='number'", "focus='{{payFocus}}'", "bindinput='inputPwd'", "maxlength='6'/>", "</view></view>2、js代码//index.js//获取应用实例const", "app", "=", "getApp()Page({", "data:", "{", "showPayPwdInput:", "false,", "//是否展示密码输入层", "pwdVal:", "'',", "//输入的密码", "payFocus:", "true,", "//文本框焦点", "},", "onLoad:", "function", "()", "{", "this.showInputLayer();", "},", "/**", "*", "显示支付密码输入层", "*/", "showInputLayer:", "function(){", "this.setData({", "showPayPwdInput:", "true,", "payFocus:", "true", "});", "},", "/**", "*", "隐藏支付密码输入层", "*/", "hidePayLayer:", "function(){", "var", "val", "=", "this.data.pwdVal;", "this.setData({", "showPayPwdInput:", "false,", "payFocus:", "false,", "pwdVal:", "''", "},", "function(){", "wx.showToast({", "title:", "val,", "})", "});", "},", "/**", "*", "获取焦点", "*/", "getFocus:", "function(){", "this.setData({", "payFocus:", "true", "});", "},", "/**", "*", "输入密码监听", "*/", "inputPwd:", "function(e){", "this.setData({", "pwdVal:", "e.detail.value", "});", "if", "(e.detail.value.length", ">=", "6){", "this.hidePayLayer();", "}", "}})3、样式.btn_pay{", "margin:", "100rpx", "auto;", "width:", "600rpx;", "height:", "100rpx;", "line-height:", "100rpx;", "border-radius:", "100rpx;", "background-color:", "#d3a95a;", "color:", "#fff;", "font-size:", "36rpx;", "text-align:", "center;", "}/*", "支付密码css", "start", "*/.bg_layer{", "position:", "fixed;", "left:", "0;", "top:", "0;", "bottom:", "0;", "right:", "0;", "background-color:", "rgba(0,", "0,", "0,", "0.6);", "z-index:", "9998;}.input_main{", "position:", "fixed;", "left:", "0;", "bottom:", "500rpx;", "width:", "100%;", "height:", "394rpx;", "background-color:", "#fff;", "z-index:", "9999;}.input_title{", "width:", "100%;", "height:", "90rpx;", "line-height:", "90rpx;", "text-align:", "center;", "font-size:", "32rpx;", "border-bottom:", "1rpx", "solid", "#e2e2e2;}.input_back{", "position:", "absolute;", "left:", "0;", "top:", "0;", "width:", "80rpx;", "height:", "90rpx;", "display:", "flex;", "justify-content:", "center;", "align-items:", "center;}.input_back", "text{", "width:", "20rpx;", "height:", "20rpx;", "background-color:", "white;", "border:", "1rpx", "solid", "#aaa;", "border-width:", "5rpx", "0", "0", "5rpx;", "transform:", "rotate(-45deg);}.input_tip{", "margin:", "30rpx;", "font-size:", "24rpx;", "color:", "#888;", "}/*", "密码掩码模拟", "*/.input_row{", "width:", "690rpx;", "margin:", "0", "auto;", "height:", "98rpx;", "position:", "relative;", "display:", "flex;", "align-items:", "center;", "border:", "1rpx", "solid", "#e2e2e2;", "border-radius:", "20rpx;}.input_row", ".pwd_item{", "flex:", "1;", "display:", "flex;", "align-items:", "center;", "justify-content:", "center;", "height:", "100%;", "border-right:", "1rpx", "solid", "#e2e2e2;", "position:", "relative;}.pwd_item:nth-last-of-type(1)", "{", "border-right:", "0;", "}", ".pwd_item", "text", "{", "width:", "30rpx;", "height:", "30rpx;", "border-radius:", "30rpx;", "background-color:", "#555;}.forget_pwd{", "float:", "right;", "margin:", "30rpx;", "width:", "100rpx;", "text-align:", "right;", "font-size:", "24rpx;", "color:", "#ff7800;}/*", "文本输入框位置:", "设置到左边隐藏", "*/.input_control", "{", "position:", "relative;", "left:", "-300rpx;", "bottom:", "0;", "width:", "100rpx;", "height:", "100rpx;}DEMO地址：https://github.com/xiaotanit/Tan_PayPwdInput"]}
{"author": "Rolan", "title": "如何在小程序wxml文件中编写js代码 ", "content": ["当我们创建页面时发现有个.wxs文件发现有个.wxs文件，关于wxs文件如何使用呢？", "WXS（WeiXin", "Script）是小程序的一套脚本语言，结合", "WXML，可以构建出页面的结构。", "wxs可以说就是为了满足能在页面中使用js存在的，在wxml页面中，只能在插值{{", "}}中写简单的js表达式，而不能调用方法，例如直接在wxml页面中直接保留数据的小数点的后两位。", "通常的解决办法是在page的data对象中先把这个数据截赋给某个变量，然后在页面中使用这个变量，但是问题又来了，如果变量多了呢，是不是要定义很多次。", "相对来说wxml中使用js语法就比较薄弱了，wxs就是弥补了这样的短处。", "关于wxs文件的使用方法如下：", ".wxs的实例代码为：<!--", "page/tools.wxs", "-->var", "bar", "=", "function", "(a,b)", "{var", "total", "=", "a", "*", "b;total", "=", "total.toFixed(2);//保留两位小数return", "total;}module.exports", "=", "{", "bar:", "bar};在wxml中引用代码：<!--", "page/index/index.wxml", "--><wxs", "src=\"./../tools.wxs\"", "module=\"tools\"", "/><view>", "{{tools.bar(2,3)}}", "</view>最后输出结果如图：结果注意：wxs", "不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。", "wxs", "与", "javascript", "是不同的语言，有自己的语法，并不和", "javascript", "一致。", "wxs", "的运行环境和其他", "javascript", "代码是隔离的，wxs", "中不能调用其他", "javascript", "文件中定义的函数，也不能调用小程序提供的API。", "wxs", "函数不能作为组件的事件回调。", "由于运行环境的差异，在", "iOS", "设备上小程序内的", "wxs", "会比", "javascript", "代码快", "2", "~", "20", "倍。在", "android", "设备上二者运行效率无差异。"]}
{"author": "Rolan", "title": "防踩坑指南：对接支付渠道二三事 ", "content": ["今天要分享的内容，会以商家的视角去分析对接渠道过程中需要关注的问题。一.", "支付渠道业务规则这部分内容主要介绍常见支付渠道的业务规则以及选择渠道过程中需要关注哪些重点，主要面向商家的业务部门，方便根据自身业务模式匹配最合适的支付渠道。1.", "产品概述和应用场景要想了解支付渠道的业务规则，首先需要知道目前主要的支付渠道、支付产品有哪些，是什么模式，然后商家根据自身产品及业务模式去匹配最优的支付方式。一般情况下对接的支付渠道有两类：银行：招行、建行、农行等支付机构：微信、支付宝、京东等每个渠道有自己的收款产品，对应在不同的支付终端上使用。这里讲一下，「支付终端」换成「支付场景」也是合适的，不同公司团队个人叫法可能有所不同，总之方便理解来看就是电脑网站、手机网站以及手机应用等等。这里将各个渠道的收付款产品放到了对应的支付终端下，不同支付终端下支持的渠道支付产品也有所区别，且需要独立申请开通权限。微信在移动应用、手机网页、pc", "网页、公众号内、线下扫码、微信小程序中的支付产品分别是：APP", "支付、H5", "支付、扫码支付、公众号支付（仅能在微信浏览器内支付）、刷卡支付（也包含扫码支付", "）、小程序支付（", "其中小程序内不能使用其他渠道的支付产品）。扫码支付和刷卡支付的区别是，前者是用户扫商家码，后者是用户的支付码被商家扫。其中需要注意的是，APP", "支付和公众号支付需要分别在开放平台和公众平台进行申请开通。开通公众号支付后，默认会开通扫码支付和刷卡支付的产品权限。H5", "支付功能是在微信商户平台上开通的支付产品权限，前提是至少开通APP支付、小程序支付、公众号支付的其中一种支付权限。分期产品：目前比较常见的花呗分期和京东白条，这两家的分期产品早期都是放在收银台的一种支付方式，C", "端用户在选择支付宝或者京东支付之前并不能直观的了解到该商家是否支持分期，所以后期两家也推出了分期前置的模式，即支持分期支付方式直接在商家收银台进行展示（对于", "C", "端用户来讲，更加直观，体验更好，能够有效降低消费者心里门槛），与支付宝、微信、QQ", "钱包支付可做平级展示。简单介绍了商家收款，我们也来看看商家付款的产品功能：代付：", "代付，我们通常称「代付」主要指的是商家充值到在支付机构开通的备付金账户，然后直接调用代付接口下发给", "C", "端用户或者", "B", "端商家银行账户。转代付（这个叫法可能不同公司有所不同，转代付比较容易理解）：", "转代付，这里指的是先通过支付渠道的支付产品收款至企业账户，然后直接通过出款接口进行下发。现在的微信新资金流的企业付款就是转代付的模式。分账（严格意义来讲不能称之为商家出款行为）：", "指的是商家在发起收款订单时即指定了相关的分账信息，用户支付成功时，直接将资金分账到对应的", "B", "端商家企业账户。下面一张图看看", "转代付", "和", "分账", "的区别：B", "商家发起收款", "100", "元，后续可以给", "C", "端商家或者", "B", "端商家进行打款。这里需要注明的是，给商家或者用户打款的", "X", "和", "Y", "元，跟", "100元没有必然联系，只要确保出款账户内资金足够用于", "B", "商家打款即可。这里需要提及下，微信的企业付款只能针对", "C", "端用户，不能给", "B", "端商家打款。支付宝的单笔转账可以给", "C", "端用户和", "B", "端商家的支付宝账户转账。因为微信现在区分新旧资金流，所以现在企业付款到零钱资金根据商户号的账户开通情况，实际出款账户有做区别：默认情况下，企业付款到零钱使用商户号基本户（或余额账户）余额。如商户号已开通运营账户，则企业付款到零钱使用运营账户内的资金。基本户（或上述其他出款账户）的资金来源，可能是交易结算款项（仅基本户），或给账户充值的资金。当出款账户余额不足时，付款将因余额不足而付款失败。B", "商家发起", "100", "元收款，含分账指令给", "C", "商户", "20", "元，那么最终用户完成这笔订单支付的时候，则商家", "B", "收款", "80", "元，商家", "C", "收款", "20", "元。分账模式比较适用于平台类型的商家或者集团类型的商家，目前所接触到的微信分账并没有对外开放申请，最多关联的分账账户有", "5", "个的限制。支付宝的分账目前看到的是在跨境上有用到，最多支持在", "10", "个以内。两个分账功能均需要单独联系", "BD", "进行申请。2.", "行业准入和区别（1）商家收款类别1）这里简单列了下大的分类，主要有实物类、虚拟类和政府/事业单位（主要指的公立医院和学校）走微信和支付宝的渠道申请所对应的费率和结算周期的区别。特殊行业对应所需要的资质也有所区别。实物类：", "医疗类的会有资质文件才可以申请，比如医疗器械、身体康复用品的需要持有《医疗器械经营企业许可证》、经营内容包含美瞳或者隐形眼镜，则需要提供《第三类医疗器械销售资质》等等；虚拟类：", "比如游戏道具购买，需要具备《网络文化经营许可证》。2）商家的行业可以直接参照腾讯或者支付宝的的商家类目、费率、资质的文档，简单粗暴，可以到官网上了解一下。3）这里提及一下，前面的花呗分期和京东白条产品：使用的前提都是至少拥有支付宝或者京东对应的基础支付功能，才能进一步申请分期的产品权限，目前两家的分期产品的权限都是需要单独联系", "BD", "，走线下申请的流程，周期较长。（2）商家付款类别Tips：微信新资金流开通企业付款功能要求商户号开通", "90", "天且持续", "30", "天以上有交易流水，才可以申请开通「企业付款」权限，且目前服务商模式不支持企业付款。目前银行卡代付的申请，看各家机构的要求，目前尚且没有比较固定的行业分类。基本上", "case", "by", "case", "的去看。所以我们主要看看在使用商家付款产品的时候，需要关注哪些内容。①", "费用看代付的费用从两种情况来看，一个是付款到银行卡，一个是付款到钱包账户。前者的费用一般是按照单笔手续费计算，比如", "1-2", "元/笔。后者代付到钱包一般是免费，这个手续费商家不承担，主要在用户发起提现的时候会需要支付提现手续费。②", "限额各家支付机构不一样，但是主要需要与支付机构沟通的是单笔、单日、单月、以及每天的调用频次等是否有限制，限制是多少。避免业务部门已经申请完成了渠道，后面产品对接发现根本不能满足业务应用场景，那就后使用起来就", "GG", "了。③", "到账时间选择商家付款渠道的时候也需要关注付款到账时间，因为有些应用场景对于实时性要求比较高。④", "支持的银行支持银行列表也需要多加关注，尤其是", "B2B", "转账或者对于有特殊银行需求的商家。前面在商家付款中提到的代付和转代付，对于微信的", "企业付款", "产品区分新旧资金流。微信现在区分新旧资金流企业付款到零钱资金根据商户号的账户开通情况，实际出款账户有做区别：默认情况下，企业付款到零钱使用商户号基本户（", "或余额账户", "）余额。如商户号已开通运营账户，则企业付款到零钱使用运营账户内的资金。基本户（或上述其他出款账户）的资金来源，可能是交易结算款项（仅基本户），或给账户充值的资金。当出款账户余额不足时，付款将因余额不足而付款失败。3.", "渠道合作模式和优惠政策早期商家跟渠道的合作比较单一，但是近", "2", "年渠道也推出来比较多的合作模式来吸引商家以及合作伙伴。简单介绍下各种合作模式：直连直连（", "入驻", "）普通服务商银行服务商目前服务商模式做的比较好的是微信和支付宝，微信的营销活动做的比较好，之前的智慧餐厅推广叠加活动、随机立减活动，以及最近的朋友圈广告功能投放功能等等活动，无论是从商家成本还是用户体验上，都极大的调动符合条件客户参与活动的积极性。各种合作模式的优缺点4.", "退款处理规则接下来我们讲讲退款，原先「退款」这一块的逻辑是放在后面渠道开发对接部分的。但是因为近期日常渠道运营中遇见了一个关于手续费的问题，退款是否退回手续费的问题一定程度上决定了某些特定场景的商户对于支付渠道的选择，因此把它提到业务规则中来聊一聊。为什么在业务对接的时候就需要关注上图这三点呢？某些特定行业对于退款的周期有特殊要求", "，比如共享单车的押金、家具公司的较长退货期等等，这一类允许较长周期退款的行业都需要关注各个渠道的退款周期。如果退款周期不满足需求，最好在入网阶段就能提出延长订单可退款周期的需求，按照渠道要求提交业务说明并变更退款周期。避免到了后期渠道不好调整而导致用户与商家的纠纷投诉。关于退款是否退回手续费的规则需要提前与渠道确认好", "，正常情况下当用户产生退款，商家是会被渠道退回支付时收取的交易手续费的。但少部分支付渠道存在以下几种情况：退款不退回手续费、部分退款不退回手续费、退款只退部分手续费（退动态手续费，不退固定手续费部分）因此需要提前捋顺几个问题：退款功能是否需要提前额外申请退款周期是否需要延长退款资金是否需要额外充值：待结算账户、余额充值账户退款或者撤销是否退回原订单的支付手续费以下是一张关于各渠道的退款周期，是否退回手续费以及退回手续费的逻辑说明：5.", "支付渠道对接及管理（1）资金结算方式手动提现还是自动结算，自动结算是否有资金门槛（因为在跨境微信支付宝的渠道资金结算，直连会有", "5000", "usd", "结算资金门槛）（2）获取对账单方式业务需要提前确认获取对账单方式，是只能通过商户平台下载还是也能通过接口下载。如果通过接口下载是否需要提前走申请流程，因为我们有遇见过一些支付渠道下载对账单也需要提前走线下公司盖章的申请流程，周期略长。前期若没有确认好，会都后期项目开发周期造成影响。（3）清分时间这个跟获取对账单方式时候可以一并确认，一般渠道的清分时间都是", "00-24", "点之间的交易。（4）区分不同交易对账单微信新资金流，因为没有待结算和余额充值账户的概念，退款都是从基本户中出去的，所以退款的订单都会在", "ALL", "类型的对账单中；微信旧资金流，区分待结算账户和充值余额账户，即使针对", "ALL", "类型的对账单，也不包含余额充值的退款对账单。二.", "支付渠道对接及管理这部分内容着重介绍在开发对接渠道过程中需要关注哪些问题，主要面向商家的产品部门。第一部分主要讲了商家的业务部门在前期申请渠道时候，场景适配以及需要提前跟渠道沟通了解的注意事项。第二部分就涉及到产品技术对接阶段的一些细节处理。1.", "渠道对接步骤和内容公司内各个部门不同的产品，线上线下产品适用场景不同，费率会有所区分，注意事项在第一部分已经阐述。切记不要申请错了权限，这个对于微信是比较常见的问题（", "服务号、订阅号、APP", "）配置并获取参数，这一个步骤建议是产品与业务部门能一起操作、确认。另外如果有线下版本的协议，建议产品也可以看下，因为我们曾经遇见过一些渠道有业务处理时间的限制，但是没有写在线下开发文档中，是单独列在了协议中。在获取参数时，部分渠道是一定要通过测试案例提交才能获取正式参数，此处也需要留足项目时间。对接支付相关的", "API", "，按照自己内部支付模块以及支付渠道的对接开发文档对接开发即可。上线结果通知：这一步列在这里的原因是因为对外的技术服务商在日常工作中需要留足足够的时间给协同模块。关联模块功能更新：可以完成一笔成功的交易并不代表整个交易功能已经完善。比如对于交易明细的展示和管理、报表展示。后期商家内部渠道参数的更新、维护等配套模块也需要做更新。①", "是否需要添加出口IP部分渠道需要添加", "IP", "白名单才可以进行开发、测试调试，有些渠道较快的能添加完成，但是有些银行类的可能要走比较漫长的线下申请。②", "对接的接口版本不同支付渠道的接口版本对应的支付渠道的参数也不一样，所以在商务确定产品合作后需要确认对应的业务申请参数和渠道开发的接口版本是否一致。③", "订单号长度和组合支付机构遇到此类问题比较多。每个渠道的订单规则其实略有不同，例如招行早期的订单号只允许数字形式，不允许其他任何符号；微信、支付宝和银联对订单号的长度要求不同，因此建议订单号长度为", "8~20", "位，目前来看基本可以适配要求。④", "交易金额单位一般情况下单位都是以「分」为单位，但也遇到过以「元」为单位的情况。⑤", "商品描述特殊字符，是否展示在用户可见的渠道支付页部分渠道会因为在商品描述中加入了特殊字符而导致交易失败，然后因为报错提示信息不明显，会导致开发定位较长时间，另外需要确认该信息是否会展示在用户所见的渠道支付页上，避免字段设置的信息给用户产生疑惑。⑥", "收款公司名称展示常规情况下，大部分支付渠道是可以在后台进行设置或者在入网时有很清晰的提示，但是有些渠道是通过某个字段来进行填写并上传的，比如建行龙支付。⑦", "订单过期时间的模式确认绝对时间（", "某个固定的时间", "）相对时间（", "例如用户在支付页面密码输错了扣款失败，才开始计时", "）二维码有效期过期时间单位⑧分期支付是否支持前置展示主要是用户体验的问题，假设不做前置展示可能会在最后一步支付时流失掉这个订单。⑨", "是否支持禁用信用卡有些商家不希望用户支付使用信用卡，部分渠道可以通过请求参数字段进行设置，也有渠道通过入网签订协议后台配置。⑩", "前端带回的参数信息大部分商家比较在意前端带回的结果参数信息，例如订单号、支付结果等等①", "可退款订单周期、权限开通之前在对接线下扫码支付，走服务商模式，退款权限并不默认开通，需要走线下申请的流程后才可以开通。可退款订单周期如之前提及，需要提前申请确认。②", "单笔订单退款次数、频率限制例如微信是有单笔订单对多", "50", "次退款限制的，虽然实际场景中遇见单笔退款几十次概率很小，但一旦出现这类情况就需要做好线下给用户退款的准备。③", "是否支持原单重试这种场景微信比较多，微信现在文档上备注的已经十分详细了，尤其对于商家转账红包这种类型的出款，一定需要提前确认是否支持原单重试，避免重复出款。④", "是否支持部分退款&", "是否退还手续费以及计算逻辑对接的渠道大部分都支持部分退款，但是有些个别的渠道是支持退款不退手续费。因此商家遇到用户退款的情况，就会在退款时损失手续费。同时对计算逻辑也要进一步确认，有些渠道的手续费分两部分，一部分是固定手续费，一部分是动态手续费。在退款时也会有全退、只退动态手续费不退固定手续费以及手续费全部不退的情况。⑤", "多选一单号请求，需要确认优先级这个在退款时微信、QQ", "钱包都有过类似的问题，例如早期", "QQ", "钱包超过", "30", "天的订单如果不使用交易单号就会报错。因此如果渠道的文档表示两个字段二选一都行，就要提前确认好优先级。⑥", "退款描述特殊支付，是否展现在用户可见的地方这部分和前面是一样的，就不细说了。⑦", "是否支持退款的异步通知最早期的时候微信退款无异步通知，我们自己做了个自动查询模块，定时（5s、10s、20s、1min", "等等递增）去调用退款查询接口来获取退款状态，现在微信也支持了退款成功的异步通知，主要的支付渠道也都支持了该功能。⑧", "是否区分退款资金来源这块主要是需要清楚地明白和业务的关联点在哪里，一般在退款接口上会有区分字段提示。⑨", "同步返回的状态，是否可以作为最终结果该种情况除了接口文档上的描述外，建议与渠道再做二次确认。通常是根据异步通知或者查询的退款结果进行更新，但是存在部分渠道建议直接根据创建退款同步返回结果直接判断的情况，比如支付宝国际的退款，并不提供退款查询接口。①", "支付和退款的查询是否区分接口有的渠道不作区分，但有的渠道例如单号是区分支付成功单号以及退款单号两种不同的字段。②", "确认查询接口展示的状态参数比如退款、用户被扫等模式可能存在多个状态，需要考虑多状态之间的关系和更新逻辑。③", "多选一单号查询，需要确认优先级与前文相同，不做赘述。④", "区分通信结果、业务结果、交易结果查询一个交易结果之前需要判断通信结果以及业务结果，最终展示的交易状态要根据交交易结果来判断。⑤", "结算金额、优惠金额、退款渠道等信息是否返回常规情况下渠道会通过支付成功之后的异步通知或者查询返回对应的信息，但是也存在部分渠道是通过后台配置的优惠信息，仅在支付成功页面、对账单中才有体现，并不会体现在交易返回参数中。⑥", "查询和异步通知返回的交易相关信息一致例如支付宝国际支付，查询与异步通知返回的信息不一致，是由于币种的转换造成的。存在部分返回信息需要提前邮件申请进行配置，虽然对外并没有文档指引和说明。⑦", "查询频率是否限制，是否有建议的查询间隔机制不同的渠道略有不同，有的渠道对频率有限制、间隔有限制。因此在前期需要确认。①", "各种交易是否有异步通知产品与技术对接过程当中，需要稍微注意一下，因为渠道的文档都放一起，按照惯例是都有的，但是背不住要踩坑，比如线下支付的用户被扫模式。②", "异步通知地址是请求上送还是后台固定配置不同渠道不一样，大部分是通过接口请求上送；小部分渠道通过后台固定地址配置。③", "何种状态会触发异步通知需要校验异步通知的状态类型，比如支付成功、订单支付中、订单关闭等等，避免未区分异步通知类型导致错误更新订单状态。④", "交易成功时间字段有些渠道交易成功时间这个字段不正确，可能会导致对账会出现一些问题，需要人工去处理。⑤", "是否带回交易请求上送的附加信息在渠道提供的交易请求信息并不足以区分商家内部的业务订单时，商家往往还会上送额外的字段信息，有些渠道有去无回，即异步通知不带回该额外信息，导致商家业务更新异常。⑥", "重试机制以及恢复信息重试机制需要提前确认，如果渠道间隔时间比较长，就需要提前在订单过期前之前加一些查询机制，避免用户体验糟糕。⑦", "签名验证或IP", "白名单异步通知的验证真伪性一般可以通过签名或者", "IP", "白名单，如果是", "IP", "白名单的话提现与渠道确认好出口", "IP", "。2.", "常见对接问题和解决方案一般情况下上图中的情况会导致交易异常，因此建议商家除了对接渠道异步通知也要对接查询接口，可以设置查询任务；同时不建议商家以业务查询结果为参考，查询服务端的订单状态，一旦不一致就调用接口去查询一下，更保险。还有不要查询频率太高，可能造成渠道结果返回不了。例如支付宝和微信使用线下渠道会有风控（", "一般线上套线下才会有", "），因此匹配自身场景去申请渠道是最安全的。渠道系统异常的情况，最好是多对接几个渠道，万一挂掉了一个另一个也不影响使用。渠道更新接口/", "规则没有及时同步的情况，这就需要经常爬一下各渠道的公告平台了。渠道数据状态不同步的情况只能去咨询渠道，根据渠道的建议去修改查询模块。本文由", "@支付学院", "原创发布于人人都是产品经理。未经许可，禁止转载题图来自", "Pexels，基于", "CC0", "协议"]}
{"author": "Rolan", "title": "微信小程序实现类3D轮播图 ", "content": ["效果图如下：1.swiper的相关属性indicator-dots", "是否显示小圆点，也可以自己重新设置小圆点circular", "是否衔接滑动，就是实现无限滚动previous-margin", "与上一张图片的间距next-margin", "与下一张图片的间距autoplay", "实现自动滚动这里主要利用了circular实现无限滚动，然后再加上前后间距，再设置图片的层级和透明度就可以实现了,将图片及容器的高度设置好就差不多可以实现了wxml文件<!--carousel/index.wxml-->", "<swiper", "class=\"imageContainer\"", "bindchange=\"handleChange\"", "previous-margin=\"50rpx\"", "next-margin=\"50rpx\"", "circular", "autoplay>", "<block", "wx:for=\"{{3}}\"", "wx:key=\"{{index}}\">", "<swiper-item", "class=\"item\">", "<image", "class=\"itemImg", "{{currentIndex", "==", "index", "?", "'active':", "''}}\"", "src=\"../../../image/3.jpg\"></image>", "</swiper-item>", "</block>", "</swiper>wxss文件/*", "carousel/index.wxss", "*/", "page{", "background:", "#f7f7f7f7;", "}", ".imageContainer{", "width:", "100%;", "height:", "500rpx;", "background:", "#000;", "}", ".item{", "height:", "500rpx;", "}", ".itemImg{", "position:", "absolute;", "width:", "100%;", "height:", "380rpx;", "border-radius:", "15rpx;", "z-index:", "5;", "opacity:", "0.7;", "top:", "13%;", "}", ".active{", "opacity:", "1;", "z-index:", "10;", "height:", "430rpx;", "top:", "7%;", "transition:all", ".2s", "ease-in", "0s;", "}JS文件//", "carousel/index.js", "Page({", "data:", "{", "currentIndex:", "0", "},", "onLoad:", "function", "(options)", "{", "},", "/*", "这里实现控制中间凸显图片的样式", "*/", "handleChange:", "function(e)", "{", "this.setData({", "currentIndex:", "e.detail.current", "})", "},", "})正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：画三角形webpack打包（有面试题）setInterval与setTimeout"]}
{"author": "Rolan", "title": "富文本解析-微信小程序 rich-text 组件 ", "content": ["微信小程序富文本解析器微信小程序在rich-text组件后开始支持富文本解析，但需要对照一套自定义规则的", "JOSN", "数据格式，API", "返回的富文本需要前端做数据转换。这个主要是用于某些需要", "API", "直接输出富文本的地方。比如后端输出title字段,", "但", "title", "字段中有加重提示的几个文字是需要标红的。这种情况下后端如果不返回富文本，前端去在小程序去处理是比较麻烦的，还得定个规则，前端再写好样式拼接起来。如果后端直接给你返回富文本，用这个去解析可以直接搞定。如官网给的例子：=如何才能将", "HTML", "转为微信小程序组件支持的数据格式呢？html2json", "是一个将", "HTML", "解析为对应的", "json", "格式但", "html2json", "库转换出来的", "JSON", "与微信小程序要求不一致，且不支持解析", "style，故在此库的基础上做的了扩展与调整。使用方法：import", "html2json", "from", "'wxapp-rich-text';", "//", "或者下载该仓库", "import", "html2json", "from", "'./your/path/index.js';", "const", "html", "=", "'<div", "id=\"this-id\"", "class=\"this-class\">sample<br/>text<h2", "style=\"color:", "red;font-size:48rpx;\">sample", "text</h2></div>';", "const", "json", "=", "html2json(html);", "this.setData({", "nodes:", "json,", "});", "源码见Github:", "https://github.com/treadpit/w...目前只测试了一些简单的例子，如下图："]}
{"author": "Rolan", "title": "微信小程序可实时改变转速的css3旋转动画 ", "content": ["先上效果图", "最上面那一行就是个简单的换颜色效果，极其简答就不多说了，直接上代码。<view", "class='box'", "style='background-color:{{backgroundcolor}}'></view><view", "class='viewBox'>", "<button", "bindtap='changeColor'", "data-color='black'", "class='box'>黑</button>", "<button", "bindtap='changeColor'", "data-color='violet'", "class='box'>紫</button>", "<button", "bindtap='changeColor'", "data-color='orange'", "class='box'>橙</button>", "<button", "bindtap='changeColor'", "data-color='blue'", "class='box'>蓝</button>", "<button", "bindtap='changeColor'", "data-color='green'", "class='box'>绿</button></view>JS", "data:", "{", "backgroundcolor:'red'", "},", "changeColor:function(e){", "this.setData({", "backgroundcolor:", "e.currentTarget.dataset.color", "})", "}那么下面咱们说一说这个旋转的动画。小程序里呢，有自己的动画api，但是用起来感觉极其麻烦，而且容易产生倒转，对设备的性能消耗也多，动画多了以后就会极其卡顿，所以还是css3的动画比较好。", "首先来写这个css3动画", "css3旋转动画<view", "class='animationSlow'></view>.animationSlow", "{", "width:", "100rpx;", "height:", "100rpx;", "background-color:", "orange;", "animation-name:", "myfirst;", "/*动画的名称", "*/", "animation-duration:", "2000ms;", "/*动画从开始到结束的时间*/", "animation-timing-function:", "linear;", "/*动画执行快慢的参数*/", "animation-iteration-count:", "infinite;", "/*动画执行多少次的参数*//*以下是兼容ios所需，参数意义与上相同*/", "-webkit-animation-name:", "myfirst;", "-webkit-animation-duration:", "2000ms;", "-webkit-animation-timing-function:", "linear;", "-webkit-animation-iteration-count:", "infinite;}@keyframes", "myfirst", "{", "/*开始转的角度*/", "from", "{", "transform:", "rotate(0deg);", "}/*结束的角度*/", "to", "{", "transform:", "rotate(360deg);", "}}/*兼容ios*/@-webkit-keyframes", "myfirst", "{", "from", "{", "transform:", "rotate(0deg);", "}", "to", "{", "transform:", "rotate(360deg);", "}}效果图", "如果只是一个一次性的动画效果，现在这些代码就OK了。", "如果想要实时可以改变旋转的转速，我们还得再加点东西。实现可以实时修改转速", "微信小程序里涉及到实时数据就避免不了Page.data这个东西。", "1.我们需要将控制动画时间的css属性放到内联样式中去<view", "class='animationSlow'", "style='animation-duration:", "2000ms;-webkit-animation-duration:", "2000ms;'></view>2.在页面对应的js中，设置掌控时间的Page.data属性，将wxml里内联属性的时间改为Page.data的属性。", "data:", "{", "animationTime:'2000ms'", "},<view", "class='animationSlow'", "style='animation-duration:", "{{animationTime}};-webkit-animation-duration:", "{{animationTime}};'></view>3.接下来我们写几个按钮，绑定上修改这个时间的方法，进而来改变转速。这一步都是基本代码，我就不贴代码了。放个效果图吧。效果图那么接下来重点来了：其实这里有个bug，这个效果呢在安卓机上是一点点问题都没有的。但是在苹果机上，动画一旦开始，再通过这个方法去修改转速，就不能生效了。解决IOS系统的BUG", "上面说了，IOS系统上呢，动画一旦开始，这个方法就不能用了。那么咱是不是可以先把这个动画停下来，然后再改转速呢？这个办法可不可以呢？答案是肯定的，但是不是去把动画时间改为0，而是采用了css3动画的一个属性。CSS3", "动画教程animation-play-state:", "paused|running;简而言之就是先用这个属性把动画暂停，修改转速，然后再让它跑起来。这一切都得再js里进行。", "1.需要在标签的内联样式里加上这个属性，在Page.data里再定义一个属性控制开始暂停。<view", "class='animationSlow'", "style='animation-duration:", "{{animationTime}};-webkit-animation-duration:", "{{animationTime}};animation-play-state:{{status}};-webkit-animation-play-state:{{status}};'></view>", "data:", "{", "animationTime:'2000ms',", "status:", "'running'//paused", "},2.然后我们去修改改变转速的方法。暂停>(修改>跑起来)，效果上稍微有些延迟。", "changeTime:function(e){", "this.setData({", "status:", "'paused'", "})", "this.setData({", "timeAnimation:", "e.currentTarget.dataset.time,", "status:", "'running'", "})", "},3.来上效果图了。效果图可能动图上感觉不出来，不过你们可以去真机试一下，就可以展现出来了。本次分享结束(@LcFireRabbit)作者：LcFireRabbit", "链接：https://www.jianshu.com/p/4c1928534c4f"]}
{"author": "Rolan", "title": "微信小程序抽奖-翻牌 ", "content": ["背景ps：本次开发基于wepy框架", "由于最近接到一个需求--抽奖活动；", "翻牌打乱活动抽奖活动，大概需求是这样的，九宫格卡牌，先正面展示所有奖品，然后卡牌翻转，打乱排序，点击卡牌，然后抽奖。这个需求本身其实不难，主要是分为三步；展示所有卡牌，然后翻转。打乱所有卡牌点击其中一张卡牌，抽奖第一步：卡牌翻转我们先在dom中渲染9个卡牌。<view", "class=\"card-module\">", "<view", "class=\"card", "{{showClass", "?", "'change'", ":", "''}}>", "<view", "class=\"front", "card-item\">{{cardItem.front}}</view>", "<view", "class=\"back", "card-item\">{{cardItem.back}}</view>", "</view>", "</repeat></view>在数据中生成模拟卡牌数据cardData:", "[", "{", "animationData:", "{},", "front:", "'正面1',", "back:", "'反面1'", "},", "...", "...", "{", "animationData:", "{},", "front:", "'正面9',", "back:", "'反面9'", "}", "],", "showClass:", "false,在样式中把卡牌的基本样式渲染出来.card-module{", "padding:", "45rpx;", "display:", "flex;", "flex-direction:", "row;", "flex-wrap:", "wrap;", "transform:translate3d(0,0,0);", ".card{", "width:", "200rpx;", "height:", "200rpx;", "line-height:", "200rpx;", "text-align:", "center;", "color:", "#fff;", "margin:", "10rpx;", "position:relative;", "overflow:hidden;", ".card-item{", "position:absolute;", "left:0;", "top:0;", "width:100%;", "height:100%;", "transition:all", ".5s", "ease-in-out;", "transform-style:preserve-3d;", "backface-visibility:hidden;", "box-sizing:border-box;", "}", ".front{", "background-color:", "red;", "transform:", "rotateY(0deg);", "z-index:2;", "}", ".back{", "background-color:", "#009fff;", "transform:", "rotateY(180deg);", "z-index:1;", "}", "}", ".card.change{", ".front{", "z-index:1;", "transform:", "rotateY(180deg);", "}", ".back{", "z-index:2;", "transform:", "rotateY(0deg);", "}", "}}效果如下这里有些css属性可能需要大部补充学习一下css3", "backface-visibility", "属性定义和用法", "backface-visibility", "属性定义当元素不面向屏幕时是否可见。", "如果在旋转元素不希望看到其背面时，该属性很有用。CSS3", "perspective", "属性perspective", "属性定义", "3D", "元素距视图的距离，以像素计。该属性允许您改变", "3D", "元素查看", "3D", "元素的视图。", "当为元素定义", "perspective", "属性时，其子元素会获得透视效果，而不是元素本身。第二步：卡牌打乱由于业务上是抽奖使用的，所以选择的方案是：翻转后，卡牌收回到中间的卡牌中间，然后再让卡牌回到原来的位置。", "关于小程序的原生框架有支持的动画接口，若不了解的请前往：", "developers.weixin.qq.com/miniprogram…", "在对动画有基本了解之后，我们可以开始在翻转的基础上加上打乱的动画了", "微信小程序的动画接口使用方式是在dom对象上面加上animation对象。", "dom<view", "class=\"card-module\">", "<view", "class=\"card", "{{showClass", "?", "'change'", ":", "''}}", "animation=\"{{cardItem.animationData}}\"", ">", "<view", "class=\"front", "card-item\">{{cardItem.front}}</view>", "<view", "class=\"back", "card-item\">{{cardItem.back}}</view>", "</view>", "</repeat></view>scriptallMove", "()", "{", "//", "110", "是卡牌宽度加边距", "this.methods.shuffle.call(this,", "110)", "let", "timer", "=", "setTimeout(()", "=>", "{", "clearTimeout(timer)", "this.methods.shuffle.call(this,", "0)", "this.$apply()", "},", "1000)},//", "洗牌shuffle", "(translateUnit)", "{", "let", "curCardData", "=", "this.cardData", "curCardData.map((item,", "index)", "=>", "{", "let", "animation", "=", "wepy.createAnimation({", "duration:", "500,", "timingFunction:", "'ease'", "})", "animation.export()", "switch", "(index)", "{", "case", "0:", "animation.translate(translateUnit,", "translateUnit).step()", "break", "case", "1:", "animation.translate(0,", "translateUnit).step()", "break", "case", "2:", "animation.translate(-translateUnit,", "translateUnit).step()", "break", "case", "3:", "animation.translate(translateUnit,", "0).step()", "break", "case", "4:", "animation.translate(0,", "0).step()", "break", "case", "5:", "animation.translate(-translateUnit,", "0).step()", "break", "case", "6:", "animation.translate(translateUnit,", "-translateUnit).step()", "break", "case", "7:", "animation.translate(0,", "-translateUnit).step()", "break", "case", "8:", "animation.translate(-translateUnit,", "-translateUnit).step()", "break", "}", "item.animationData", "=", "animation.export()", "})", "this.cardData", "=", "curCardData", "this.$apply()},算法后面需要优化，我们先完成功能效果，", "效果如下第三步：卡牌翻转dom代码<view", "class=\"card-module\">", "<view", "class=\"card", "{{showClass", "?", "'change'", ":", "''}}", "{{curIndex", "===", "index", "?", "'getprize'", ":", "''}}\"", "@tap=\"itemChage({{cardItem}},", "{{index}})\"", "animation=\"{{cardItem.animationData}}\"", ">", "<view", "class=\"front", "card-item\">{{cardItem.front}}</view>", "<view", "class=\"back", "card-item\">{{cardItem.back}}</view>", "</view>", "</repeat></view>script代码data中定义一个curIndex", "=", "-1的对象data", "=", "{", "curOpen:", "-1,", "}methods", "=", "{", "//", "抽奖", "itemChage", "(item,", "curIndex)", "{", "this.cardData[curIndex].front", "=", "'iphone", "x'", "console.log(item,", "curIndex)", "this.curOpen", "=", "curIndex", "}}less.card.getprize{", ".front{", "z-index:2;", "transform:", "rotateY(0deg);", "}", ".back{", "z-index:1;", "transform:", "rotateY(180deg);", "}", "}效果如下现在我们就已经完成了基本的需求；但是在位移动画时候代码写的太丑陋了。", "我们来想想怎么优化算法；", "我们现在就九宫格布局，我们可以看成是二维布局那我们是不是可以在卡牌中也使用二维数组布局属性resetData", "()", "{", "const", "total", "=", "9", "//", "总数", "const", "lineTotal", "=", "3", "//", "单行数", "curCardData.map((item,", "index)", "=>", "{", "let", "curCardData", "=", "this.cardData", "let", "x", "=", "index", "%", "lineTotal", "let", "y", "=", "parseInt(index", "/", "lineTotal)", "item.twoArry", "=", "{x,", "y}", "})}在位移动画中使用二维布局的差值进行位移//", "洗牌shuffle", "(translateUnit)", "{", "let", "curCardData", "=", "this.cardData", "curCardData.map((item,", "index)", "=>", "{", "let", "animation", "=", "wepy.createAnimation({", "duration:", "500,", "timingFunction:", "'ease'", "})", "animation.export()", "const", "translateUnitX", "=", "translateUnit", "*", "(1", "-", "item.twoArry.x)", "const", "translateUnitY", "=", "translateUnit", "*", "(1", "-", "item.twoArry.y)", "animation.translate(translateUnitX,", "translateUnitY).step()", "item.animationData", "=", "animation.export()", "})", "this.cardData", "=", "curCardData", "this.$apply()},这样整个动画就算完成了，demo请前往githubgithub.com/fishmankkk/…作者：fishman", "链接：https://juejin.im/post/5b867460f265da435743a8de", "来源：掘金", "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]}
{"author": "Rolan", "title": "微信小程序之判断页面滚动方向 ", "content": ["需求微信小程序中如果判断页面滚动方向？解决方案1.用到微信小程序API获取页面实际高度", "nodesRef.boundingClientRect([callback])监听用户滑动页面事件onPageScroll。2.获取页面实际高度<!--WXML-->", "<view", "id=\"box\">", "<view", "class=\"list\"", "wx:for=\"{{List}}\"", "wx:key=\"List{{index}}\">", "<image", "mode='aspectFill'", "class='list_img'", "src=\"{{item.imgUrl}}\"", "></image>", "</view>", "</view>", "/*", "JS", "*/", "//", "封装函数获取ID为box的元素实际高度", "getScrollHeight:", "function()", "{", "wx.createSelectorQuery().select('#box').boundingClientRect((rect)", "=>", "{", "this.setData({", "scrollHeight:", "rect.height", "})", "console.log(this.data.scrollHeight)", "}).exec()", "},", "//", "假设数据请求", "getDataList:", "function()", "{", "wx.request({", "url:", "'test.php',", "//仅为示例，并非真实的接口地址", "success:", "function(res)", "{", "//", "如果该元素下面的数据是动态获取的，此方法在wx.request请求成功的回调函数中调用", "this.getScrollHeight()", "}", "})", "},", "3.监听用户滑动页面事件", "//监听用户滑动页面事件", "onPageScroll:", "function(e)", "{", "if", "(e.scrollTop", "<=", "0)", "{", "//", "滚动到最顶部", "e.scrollTop", "=", "0;", "}", "else", "if", "(e.scrollTop", ">", "this.data.scrollHeight)", "{", "//", "滚动到最底部", "e.scrollTop", "=", "this.data.scrollHeight;", "}", "if", "(e.scrollTop", ">", "this.data.scrollTop", "||", "e.scrollTop", ">=", "this.data.scrollHeight)", "{", "//向下滚动", "console.log('向下", "',", "this.data.scrollHeight)", "}", "else", "{", "//向上滚动", "console.log('向上滚动", "',", "this.data.scrollHeight)", "}", "//给scrollTop重新赋值", "this.setData({", "scrollTop:", "e.scrollTop", "})", "},参考：微信小程序如何判断页面上下滚动"]}
{"author": "Rolan", "title": "微信小程序UI规范 ", "content": ["微信小程序设计的基本原则是微信设计中心针对在微信类上线的小程序页面总结的设计指南及建议。以下设计原则都是基于对用户的尊重的基础上的，旨在微信生态类建立有号、高效、一致的用户体验的同时，最大程度顺应和支持各业务需求设计，实现用户与程序的共赢。一、有好礼貌为了避免用户在微信中使用小程序服务时，注意力被周围复杂环境干扰，小程序哎设计时应该注意减少无关的设计元素对用户目标干扰，礼貌地向用户展示程序侧提供的服务，友好地引导用户进行操作。1.", "重点突出每个页面都应有明确的重点，以便于用户每进入一个新页面的时候都能快速地理解页面内容，在确定了重点的前提下，应尽量避免页面上出现其他干扰项影响用户的决策和操作。反例示意此页面的主题是查询，却添加了诸多与查询不相关的业务入口，与用户的预期不符，易造成用户的迷失。纠正示意去掉任何与用户目标不相关的内容，明确页面主题，在技术和页面控件允许的前提下提供有助于用户目标的帮助内容，比如最近搜索词，常用搜索词等。反例示意操作没有注册，让用户无从选择纠正示意首先要避免并列过多操作让用户选择，在不得不并列多个操作时，需区分操作主次，减轻用户的选择难度。2.", "流程明确为了让用户顺畅地使用页面，在用户进行某一个操作流程时，应避免出现用户目标流程之外的内容而打断用户。反例示意用户本打算进行搜索，在进入页面时却被突如其来的抽奖弹窗所打断；对于抽奖没有兴趣的用户是非常不友好的干扰，平添一份对开发团队的恼怒；而即使有部分用户确实被“诱人”的抽奖活动所吸引，离开主流程去抽奖之后可能就遗忘了原本的目标，进而失去了对产品真正价值的利用和认识。二、清晰明确作为一个负责任的开发者，一旦用户进入我们的小程序页面，就有责任和义务清晰明确告知用户身在何处、又可以往何处去，确保用户在页面中游刃有余地穿梭而不迷路，这样才能为用户提供安全的愉悦的使用体验。1.", "导航明确，来去自如导航是确保用户在网页中浏览跳转时不迷路的最关键因素。导航需要告诉用户，我在哪，我可以去哪，如何回去等问题。首先在微信系统内的所有小程序的全部页面，均会自带微信提供的导航栏，统一统一解决我在哪，如何回去的问题。在微信层级导航保持体验一致，有益用户在微信内形成较为统一的体验和交互认知，无需在各小程序和微信切换中新增学习成本或使用习惯。微信导航栏微信导航栏，直接继承于客户端，除导航栏颜色之外，开发者无需亦不可以对其中的内容进行自定义。但开发者需要规定小程序各个页面的跳转关系，让导航系统能够以合理的方式工作。微信导航栏分为导航区域、标题区域以及操作区域。其中导航区控制程序页面进程。目前导航栏分深浅两种基本配色，在iOS和Android展示有所不同，如下图所示：导航区（iOS）导航区通常只有一个操作，即返回上一级界面。开发者可定义其内容，不可对样式进行修改。导航区（Android）通常情况下，系统导航左侧唯一的操作为“离开小程序，回到微信，程序后台运行”。当用户进入小程序次级页面后，我们建议小程序自身可以设计返回操作，同事用户也可以通过安卓系统自带的硬件返回按钮返回上一级。微信导航栏自定义颜色规则（iOS和Android）小程序导航栏支持基本的背景颜色自定义功能，选择的颜色需要在满足可用性前提下，和谐搭配微信提供的两套主导航栏图标。建议参考以下选色效果：选色方案示例：页面内导航开发者可根据自身功能合计需要在页面内添加自有导航。并保持不同页面间导航一致。但是受限于手机屏幕尺寸的限制，小程序页面的导航应尽量简单，若仅为一般线性浏览的页面建议仅使用微信导航栏即可。微信控件库提供tab导航供开发者选择。tab栏可固定在页面顶部或者底部，便于用户在不同的tab页面间作切换。为确保点击区域，tab项不得超过4项。一个页面也不应出现一组以上的tab栏。2.", "减少等待，反馈及时页面的过长时间的等待会引起用户的不良情绪，使用微信小程序项目提供的技术已能很大程度缩短等待时间。即便如此，当不可避免的出现了加载和等待的时候，需要予以及时的反馈以舒缓用户等待的不良情绪。启动页设计小程序启动也是小程序在微信内容一定程度上展现品牌特征的页面之一。本页面将突出展示小程序品牌特征和加载状态。启动页除LOGO品牌展示外，页面上的其他所有元素如加载进度指示，由微信统一提供且不能更改。无需开发者开发。下拉标示区微信类所有小程序页面，都会再下拉时出现微信为其统一设计的标示区。品牌展示区由品牌名称和微信小程序提示组成。目的是强化品牌和用户对小程序的产品感知。下拉标示（iOS深浅两色方案）微信提供深浅两套配色方案，如此处标示所示，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。下拉标示（Android深浅两色方案）微信下拉提示用于给用户明确的小程序归属者，防止造假与作弊。此处标示提供深浅两套方案，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。页面刷新交互（iOS）开发者可自定义需要通过下拉交互完成刷新的页面，此类交互微信将提供标准能力和样式。在样式上，刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标示与刷新图标的和谐统一。但用户在该类页面做出下拉交互时，出现微信小程序页面标准加载动画。开发者无需自行开发样式。在开发者没有在页面顶部设计tab的情况下，若定义该页面可通过下拉动作刷新，则刷新后加载状态提示语小程序品牌展示区出现在标题栏之下，页面顶部。开发者暂无法执行定义此加载效果。在开发者定义了页面顶部tab并定义该Tab下的内容页面可通过下拉动作刷新，则刷新后加载状态提示语小程序品牌展示区出现在顶部Tab之下，且仅刷新当前页面内容。开发者暂无法自行定义此加载效果。页面刷新交互（Android）与iOS相同，在样式上，Android下刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标识与刷新图标的和谐统一。微信下拉标示错误使用案例请避免以下错误使用情况，确保信息的可见性和页面的可用性。页面内导航微信控件库提供深浅tab导航方案供开发者选择。tab栏需固定在页面顶部，便于用户在不同的tab页面间作切换。为确保点击区域，tab项不得超过4项。一个页面也不应出现一组以上的tab栏。Tab栏选中态默认为100%实色，未选中态带有60%，其中选中态颜色可自定义。在自定义颜色选择中，务必保持Tab的可用性、可视性和可操作性。页面内加载反馈开发者可在小程序里自定义页面内容的加载样式。建议不管是使用在局部还是全体，自定义加载样式都应该尽可能简洁，并使用简单动画告知用户加载过程。开发者也可以使用微信提供的，统一的页面加载样式，如图中例所示。模态加载模态的加载样式将覆盖整个页面的，由于无法明确告知具体加载的位置或内哦让那个将可能引起用户的焦虑感，因此应谨慎使用。除了在某些全局性操作下不要使用模态的菊花。局部加载反馈即旨在触发加载的页面局部进行反馈，这样的反馈机制更加有针对性，页面改动小，是微信推荐的反馈方式。例如：加载反馈注意事项若加载时间较长，应提供取消操作，并使用进度条显示载入的进度。载入过程中，应保持动画效果；无动画效果的加载很容易让人产生该界面已经卡死的错觉。不要再同一个页面使用超过1个加载动画。结果反馈除了在用户等待的过程中需予以及时反馈外，对操作的结果也需要予以明确反馈。根据实际情况看，可选择不同的结果反馈样式。对于页面局部的操作，可在操作区域予以直接反馈，对于页面级操作结果，可使用toast、弹窗或结果页面展示。页面局部操作结果反馈对于页面局部的操作，可在操作区域予以直接反馈，例如点击多选控件前后如下图。对于常用控件，微信设计中心已提供控件库及WeUI控件库，其中的控件都已设计有完整的操作反馈。页面全局操作结果——toast其中toast适用于轻量级的成功提示，1.5秒后自动消失，并不打断流程，对用户影响较小，适用于不需要强调成功专题的操作提醒。特别注意toast形式不适用于任何错误提醒。页面全局操作结果——弹框对于需要用户明确知晓的操作结果状态可通过弹框来提示，并可附带下一步操作指引。页面全局操作结果——结果页对于操作结果已经是当前流程的终结的情况，可使用操作结果页来反馈。这种方式最为强烈和明确的告知用户操作已经完成，并可根据实际情况给出下一步操作的指引。3.", "异常可控，有路可退在设计任何的任务和流程时，异常状态和流程往往容易被忽略，而这些异常场景往往是用户最为沮丧和需要帮助的时候，因此需要格外注意异常状态的设计，在出现异常时予以用户必要的状态提示，并告知解决方案，使其有路可退。要杜绝异常状态下，用户莫名其妙又无处可去，卡在某一个页面的情况。2.2中所提到的弹窗和结果页面都可作为异常状态的提醒方式。除此之外，在表单页面中尤其是表单项较多的页面中，还应明确指出出错项目，以便用户修改。异常状态——表单出错表单报错，在表单顶部告知错误原因，并标识出错误字段提示用户修改。三、便捷优雅从PC时代的物理键盘鼠标到移动端时代手指，虽然输入设备极大精简，但是手指操作的准确性却大大不如键盘鼠标精确。为了适应这个变化，需要开发者在设计过程中充分利用手机特性，让用户便捷优雅的操控界面。1.", "减少输入由于手机键盘区域小且密集，输入困难的同时还易引起输入错误，因此在设计小程序页面时因尽量减少用户输入，理由现有接口或其他一些易于操作的选择控件来改善用户输入的体验。减少输入，巧用接口例如下图中，在添加银行卡时，采用摄像头识别SDK接口来帮助用户输入。除此之外微信团队还对外开放例如地理位置接口等多种SDK接口（详见微信JS-SDK），充分利用这些接口将大大提高用户输入的效率和准确性，进而优化体验。除了利用接口外，在不得不让用户进行手动输入时，应尽量让用户做选择而不是键盘输入。一方面，回忆易于记忆，让用户在有限的选项中做选择通常来说是容易于完全靠记忆输入；另一方面，仍然是考虑到手机键盘密集的单键输入极易造成输入错误。例如图中，在用户搜索时提供搜索历史快捷选项将帮助用户快速进行搜索，而减少或避免不必要的键盘输入。2.", "避免误操作一位内在手机上我们通过手指触摸屏幕来操控界面，手指的点击精确度远不如鼠标，因此在设计页面上需点击的控件时，需要充分考虑到其热区面积，避免由于可点击区域过小或过于密集而造成误操作。当简单的将原本在电脑屏幕上使用的界面不做任何适配直接移植到手机上时，往往就容易出现这样的问题。由于手机屏幕分辨率各不相同，因此最适宜点击像素尺寸也不完全一致，但换算成物理尺寸后大致是在7mm-9mm之间。在微信提供的标准控件库中，各种控件均已考虑到了页面点击效果以及不同屏幕的适配，因此再次推荐使用或模仿标准控件尺寸进行设计。3.", "利用接口提升性能微信设计中心已推出了一套网页标准控件库，包括sketch设计控件库和WeUI重构代码库，这些控件都已充分考虑了移动端页面的特点，能够保证其在移动端页面上的可用性和操作性能；同事微信web开发团队也在不断完善和扩充微信JS-SDK接口，并提供微信公共库，利用这些资源不但能够为用户提供更加快捷的服务，而且对页面性能的提高有极大作用，无形之中提升了用户体验。四、统一稳定除了以上所提到的种种原则，建议接入微信的小程序还应该时刻注意不同页面间的统一性和延续性，在不同的页面尽量使用一致的控件和交互方式。统一的页面体验和有延续性的界面元素都将帮助用最少的学习成本达成使用目标，减轻页面跳动所造成的不适感。正因如此，小程序可根据需要使用微信提供的标准控件，以达到统一稳定的目的。五、视觉规范为方便设计师进行设计，微信提供一套可供Web设计和小程序使用的基础控件库；同时方便开发者调用。1.", "字体规范常用字号为20，18，17，16，14，13，11（pt），使用场景具体如下：微信类字体的使用与所运行的系统字体保持一致，以导航为例，iOS与Android对应字体如下：导航（iOS和Android）字体颜色主内容Black黑色，次要内容Grey灰色；时间戳与表单缺省值Light灰色；大段的说明内容而且属于主要内容用Semi黑；蓝色为链接用色，绿色为完成字样颜色，红色为出错用色Press与Disable状态分别降低透明度为20%与10%；2.", "列表视觉规范3.", "表单输入视觉规范4.", "按钮使用原则列表外按钮上文字标准按钮高度为44px下使用：颜色#000000", "/", "#353535", "字号18pt可点状态下文字调整透明度为60%不可点状态下文字调整透明度为30%列表外按钮上文字标准按钮高度为25px下使用：颜色#000000", "/", "#353535", "字号14pt页面线性按钮上文字标准按钮高度为35px下使用：颜色#09BB07", "/", "#353535", "字号16pt5.", "图标使用原则"]}
{"author": "Rolan", "title": "微信小程序 canvas区间滑动选取 ", "content": ["目标js文件使用", "import", "引入;", "然后在onLoad(){}里面要一下写入例如:", "this.selectInterval", "=", "new", "selectInterval({属性});", "this.selectInterval", "=", "new", "SelectInterval({", "canvasId:'canvas',", "值必须是canvas组件的canvas-id属性的值", "canvasHeight:100,", "值必须是当前画布的高度", "Xaxis:{left:30,right:345},", "{", "left:30,", "横条的左端", "right:345,", "横条的右端", "}(right必须大于left,如果不传有默认值)", "scale:[10,20,30],", "刻度值Array类型,取值以一个不变数为常量不断递增,数组任何两个前后值相减要恒等于这个常量,如果数组第一个值不是0,", "会默认在数组前面添加一个0,但是0这个值不会在canvas上显示,(当数组长度是2的时候,", "可以设置任意大于零的数值,但第二个值必须大于第一个值);", "Yaxis:[125,5],", "刻度值Array类型,第一个值是绘制的横条的起始高度,第二个值是横条本身的高度(如果不传默认[125,5])", "manner:true,", "切换选择滑动点的上方在滑动的时候是否有跟随圆球，如果值为false那么明确显示区间滑动所得的最小值与最大值", "bothEndsNear:310,", "可以设置刻度值和尺度点距离横条的开头与终点的距离,不传默认居中", "//", "decimalPoint:10,", "刻度值/decimalPoint,可以使刻度值变小数,必须是10的倍数,可以不传", "//", "rightSliderStop:2,", "值为一个Boolean或者在manner的值为true的时候可填number,可以不传;而number的值就是最大值与最小值的差，设置后两个滑动点是不会滑动到小于这个number的距离", "showTitle:{", "name:'km',", "String类型,用作设置单位", "size:15,", "标签字体大小,Number类型", "title:'#1384e0',", "头部标签的字体颜色或者圆球里面的字体颜色,String类型", "positionX:100,", "标签字体在canvas横向的位置,Number类型，只有manner为false或者不传的时候生效", "positionY:80,", "标签字体或者圆球在canvas纵向的位置,Number类型", "isfollow:{", "跟随圆球大小与颜色的设置,manner的值为false或不传的时候,这个属性可以不给", "view:true,", "manner的值为true时，view的值必须为true", "roundSize:12,", "圆球大小", "roundColor:'rgba(10,", "113,", "238,", "0.8)'", "圆球的颜色", "}", "},(如果不传不会显示头部标签)", "scaleIn:{", "name:'km',", "String类型,用作设置单位", "size:10,", "控制刻度值字体的大小,Number类型", "valueY:108,", "刻度值在canvas纵坐标的位置,Number类型", "pointY:113", "尺度点在canvas纵坐标的位置,Number类型", "},(如果不传不会显示刻度值)", "colour:{", "colorBar:['#e5e5e5','#1384e0'],", "横条的颜色,Array类型,第一个是横条的底色,第二个是取值范围的颜色", "roundColor:['#ffffff','#e5e5e5'],", "圆圈颜色,Array类型,第一个是圆的颜色,第二个是圆的边框颜色", "scale:['#000000','#999999']", "刻度数值的字体颜色", "},(如果不传会显示上面的默认参数)", "selectedInterval:{", "min:15,", "max:23", "},(min不能大区等于max,如果不传只会显示在横条的两端)", "round:{", "radius:10,", "edgeLine:2", "},(如果不传会默认圆的半径为10,边框为2)", "//", "image:{", "//", "url:'../../assets/image/spot-a.png',", "图片的本地路径值为String类型；值可以为数组，但是如果是数组时数组的长度必须是2", "//", "width:20,", "设置图片的宽度", "//", "height:24", "设置图片的高度", "//", "},(如果不传不会显示图片)", "followValue:{", "name:'',", "String类型,用作设置单位", "color:'#f8835f',", "size:10,", "设置字体大小", "leftY:151,", "随数值在canvas纵向的位置", "rightY:151", "}(如果不传不会显示跟随数值)", "});/**Page({})里面创建如下属性", "必须自定义(e){", "bindtouchstart", "this.selectInterval.move(e.changedTouches[0].x,e.changedTouches[0].y);},自定义(e){", "bindtouchmove", "this.selectInterval.meter(e.changedTouches[0].x);},自定义(e){", "bindtouchend", "this.selectInterval.texthints((min,max)=>{", "参数min/max返回的值是最小/大价格,超过最大值max返回null", "console.log(min,max);", "},true);初始化时传入manner属性的值为true时候,这个函数的第二个参数的true就要传,不传也没什么问题，只是结果会有不同;},<canvas", "canvas-id=\"canvas\"", "bindtouchstart=\"自定义\"", "bindtouchmove=\"自定义\"", "bindtouchend=\"自定义\"></canvas>画布css样式width:100%;box-sizing:", "border-box;height:", "自定义rpx;"]}
{"author": "Rolan", "title": "【微信小程序】Text2Image ", "content": ["今天给大家分享如何制作一个Text2Image微信小程序。视频地址【内含源码下载链接】BiliBiliYoutube【微信小程序】text2imagehttp://v.youku.com/v_show/id_XMzgwNzEyNDM0NA==.html参考微信小程序", "绘图", "API接口使用canvas生成朋友圈分享图片并保存到手机相册主要功能添加文字选择背景选择字体大小生成图片保存图片到相册步骤创建项目导入weui", "for", "小程序样式库添加text2image页面添加布局添加逻辑完成", "&", "测试创建项目导入weui", "for", "小程序样式库下载weui", "for", "小程序样式文件https://github.com/Tencent/we...将weui.wxss添加到项目中引入全局样式//", "app.wxss", "@import", "'/src/wxss/weui.wxss';添加text2image页面//", "app.json", "pages:", "[", "'pages/text2image/text2image',", "...", "]添加以上代码，注意新页面放在pages数组第一个，确保小程序的首页为text2image，修改完之后并保存，添加新页面为下图时就成功了！添加布局<!--pages/text2image/text2image.wxml-->", "<view", "class=\"page\">", "<view", "class=\"page__bd\">", "<view", "class=\"weui-cells__title\">内容</view>", "<view", "class=\"weui-cells", "weui-cells_after-title\">", "<view", "class=\"weui-cell\">", "<view", "class=\"weui-cell__bd\">", "<textarea", "class=\"weui-textarea\"", "bindinput='typeNewContent'", "value=\"{{content}}\"", "placeholder=\"请输入文本\"/>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells__title\">生成图片</view>", "<view", "class=\"weui-cells", "weui-cells_after-title\">", "<canvas", "style=\"width:{{windowWidth}}px;height:{{contentHeight}}px\"", "canvas-id=\"myCanvas\"></canvas>", "</view>", "<view", "class=\"weui-cells__title\">设置</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "weui-btn-area\">", "<button", "type=\"primary\"", "bindtap=\"chooseBackgroundImage\">选择背景图片</button>", "<view", "class=\"section\">", "<view", "class=\"section__title\">选择文字颜色</view>", "<picker", "bindchange=\"bindPickerChange\"", "value=\"{{fontColorIndex}}\"", "range=\"{{fontColors}}\">", "<view", "class=\"picker\">", "当前选择：{{fontColors[fontColorIndex]}}", "</view>", "</picker>", "</view>", "</view>", "<view", "class=\"weui-btn-area\">", "<button", "type=\"primary\"", "bindtap=\"savePic\"", "wx:if=\"{{hasGenerate}}\">保存图片</button>", "</view>", "</view>", "</view>//", "pages/text2image/text2image.wxss", "page", "{", "background-color:", "#F8F8F8;", "}添加逻辑设置data//", "pages/text2image/text2image.js", "data:", "{", "windowWidth:", "0,", "//", "窗口宽度", "contentHeight:", "0,", "//", "内容高度", "content:", "'',", "//", "内容", "lineHeight:", "30,", "//", "行高", "fontColorIndex:", "0,", "//", "当前字体颜色", "fontColors:", "[", "'black',", "'red',", "'white',", "'green'", "],", "//", "字体颜色列表", "backgroundImage:", "'../../src/images/leaves.png',", "//", "背景图片", "hasGenerate:", "false,", "//", "是否已经生成图片", "},导入背景图片获取窗口宽度//", "pages/text2image/text2image.js", "onLoad:", "function", "(options)", "{", "let", "that", "=", "this;", "wx.getSystemInfo({", "success:", "function", "(res)", "{", "that.setData({", "windowWidth:", "res.windowWidth", "})", "}", "});", "},解析文字内容//", "pages/text2image/text2image.js", "parseContent:", "function", "()", "{", "let", "that", "=", "this;", "let", "i", "=", "0;", "let", "lineNum", "=", "1;", "let", "thinkStr", "=", "'';", "let", "thinkList", "=", "[];", "for", "(let", "item", "of", "that.data.content)", "{", "if", "(item", "===", "'\\n')", "{", "thinkList.push(thinkStr);", "thinkList.push('a');", "i", "=", "0;", "thinkStr", "=", "'';", "lineNum", "+=", "1;", "}", "else", "if", "(i", "===", "19)", "{", "thinkList.push(thinkStr);", "i", "=", "1;", "thinkStr", "=", "item;", "lineNum", "+=", "1;", "}", "else", "{", "thinkStr", "+=", "item;", "i", "+=", "1;", "}", "}", "thinkList.push(thinkStr);", "return", "thinkList;", "}绘制背景//", "pages/text2image/text2image.js", "drawBackground:", "function", "(ctx)", "{", "ctx.drawImage(this.data.backgroundImage);", "}绘制文字//", "pages/text2image/text2image.js", "drawFont:", "function", "(ctx,", "content,", "height)", "{", "ctx.setFontSize(16);", "ctx.setFillStyle(this.data.fontColors[this.data.fontColorIndex]);", "ctx.setTextAlign('center');", "ctx.fillText(content,", "this.data.windowWidth", "/", "2,", "height);", "}清空画布//", "pages/text2image/text2image.js", "clearCanvas:", "function", "(ctx,", "width,", "height)", "{", "ctx.clearRect(0,", "0,", "width,", "height);", "}创建图片//", "pages/text2image/text2image.js", "createNewImg:", "function", "(thinkList)", "{", "let", "that", "=", "this;", "let", "lineNum", "=", "thinkList.length;", "let", "ctx", "=", "wx.createCanvasContext('myCanvas');", "this.clearCanvas(ctx,", "that.data.windowWidth,", "that.data.contentHeight);", "let", "height", "=", "60;", "let", "contentHeight", "=", "(lineNum", "-", "1)", "*", "that.data.lineHeight", "+", "2", "*", "height;", "that.setData({", "contentHeight:", "contentHeight", "});", "that.drawBackground(ctx,", "contentHeight);", "for", "(let", "item", "of", "thinkList)", "{", "if", "(item", "!==", "'a')", "{", "that.drawFont(ctx,", "item,", "height);", "height", "+=", "that.data.lineHeight;", "}", "}", "ctx.draw();", "}生成图片//", "pages/text2image/text2image.js", "generateImage:", "function()", "{", "let", "thinkList", "=", "this.parseContent();", "this.createNewImg(thinkList);", "this.setData({", "hasGenerate:", "true", "});", "}设置页面显示时生成图片//", "pages/text2image/text2image.js", "onShow:", "function(options)", "{", "this.generateImage();", "}这一步的目的是页面初始化页面数据。绑定输入新内容事件//", "pages/text2image/text2image.js", "typeNewContent:", "function(e)", "{", "this.setData({", "content:", "e.detail.value.trim()", "});", "this.generateImage();", "}现在尝试在内容文本框中输入文字，文字会实时显示在下面的图片区域。选择背景图片//", "pages/text2image/textimage.js", "chooseBackgroundImage:", "function", "()", "{", "let", "that", "=", "this;", "wx.chooseImage({", "success:", "function", "(res)", "{", "that.setData({", "backgroundImage:", "res.tempFilePaths[0]", "});", "that.generateImage();", "}", "})", "},从本地相册选择背景图片或使用照相机拍照，选择成功之后重新生成图片。绑定选择字体颜色事件//", "pages/text2image/text2image.js", "bindPickerChange:", "function(e)", "{", "let", "that", "=", "this;", "that.setData({", "fontColorIndex:", "e.detail.value", "});", "that.generateImage();", "},点击选择文字颜色区域，即可进行颜色选择，可以在fontColors数组中添加", "【更多预定义颜色】。保存图片//", "pages/text2image/text2image.js", "savePic:", "function", "()", "{", "let", "that", "=", "this;", "wx.canvasToTempFilePath({", "x:", "0,", "y:", "0,", "width:", "that.data.windowWidth,", "height:", "that.data.contentHeight,", "canvasId:", "'myCanvas',", "success:", "function", "(res)", "{", "that.savePicToAlbum(res.tempFilePath);", "}", "},", "this)", "},", "savePicToAlbum:", "function", "(tempFilePath)", "{", "let", "that", "=", "this;", "wx.getSetting({", "success(res)", "{", "if", "(!res.authSetting['scope.writePhotosAlbum'])", "{", "wx.authorize({", "scope:", "'scope.writePhotosAlbum',", "success()", "{", "wx.saveImageToPhotosAlbum({", "filePath:", "tempFilePath,", "success(res)", "{", "wx.showToast({", "title:", "'保存成功'", "});", "},", "fail(res)", "{", "console.log(res);", "}", "})", "},", "fail()", "{", "//", "用户拒绝授权,打开设置页面", "wx.openSetting({", "success:", "function", "(data)", "{", "console.log(\"openSetting:", "success\");", "},", "fail:", "function", "(data)", "{", "console.log(\"openSetting:", "fail\");", "}", "});", "}", "})", "}", "else", "{", "wx.saveImageToPhotosAlbum({", "filePath:", "tempFilePath,", "success(res)", "{", "wx.showToast({", "title:", "'保存成功',", "});", "},", "fail(res)", "{", "console.log(res);", "}", "})", "}", "},", "fail(res)", "{", "console.log(res);", "}", "})", "}点击保存图片按钮即可保存生成的图片。"]}
{"author": "Rolan", "title": "微信小程序 - 多地点标识(map) ", "content": ["演示如下：wxml1", "<map", "id=\"map\"", "scale=\"{{scale}}\"", "controls=\"{{controls}}\"", "bindcontroltap=\"controltap\"", "markers=\"{{markers}}\"", "bindmarkertap=\"markertap\"", "bindregionchange=\"regionchange\"", "show-location", "style=\"width:", "100%;", "height:", "580px;\"></map>js", "1", "let", "hospitalData", "=", "require('hospitalData')", "2", "Page({", "3", "data:", "{", "4", "centerX:", "0.0,", "5", "centerY:", "0.0,", "6", "//可能我标识的地点和你所在区域比较远，缩放比例建议5;", "7", "scale:15,", "8", "markers:", "[],", "9", "controls:", "[{", "10", "id:", "1,", "11", "iconPath:", "'/image/location-control.png',", "12", "position:", "{", "13", "left:", "0,", "14", "top:", "10,", "15", "width:", "40,", "16", "height:", "40", "17", "},", "18", "clickable:", "true", "19", "}]", "20", "},", "21", "onReady:", "function(e)", "{", "22", "//", "使用", "wx.createMapContext", "获取", "map", "上下文", "23", "this.mapCtx", "=", "wx.createMapContext('myMap')", "24", "},", "25", "26", "onLoad:", "function()", "{", "27", "console.log('地图定位！')", "28", "let", "that", "=", "this", "29", "wx.getLocation({", "30", "type:", "'gcj02',", "//返回可以用于wx.openLocation的经纬度", "31", "success:", "(res)", "=>", "{", "32", "let", "latitude", "=", "res.latitude;", "33", "let", "longitude", "=", "res.longitude;", "34", "let", "marker", "=", "this.createMarker(res);", "35", "this.setData({", "36", "centerX:", "longitude,", "37", "centerY:", "latitude,", "38", "markers:", "this.getHospitalMarkers()", "39", "})", "40", "}", "41", "});", "42", "},", "43", "44", "/**", "45", "*", "标示点移动触发", "46", "*/", "47", "regionchange(e)", "{", "48", "console.log(e.type)", "49", "},", "50", "51", "/**", "52", "*", "点击标识点触发", "53", "*/", "54", "markertap(e)", "{", "55", "console.log(e)", "56", "},", "57", "58", "/**", "59", "*", "control控件点击时间", "60", "*/", "61", "controltap(e)", "{", "62", "console.log(e.controlId)", "63", "this.moveToLocation()", "64", "},", "65", "66", "67", "/**", "68", "*", "获取医院标识", "69", "*/", "70", "getHospitalMarkers()", "{", "71", "let", "markers", "=", "[];", "72", "for", "(let", "item", "of", "hospitalData)", "{", "73", "let", "marker", "=", "this.createMarker(item);", "74", "markers.push(marker)", "75", "}", "76", "return", "markers;", "77", "},", "78", "79", "/**", "80", "*", "移动到自己位置", "81", "*/", "82", "moveToLocation:", "function()", "{", "83", "let", "mpCtx", "=", "wx.createMapContext(\"map\");", "84", "mpCtx.moveToLocation();", "85", "},", "86", "87", "88", "/**", "89", "*", "还有地图标识，可以在name上面动手", "90", "*/", "91", "createMarker(point)", "{", "92", "let", "latitude", "=", "point.latitude;", "93", "let", "longitude", "=", "point.longitude;", "94", "let", "marker", "=", "{", "95", "iconPath:", "\"/image/location.png\",", "96", "id:", "point.id", "||", "0,", "97", "name:", "point.name", "||", "'',", "98", "latitude:", "latitude,", "99", "longitude:", "longitude,100", "width:", "25,101", "height:", "48102", "};103", "return", "marker;104", "}105", "})hospitalData.js", "（模拟数据）", "1", "module.exports", "=", "[{", "2", "\"id\":", "1,", "3", "\"name\":", "\"永州市中心医院\",", "4", "\"longitude\":", "\"111.62852107566833\",", "5", "\"latitude\":", "\"26.42142999357519\"", "6", "},", "7", "{", "8", "\"id\":", "2,", "9", "\"name\":", "\"永州市中医院\",10", "\"longitude\":", "\"111.5972679762268\",11", "\"latitude\":", "\"26.44470581245983\"12", "}13", "]运行示例时，建议放在同一目录下."]}
{"author": "Rolan", "title": "小程序之canvas图片及文本适配 ", "content": ["场景需求小程序目前不支持直接分享到朋友圈，所以对于有分享到朋友圈的需求，一般是生成一张图片，例如，生成一张带有小程序码的图片，用户可以将这张图片保存到手机本地，然后将这张图片分享到朋友圈。这张图片需要使用canvas画出来。今天我们不讲怎么生成码，这个一般是后端封装一个API，前端通过调用API得到一个小程序码的url，通过image去画到canvas上，跟在canvas上画一个image是一样的逻辑。这篇文章主要是讲怎么在canvas上适配图片和文字，也就是怎么将图片和文本画到canvas上的正确的位置，能在不同的手机上都能正确的展示。效果图展示（以下图片是在微信开发者工具中显示的）", "这里演示的Demo是：", "“选择图片”button选择一张图片，可以居中显示在以下图中的黄色区域，即canvas中，并在canvas的顶部居中展示文本“你若盛开，蝴蝶自来”。以下是两个不同尺寸的图片画在canvas上，分别在iphone5、iphone6、iphone6", "plus上的展示效果图。这里的猫图片的原始尺寸：658*658这里的girl图片的原始尺寸是：700*699代码说明小程序尺寸单位小程序尺寸单位2.", "wxml<button", "bindtap=\"chooseImg\">选择图片</button><view", "class=\"canvas-box\">", "<canvas", "class=\"canvas\"", "canvas-id=\"shareCanvas\"", "bindlongtap=\"saveShareImage\"></canvas></view>$3.", "scss（wxss）", "这里我用的是scss去写样式代码，在webStorm中可以通过配置，将scss解析成wxss，至于具体怎么配置，可以自行百度。", "PS1：这里定义了一个scss", "rpx", "function，是因为在webStrom中格式化代码的时候会将数字和单位rpx中间添加一个空格，导致编译报错，所以用一个function去处理", "PS2：样式说明（设计稿是基于iphone6视觉稿标准）：", "button宽高：700rpx", "*", "92rpx", "(350px", "*", "46px)", "包裹canvas的容器的view（.canvas-box）position:fixed,占据除顶部button的高度之外，填满剩余全部空间，canvas居中显示，宽高：700rpx，", "100%@function", "rpx($value)", "{", "@return", "$value*1rpx;}page", "{", "background-color:", "#fff6f6;", "button", "{", "width:", "rpx(700);", "height:", "rpx(92);", "background-color:", "#ffddab", "!important;", "}", ".canvas-box", "{", "position:", "fixed;", "top:", "rpx(92);", "left:", "0;", "right:", "0;", "bottom:", "0;", "canvas", "{", "position:", "absolute;", "width:", "rpx(700);", "height:", "100%;", "top:", "50%;", "left:", "50%;", "transform:", "translate(-50%,", "-50%);", "}", "}}$4.", "js", "1、在data中定义三个变量data:", "{", "windowWidth:", "0,", "//", "可使用窗口宽度", "windowHeight:", "0,", "//", "可使用窗口高度", "ratio:", "0", "//", "根据尺寸动态计算", "1px换算成多少rpx", "}2、通过wx.getSystemInfo获得系统信息，并且计算ratio", "onReady:", "function", "(e)", "{", "//", "获取系统信息", "wx.getSystemInfo({", "success:", "res", "=>", "{", "console.log(res);", "this.setData({", "windowWidth:", "res.windowWidth,", "windowHeight:", "res.windowHeight,", "});", "this.setData({", "//", "屏幕宽度", "375px", "=", "750rpx，1px=2rpx", "//", "1px", "=", "（750", "/", "屏幕宽度）rpx；", "//", "1rpx", "=", "（屏幕宽度", "/", "750）px;", "ratio:", "750", "/", "this.data.windowWidth", "});", "}", "});", "},3、button的触发事件chooseImg，通过wx.chooseImage选择图片，通过wx.getImageInfo获取选择的图片的大小chooseImg:", "function", "()", "{", "wx.chooseImage({", "count:", "1,", "success:", "res", "=>", "{", "let", "imgUrl", "=", "res.tempFilePaths[0];", "//", "获取图片大小", "wx.getImageInfo({", "src:", "imgUrl,", "success:", "data", "=>", "{", "let", "imgWidth", "=", "data.width;", "let", "imgHeight", "=", "data.height;", "//", "创建canvas，根据选择的图片大小，在canvas上绘制图片和文字", "this.createCanvasShareImage(imgUrl,", "imgWidth,", "imgHeight);", "}", "});", "}", "});", "}4、创建canvas并在canvas上添加图片和文本", "createCanvasShareImage:", "function", "(imgUrl,", "imgW,", "imgH)", "{", "//", "使用wx.createCanvasContext获取绘图上下文", "context", "let", "context", "=", "wx.createCanvasContext('shareCanvas');", "console.log('context:", "',", "context);", "//", "获取canvas的宽度：", "//", "750的设计稿基于iphone6的尺寸（屏幕宽度：", "375px）在小程序中的比例是：", "1px", "=", "2rpx", "==>", "375px", "=", "750rpx", "==>", "屏幕宽度(px)", "=", "750rpx", "//", "所以", "1rpx", "=", "屏幕宽度", "/", "750", "//", "我们这里css中设置的", "canvas", "的width：700rpx,", "所以", "canvas的宽度计算是：", "[（屏幕宽度", "/", "750）*", "700]rpx，", "这样就可以做到在不同手机上都可以适配", "let", "canvasWidthPx", "=", "700", "/", "this.data.ratio;", "//", "设置", "canvas", "的背景并填充canvas", "context.fillStyle", "=", "'#ffdc22';", "context.fillRect(0,", "0,", "canvasWidthPx,", "this.data.windowHeight);", "//", "绘制图片：图片居中显示在", "canvas", "中", "let", "imgX", "=", "(700", "-", "imgW)", "/", "2;", "let", "imgY", "=", "(this.data.windowHeight", "*", "this.data.ratio", "-", "46", "*", "this.data.ratio", "-", "imgH)", "/", "2;", "let", "clipWidth", "=", "imgW", "*", "this.data.ratio;", "let", "clipHeight", "=", "imgH", "*", "this.data.ratio;", "context.drawImage(imgUrl,", "-imgX,", "-imgY,", "clipWidth,", "clipHeight,", "0,", "0,", "imgW,", "imgH);", "//", "设置字体大小、文本颜色", "context.setFontSize(20);", "context.fillStyle", "=", "\"#000\";", "//", "计算文本的宽度：measureText()", "取到文本的", "width", "let", "txtWidth", "=", "context.measureText('你若盛开，蝴蝶自来').width;", "//", "绘制居中文本：这个地方的", "(x,", "y)的坐标是在文本的左下角位置", "context.fillText(\"你若盛开，蝴蝶自来\",", "(canvasWidthPx", "-", "txtWidth)", "/", "2,", "20", "*", "this.data.ratio);", "context.draw();", "}5、长按bindlongtapcanva保存图片或者直接预览图片，先通过wx.canvasToTempFilePath将当前画布指定区域的内容导出生成指定大小的的图片，再通过wx.saveImageToPhotosAlbum将图片保存到本地，或者通过wx.previewImage直接预览图片。", "saveShareImage()", "{", "wx.canvasToTempFilePath({", "canvasId:", "'shareCanvas',", "success:", "(res)", "=>", "{", "console.log('canvasToTempFilePath：", "',", "res);", "//", "将图片保存到相册", "wx.saveImageToPhotosAlbum({", "filePath:", "res.tempFilePath,", "success:", "(data)", "=>", "{", "console.log(data);", "}", "});", "//", "直接预览图片", "wx.previewImage({", "urls:", "[res.tempFilePath]", "})", "}", "})", "}真机效果图显示（一加六手机）", "一加6手机显示的小程序效果图.png保存到手机本地的图片.png作者：豆豆的故事", "链接：https://www.jianshu.com/p/75fa54f6caa8"]}
{"author": "Rolan", "title": "mpvue写一个CPASS小程序 ", "content": ["本文是对CPASS项目的技术要点和所踩的坑做一些总结。项目一个提供移动办公场地的小程序平台。使用美团mpvue框架，", "mpvue：1.0.13,", "mpvue-loader：1.0.15", "静态资源（除了tabbar图标）放在阿里云oss组件（页面）间通信四种方式：Vuex状态管理（mapActions，mapGetters）本地缓存（setStorage，getStorage，removeStorage）Bus集中式的事件中间件（$emit，$on，$off）路由query传值这里说一下比较少用的第三种通信方式。Bus应用于非父子组件通信，利用$emit，$on，$off分别来分发、监听、取消监听。第一步：在mixins（混合）建一个文件event-bus.jsimport", "Vue", "from", "'vue';", "export", "default", "new", "Vue();复制代码第二步：在需要分发的组件中引入event-bus，再传递分发事件import", "Bus", "from", "'@/mixins/event-bus'", "//", "需要传递给兄弟组件的值", "let", "params", "=", "{", "***", "}", "Bus.$emit('getParams',", "params)", "复制代码第三步：在需要监听的组件中引入event-bus，在created周期去监听事件（小程序周期监听无效）,在", "beforeDestroy", "周期取消监听事件import", "Bus", "from", "'@/mixins/event-bus'", "created", "()", "{", "//", "监听事件", "Bus.$on('getParams',", "params", "=>", "{", "//", "to", "do", "something", "})", "},beforeDestroy", "()", "{", "//", "清除监听", "Bus.$off('getParams');", "}复制代码swiper选项卡", "+", "无限加载利用微信官方提供的swiper封装一个无限数据加载的swiperTab选项卡。空态下：技术难点：swiper需要设置固定高度，触底", "onReachBottom", "无限加载又需要高度。所以需要在swiper标签设置动态高度", ":style=\"{height:", "swiperHeight", "+", "'px'}\"", "。", "onLoad", "周期获取单个list-item的高度。假如所渲染数据有n组数据，则swiper高度为：", "swiperHeight", "=", "baseHeight", "*", "n", "+", "加载提示占位高度", "。//", "swiper动态设置高度，list为需要渲染的数据", "autoHeight(list)", "{", "let", "num", "=", "list.length;", "//", "this.loadHeight加载提示语的高度", "let", "listHeight", "=", "this.baseItemHeight", "*", "num", "+", "this.loadHeight", "this.swiperHeight", "=", "Math.max(this.windowHeight,", "listHeight);", "},", "//", "获取静态高度", "calcStaticHeight()", "{", "return", "new", "Promise((resolve)", "=>", "{", "let", "self", "=", "this;", "let", "tabListHeight;", "//", "获取tab高度", "//", "获取除去tabList高度，全屏高度（空态状态时需要）", "wx.createSelectorQuery().select('#tab-list').fields({", "size:", "true", "},", "function", "(res)", "{", "tabListHeight", "=", "res.height", "wx.getSystemInfo({", "success:", "function(resp)", "{", "self.windowHeight", "=", "resp.windowHeight", "-", "tabListHeight", "}", "})", "}).exec()", "//", "获取单个item高度", "wx.createSelectorQuery().select('#base-item').fields({", "size:", "true", "},", "function", "(res)", "{", "self.baseItemHeight", "=", "res.height", "resolve()", "}).exec()", "})", "}复制代码如果频繁切换swiper会导致卡死，是因为触摸滑动swiper和点击选项卡时赋值swiperIndex都会触发swiper", "bindchange", "事件，这里做了判断处理。//", "滑动切换", "swiperTab", "(e)", "{", "//", "如果是触摸滑动切换", "if", "(e.mp.detail.source", "===", "'touch')", "{", "if", "(this.currentTab", "===", "e.mp.detail.current)", "{", "return", "false;", "}", "else", "{", "this.currentTab", "=", "e.mp.detail.current", "this.isLoading", "=", "false", "this.allLoaded", "=", "false", "this.pageNum", "=", "1", "this.loadTips", "=", "'上拉加载更多'", "this.getDataList(this.loadTips);", "}", "}", "},", "//", "点击切换", "clickTab", "(tab)", "{", "if", "(this.currentTab", "===", "tab)", "{", "return", "false;", "}", "else", "{", "this.currentTab", "=", "tab", "this.allLoaded", "=", "false", "this.pageNum", "=", "1", "this.loadTips", "=", "'上拉加载更多'", "this.getDataList(this.loadTips);", "}", "},复制代码scroll-view封装indexList实现两种定位方式：点击定位，按住右侧字母indexList滑动定位。技术难点：按住右侧indexList滑动定位，获取字母indexList的上边距", "offsetTop", "，按住滑动时获取手指距离屏幕顶部的距离", "clientY，", "手指移动距离为", "moveY=clientY-offsetTop，", "具体实现如下：//", "索引定位(滑动开始)", "@touchstart=\"handlerStart\"", "handlerStart", "(e)", "{", "this.targetIndex", "=", "e.mp.target.id", "},", "//", "索引定位(滑动过程)", "@touchmove=\"handlerMove\"", "handlerMove(e)", "{", "let", "keyList", "=", "this.keyList;", "//", "手指滑动垂直距离", "let", "moveY", "=", "e.mp.touches[0].clientY;", "let", "rY", "=", "moveY", "-", "this.offsetTop;", "if", "(rY", ">=", "0)", "{", "//", "apHeight为字母表indexList中单个字母块高度，计算结果向上取整", "let", "index", "=", "Math.ceil((rY", "-", "this.apHeight)", "/", "this.apHeight);", "if", "(index", ">=", "0", "&&", "index", "<", "keyList.length)", "{", "this.targetIndex", "=", "keyList[index];", "}", "}", "else", "{", "this.targetIndex", "=", "keyList[0]", "}", "},复制代码坑view或者text设置border-radius=50%有时候在真机会变形（排除flex布局的影响）。wxml不支持复杂逻辑，如模版字符串，字符串截取等等。text设置行高的时候会出现样式异常，替换成view便可解决此问题。wx.showLoading和wx.showToast的属性title不可为空，线上会报错，影响js执行。总结本文只是简单讲一下项目中涉及到的几处技术要点，欢迎交流。打一波广告："]}
{"author": "Rolan", "title": "微信小程序集成 Jenkins ", "content": ["微信小程序的测试发布在没有", "CI/CD", "等相关工具的情况下，存在着如下的问题：小程序开发助手中，同一个开发者只能显示一个开发版本测试同事找开发要二维码，效率较低本地生成的二维码会出现携带本地代码、未及时拉取分支其他改动等问题为了避免如上问题的发生，采用", "微信小程序集成", "Jenkins", "的方案。基础在介绍实现方案之前，先来回顾一下常规的微信小程序发布流程。从上面的流程图可以看出，微信小程序预览、上传都是需要在微信开发者工具中进行的，接下来了解一下微信开发者工具提供的上传方式。微信开发者工具除了图形化界面，微信开发者工具还提供了命令行与", "HTTP", "服务两种接口供外部调用，来进行登录、预览、上传等操作。命令行调用命令行工具所在位置：macOS:", "<安装路径>/Contents/Resources/app.nw/bin/cliWindows:", "<安装路径>/cli.bat以", "macOS", "操作系统示例：1、打开开发者工具：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli", "-o", "复制代码其中，", "/Applications/wechatwebdevtools.app/", "为安装路径。2、登录：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli", "-l", "复制代码输入上面的命令行后，终端中打印出登录二维码，使用微信扫码登录。在微信端完成操作之后，会输出", "login", "success", "，如下图所示：如果想得到", "base64", "形式的二维码，可以使用下面的命令：#", "登录，在终端中打印登录", "base64", "形式的二维码", "cli", "-l", "--login-qr-output", "base64", "#", "登录，二维码转成", "base64", "并存到文件", "/Users/username/code.txt", "cli", "-l", "--login-qr-output", "base64@/Users/username/code.txt", "复制代码更多", "API", "可以参考命令行调用", "。HTTP", "服务HTTP", "服务在", "工具启动后自动开启", "，每次开启", "host", "固定为", "127.0.0.1，端口号并不固定。端口号在", "用户目录", "下记录，位置如下：macOS", ":", "~/Library/Application", "Support/微信web开发者工具/Default/.ideWindows", ":", "~/AppData/Local/微信web开发者工具/User", "Data/Default/.ide以", "macOS", "操作系统示例：首先需要", "运行开发者工具", "，可以利用上面介绍的命令行方法打开微信开发者工具。/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli", "-o", "port=$(cat", "\"/Users/zyy/Library/Application", "Support/微信web开发者工具/Default/.ide\")", "echo", "\"微信开发者工具运行在${port}端口\"", "复制代码这样就可以拿到微信开发者工具运行的端口号了，其中，", "/Users/zyy/", "为用户目录。1、打开开发者工具：#", "打开工具", "http://127.0.0.1:端口号/open", "#", "打开/刷新项目", "http://127.0.0.1:端口号/open?projectpath=项目全路径", "复制代码2、登录：#", "登录，返回图片格式的二维码", "http://127.0.0.1:端口号/login", "#", "登录，取", "base64", "格式二维码", "http://127.0.0.1:端口号/login?format=base64", "#", "登录，取", "base64", "格式二维码，并写入", "/Users/username/logincode.txt", "http://127.0.0.1:端口号/login?format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt", "复制代码3、预览：#", "预览路径为", "/Users/username/demo", "的项目，返回图片格式的二维码", "http://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo", "#", "预览路径为", "/Users/username/demo", "的项目，返回", "base64", "格式的二维码", "http://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64", "#", "预览路径为", "/Users/username/demo", "的项目，返回", "base64", "格式的二维码，并写入", "/Users/username/logincode.txt", "http://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt", "#", "预览路径为", "/Users/username/demo", "的项目，返回图片格式的二维码，并将预览信息输出至", "/Users/username/info.json", "http://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&infooutput=%2Users%2username%2info.json", "复制代码更多", "API", "可以参考HTTP", "调用", "。方案微信开发者工具目前只有", "macOS", "和", "Windows", "两种版本，这限制了服务器的系统。下面以", "macOS", "为例，", "来介绍具体的实现过程：安装", "JenkinsThe", "leading", "open", "source", "automation", "server,", "Jenkins", "provides", "hundreds", "of", "plugins", "to", "support", "building,", "deploying", "and", "automating", "any", "project.作为领先的开源自动化服务器，Jenkins提供数百个插件来支持构建，部署和自动化任何项目。Jenkins", "依赖于", "Java", "运行环境，所以需要在机器上安装", "Java。安装", "Jenkins", "方式很多，可以在官网直接下载最新的软件包，然后执行下面的命令启动", "Jenkins", "。java", "-jar", "jenkins.war", "--httpPort=8888", "复制代码其中，", "--httpPort=8888", "为设置服务端口号，默认端口号为", "8080", "。新建任务选择", "“", "构建一个自由风格的软件项目", "”", "，在输入任务名称之后，点击确定按钮，进入到任务配置页面。任务配置在介绍任务配置之前，先来看一下最终要实现的功能。主要的功能点如下：使用", "git", "来管理代码，可以选择分支打包版本（开发版／体验版）可以选择（注意：这里的「开发版」对应「预览」，体验版对应「上传」）1、源码管理在任务配置页面的第二项", "“源码管理”", "中，选择", "git", "方式管理代码。填入", "git", "仓库地址及访问的账户，上图中的", "$branch", "是自定义的构建参数，下面来看一下构建参数的定义。2、构建参数在任务配置页面的第二项", "“General”", "中，选择", "“参数化构建过程”，进入构建参数配置页面。参数有上述的几种类型供选择，可以参考下图进行配置，这里不再赘述。需要注意的是，这里的", "name", "可以通过", "branch", "。构建在任务配置页面的", "“构建”", "中，选择", "“执行", "shell”", "方式来进行构建。Tips：这里的", "shell", "脚本是微信小程序集成", "Jenkins", "最核心的内容。回顾一下，本文最开始提到的微信小程序发布流程图：这一系列的操作使用", "shell", "脚本来完成，如何实现呢？登录微信开发者工具的登录需要在微信端扫码确认，这一步微信并没有提供账号密码的登录方式。不过，微信开发者工具是可以保持登录态的。由于微信限制，一个开发者身份只能在一个终端登录，所以我们申请了一个新的微信账号「前端小姐姐」用于在", "Jenkins", "机器上登录。项目基础设置在图形化界面中，上传代码时，会在开发者工具中填入", "AppID", "、项目路径等信息，也会在「详情」中选择项目的基本设置，比如「ES6", "转", "ES5」。微信还提供了一种配置方法，在项目根目录使用", "project.config.json", "文件。这里通过一段", "node", "脚本，生成", "project.config.json", "文件。const", "fs", "=", "require('fs')", "const", "content", "=", "'{\"description\":\"项目配置文件。\",\"setting\":{\"urlCheck\":false,\"es6\":true,\"postcss\":true,\"minified\":true,\"newFeature\":true},\"miniprogramRoot\":\"./\",\"compileType\":\"miniprogram\",\"appid\":\"***\",\"projectname\":\"wechat-app\",\"condition\":{\"search\":{\"current\":-1,\"list\":[]},\"conversation\":{\"current\":-1,\"list\":[]},\"plugin\":{\"current\":-1,\"list\":[]},\"game\":{\"currentL\":-1,\"list\":[]},\"miniprogram\":{\"current\":-1,\"list\":[]}}}'", "fs.writeFileSync('./dist/project.config.json',", "content,", "'utf-8')", "复制代码这样就完成了项目的基础设置，接下来将介绍如何通过", "shell", "脚本完成上传。shell", "脚本echo", "-------------------------------------------------------", "echo", "GIT_BRANCH:", "${GIT_BRANCH}", "echo", "-------------------------------------------------------", "#", "执行项目构建", "npm", "i", "--registry=http://registry.npm.taobao.org", "npm", "run", "build", "#", "打开微信开发者工具", "/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli", "-o", "port=$(cat", "\"/Users/devops/Library/Application", "Support/微信web开发者工具/Default/.ide\")", "echo", "\"微信开发者工具运行在${port}端口\"", "return_code=$(curl", "-sL", "-w", "%{http_code}", "http://127.0.0.1:${port}/open)", "if", "[", "$return_code", "==", "200", "]", "then", "echo", "\"返回状态码200，devtool启动成功！\"", "else", "echo", "\"返回状态码${return_code}，devtool启动失败\"", "exit", "1", "fi", "if", "[", "\"$build_type\"", "==", "\"dev\"", "]", "then", "echo", "\"发布开发版！\"", "wget", "-O", "$BUILD_ID.png", "http://127.0.0.1:${port}/preview?projectpath=/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist", "echo", "\"预览成功！请扫描二维码进入开发版！\"", "elif", "[", "\"$build_type\"", "==", "'prod'", "]", "then", "echo", "\"准备上传！\"", "/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli", "-u", "1.0.0@/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist", "--upload-desc", "'initial", "release'", "echo", "\"上传成功！请到微信小程序后台设置体验版并提交审核！\"", "fi", "复制代码因为本项目需要编译代码，所以服务器上需要安装", "node", "和", "npm。", "npm", "run", "build", "命令不光在编译代码，而且还执行了前面介绍的生成", "project.config.json", "的", "node", "脚本。开发版上传成功后，将二维码图片保存下来，用于构建后显示二维码和发送邮件。这里结合", "命令行调用", "和", "HTTP", "调用", "两种方式来完成上传，主要出于以下原因：HTTP", "调用", "可以很方便的下载生成的二维码图片HTTP", "服务", "只有在微信开发者工具启动之后，才会启动，所以需要通过", "命令行调用", "方式，来启动微信开发者工具构建后使用", "description", "setter", "plugin", "插件来实现，构建完成后显示二维码图片。安装插件回到", "Jenkins", "主页，在「系统管理」中，进入到「插件管理」页面，搜索", "description", "setter", "plugin", "并安装。安装好插件后，返回任务配置页面。在「构建后操作」中，增加「Set", "build", "description」步骤，如下图：这里采用", "HTML", "<img>", "标签形式，展示二维码信息，如下：<img", "src=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\"", "alt=\"二维码${BUILD_ID}\"", "width=\"200\"", "height=\"200\"", "/>", "<a", "href=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\">二维码${BUILD_ID}</a>", "复制代码按照上面的方式配置后，发现图片并没有显示出来，而是显示了文本信息。这是由于", "Jenkins", "出于安全的限制，所有描述信息的", "Markup", "Formatter", "默认都采用", "Plain", "text", "的模式。在「系统管理」->", "「全局安全配置」中，将", "Markup", "Formatter", "由", "Plain", "text", "(纯文本)", "更改为", "Safe", "HTML", "即可。按照上面的步骤操作后，就可以显示出开发版二维码。因为", "Jenkins", "构建时，均使用「前端小姐姐」微信账号，所以小程序开发助手上「前端小姐姐」发布的开发版不确定是哪位同学构建的，故需要使用", "Jenkins", "平台生成的二维码，并注意二维码有效期（有效期25分钟）。总结本文以微信小程序常规的发布流程为切入点，循序渐进地介绍了如何集成", "Jenkins", "实现微信小程序预览、上传功能。后台、测试同事可以在该平台上选择分支获取开发版用于联调、测试，解决了本文开篇提及的问题。由于本文篇幅有限，只是介绍了该平台的一些基本功能，如果有其他的需求，可以参考文末的拓展链接解决。此外，文中若有任何表述不清或不当的地方，欢迎大家批评指正～本文首发于", "github.com/yingye/Blog…", "，欢迎各位关注我的Blog，正文以issue形式呈现，喜欢请点star，订阅请点watch～"]}
{"author": "Rolan", "title": "简陋至极：微信小程序日历组件（思路） ", "content": ["最近在做微信小程序项目，其中涉及到日历。一直以来，遇到日历，就是网上随便找个插件，这次心血来潮，想着自己去实现一下。这次不是封装功能强大，健硕完美的组件，只是记录一下，主体思路。更多功能还得根据项目需要，自己去挖掘、实现。（大佬轻喷）思路分析首先最主要的一点，就是要计算出某年某月有多少天，其中涉及到大小月，闰、平年二月。其次，弄清楚每月一号对应的是周几。然后，有时为填充完整，还需显示上月残余天数以及下月开始几天，这些又该如何展示。最后，根据自己项目需求实现其它细枝末节。计算每月天数按照一般思路，[1,3,5,7,8,10,12]这几个月是31天，[2,3,6,9,11]这几个月是30天，闰年2月29天，平年2月28天。每次需要计算天数时，都得如此判断一番。方案可行，而且也是大多数人的做法。但是，这个方法，我却觉得有些繁琐。其实换一种思路，也未尝不可。时间戳就是一个很好的载体。当前月一号零时的时间戳，与下一月一号零时的时间戳之差，不就是当前月天数的毫秒数嘛。//", "获取某年某月总共多少天", "getDateLen(year,", "month)", "{", "let", "actualMonth", "=", "month", "-", "1;", "let", "timeDistance", "=", "+new", "Date(year,", "month)", "-", "+new", "Date(year,", "actualMonth);", "return", "timeDistance", "/", "(1000", "*", "60", "*", "60", "*", "24);", "},", "复制代码看到上述代码，你可能会问，是不是还缺少当月为12月时的特殊判断，毕竟涉及到跨年问题。当然，你无需担心,根据MDN中关于Date的表述，js已经为我们考虑好了这一点当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为13或者分钟数为70），相邻的数值会被调整。比如", "new", "Date(2013,", "13,", "1)等于new", "Date(2014,", "1,", "1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new", "Date(2013,", "2,", "1,", "0,", "70)等于new", "Date(2013,", "2,", "1,", "1,", "10)，都表示时间2013-03-01T01:10:00。计算每月一号是周几呃，这个就不需要说了吧，getDay()你值得拥有//", "获取某月1号是周几", "getFirstDateWeek(year,", "month)", "{", "return", "new", "Date(year,", "month", "-", "1,", "1).getDay()", "},", "复制代码每个月的数据如何展示如果只是简单展示当月数据，那还是很简单的，获取当月天数，依次遍历，就可以拿到当月所有数据。//", "获取当月数据，返回数组", "getCurrentArr(){", "let", "currentMonthDateLen", "=", "this.getDateLen(this.data.currentYear,", "this.data.currentMonth)", "//", "获取当月天数", "let", "currentMonthDateArr", "=", "[]", "//", "定义空数组", "if", "(currentMonthDateLen", ">", "0)", "{", "for", "(let", "i", "=", "1;", "i", "<=", "currentMonthDateLen;", "i++)", "{", "currentMonthDateArr.push({", "month:", "'current',", "//", "只是为了增加标识，区分上下月", "date:", "i", "})", "}", "}", "this.setData({", "currentMonthDateLen", "})", "return", "currentMonthDateArr", "},", "复制代码很多时候，为了显示完整，需要显示上下月的残余数据。一般来说，日历展示时，最大是7", "X", "6", "=", "42位，为啥是42位，呃，自己去想想吧。当月天数已知，上月残余天数，我们可以用当月1号是周几来推断出来，下月残余天数，正好用42", "-", "当月天数", "-上月残余。//", "上月", "年、月", "preMonth(year,", "month)", "{", "if", "(month", "==", "1)", "{", "return", "{", "year:", "--year,", "month:", "12", "}", "}", "else", "{", "return", "{", "year:", "year,", "month:", "--month", "}", "}", "},", "复制代码//", "获取当月中，上月多余数据，返回数组", "getPreArr(){", "let", "preMonthDateLen", "=", "this.getFirstDateWeek(this.data.currentYear,", "this.data.currentMonth)", "//", "当月1号是周几", "==", "上月残余天数）", "let", "preMonthDateArr", "=", "[]", "//", "定义空数组", "if", "(preMonthDateLen", ">", "0)", "{", "let", "{", "year,", "month", "}", "=", "this.preMonth(this.data.currentYear,", "this.data.currentMonth)", "//", "获取上月", "年、月", "let", "date", "=", "this.getDateLen(year,", "month)", "//", "获取上月天数", "for", "(let", "i", "=", "0;", "i", "<", "preMonthDateLen;", "i++)", "{", "preMonthDateArr.unshift({", "//", "尾部追加", "month:", "'pre',", "//", "只是为了增加标识，区分当、下月", "date:", "date", "})", "date--", "}", "}", "this.setData({", "preMonthDateLen", "})", "return", "preMonthDateArr", "},", "复制代码//", "下月", "年、月", "nextMonth(year,", "month)", "{", "if", "(month", "==", "12)", "{", "return", "{", "year:", "++year,", "month:", "1", "}", "}", "else", "{", "return", "{", "year:", "year,", "month:", "++month", "}", "}", "},", "复制代码//", "获取当月中，下月多余数据，返回数组", "getNextArr()", "{", "let", "nextMonthDateLen", "=", "42", "-", "this.data.preMonthDateLen", "-", "this.data.currentMonthDateLen", "//", "下月多余天数", "let", "nextMonthDateArr", "=", "[]", "//", "定义空数组", "if", "(nextMonthDateLen", ">", "0)", "{", "for", "(let", "i", "=", "1;", "i", "<=", "nextMonthDateLen;", "i++)", "{", "nextMonthDateArr.push({", "month:", "'next',//", "只是为了增加标识，区分当、上月", "date:", "i", "})", "}", "}", "return", "nextMonthDateArr", "},", "复制代码整合三组数据，就得到了完整的当月数据，格式如下[", "{month:", "\"pre\",", "date:", "30},", "{month:", "\"pre\",", "date:", "31},", "{month:", "\"current\",", "date:", "1},", "{month:", "\"current\",", "date:", "2},", "...", "{month:", "\"current\",", "date:", "31},", "{month:", "\"next\",", "date:", "1},", "{month:", "\"next\",", "date:", "2}", "]", "复制代码至于上下月切换，选择某年某月等功能，无非就是参数变化而已，自己琢磨琢磨即可。骨架都有了，你想创造什么样的功能还不是手到擒来。"]}
{"author": "Rolan", "title": "微信小程序 | 切换按钮或者view的选中状态 ", "content": ["实现非常简单，通过一个简单的判断当前data中的选中值，点击按钮时更新data值，重新渲染页面。index.wxml文件<view", "class=\"switch-type\">", "<view", "class=\"btn", "{{currentSelectTripType", "==", "'pinche'", "?", "'active'", ":", "''}}\"", "bindtap='selectedPinche'", "data-id='pinche'>拼车</view>", "<view", "class=\"btn", "{{currentSelectTripType", "==", "'baoche'", "?", "'active'", ":", "''}}\"", "bindtap='selectedBaoche'", "data-id='baoche'>包车</view>", "</view>", "index.js文件Page({", "data:", "{~~~~", "currentSelectTripType:", "'pinche',", "},", "//", "更新data", "切换选中状态", "selectedPinche:", "function", "(e)", "{", "this.setData({", "currentSelectTripType:", "e.currentTarget.dataset.id", "})", "},", "selectedBaoche:", "function(e)", "{", "this.setData({", "currentSelectTripType:", "e.currentTarget.dataset.id", "})", "},", "})", "附上一个简单的样式index.wxss.switch-type", "{", "display:", "flex;", "}", ".switch-type", ".btn:first-child", "{", "border-top-right-radius:", "0;", "border-bottom-right-radius:", "0;", "}", ".switch-type", ".btn:last-child", "{", "border-top-left-radius:", "0;", "border-bottom-left-radius:", "0;", "}", ".switch-type", ".btn", "{", "background:", "#dfdfdf;", "padding:", "10rpx", "40rpx;", "}", ".switch-type", ".btn.active", "{", "border:", "2rpx", "solid", "#007bff;", "background:", "#fff;", "}"]}
{"author": "Rolan", "title": "使用mpvue开发github小程序总结 ", "content": ["最近有点闲，想起关注已久的", "mpvue", "写小程序，所以稍微肝了半个多月写了个", "github", "版的微信小程序，已上线。现在总结一下遇到的坑。项目地址、", "github.com/cheesekun/w…mina坑scroll-view", "高度可滚动视图区域。使用竖向滚动时，需要给", "<scroll-view/>", "一个固定高度，通过", "WXSS", "设置", "height。小程序提供的", "scroll-view", "组件，想让他能滚动，就要给他提供一个固定的高度。我们一般需求是，上一块区域固定，下一块区域可滚动，我的处理方法是，拿到机型的可视高度，减去上一块固定区域的高度，动态赋值", "scroll-view", "最终高度。//", "以", "search", "页为例", "//", "滚动区域高度", "=", "总高度", "-", "搜索框高度", "-", "tabs", "高度", "onLoad", "()", "{", "wx.getSystemInfo({", "success:", "(res)", "=>", "{", "this.height", "=", "res.windowHeight", "//", "获取机型可视高度", "}", "})", "let", "query", "=", "wx.createSelectorQuery()", "//", "选择id", "query.select('#search').boundingClientRect()", "query.exec(res", "=>", "{", "let", "searchH", "=", "res[0].height", "//", "获取search框高度", "this.height", "=", "this.height", "-", "searchH", "-", "this.tabsH", "})", "}", "复制代码坑点：", "wx.createSelectorQuery()", "获取不了", "display:", "none", "的元素高度。我的解决方法是：在", "trending", "页获取到", "tabs", "组件的高度，再存放到", "vuex", "中，给", "search页使用生命周期（同一page携带不同参数）小程序生命周期当我们从一个页面①进入页面②时，我们一般在", "onLoad", "进行初始数据的获取，从页面②返回到页面①时，若两个页面是不同的page，如", "①为page/info", "，②为page/repo，那没问题，①页面", "unOnLoad", "，②页面", "onShow", "。但是若", "①为page/info?user=a", "，", "②为page/info?user=b", "，那gg了，从页面②返回到页面①，页面①的数据会变成页面②的数据为了避免这种情况，我一开始使用", "onShow", "代替", "onLoad", "，也就是在", "onShow", "的时候获取页面的初始数据。但是这个情况就有点可怕了，我们知道", "onShow", "很多情况都会触发到，切换前后台，从一个页面返回到另一个，都会触发", "onShow", "，这就导致会触发很多不必要的请求，而且用户体验极差。可我很多需求就是类似从", "①为page/info?user=a", "到", "②为page/info?user=b", "，因此曲线救国想出用", "vuex", "维护有相关需求页面的路由栈。页面", "onLoad", "的时候，推入query参数到栈中，", "onShow", "时，若当前页面的参数和栈中最后一个元素相同，则不重新加载数据。当页面被销毁，则在", "onUnload", "中把相应的页面栈推出。这样就可以避免很多无谓的", "onShow", "请求。onLoad", "()", "{", "this.reset()", "const", "options", "=", "getQuery()", "user", "=", "options.login", "//", "vuex", "this.reposStack.push(options)", "this.getRepos()", "},", "onShow", "()", "{", "const", "options", "=", "getQuery()", "//", "vuex", "let", "reposStack", "=", "JSON.parse(JSON.stringify(this.reposStack))", "let", "len", "=", "reposStack.length", "let", "endStack", "=", "reposStack[len", "-", "1]", "if", "(JSON.stringify(endStack)", "===", "JSON.stringify(options))", "{", "return", "}", "this.reset()", "user", "=", "options.login", "this.getRepos()", "},", "onUnload", "()", "{", "//", "vuex", "this.reposStack.slice(0,", "-1)", "}", "复制代码mpvue坑query参数mpvue", "可以通过", "this.$root.$mp.query", "在所有页面的组件内获取路径参数。如果以", "mina", "来说的话，我们是通过在生命周期", "onLoad(options)", "，拿到", "options", "上携带的路径参数，", "mpvue", "提供了", "this.$root.$mp.query", ",我们可以所有生命周期上使用。但是我们知道，当我们从当前页返回到上一页时，上一页并不会执行", "onLoad()", ",假设当前页和上一页是同个", "page", "，只是携带参数不同的话，此时回退到上一页，上一页的", "this.$root.$mp.query", "不会变成自己的", "query", "，还是会变成当前页的", "query举例：①page/info?a=1", "=>", "②page/info?b=2当我从②返回到①时，①的", "this.$root.$mp.query", "会变成", "{b:2}我猜", "mpvue", "的", "this.$root.$mp.query", "是通过", "onLoad(options)", "获取到", "options", "，再赋值。但是遇到小程序页面返回不会执行", "onLoad为了避免麻烦，我直接使用了小程序的api", "getCurrentPages()", "，获取路由栈中最后一个路由的参数getCurrentPages()", "函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。/**", "*", "获取当前路径参数", "*", "不用mpvue提供的this.$root.$mp.query", "*", "因为其进入同一页面，参数不会变化", "*/", "export", "function", "getQuery", "()", "{", "/*", "获取当前路由栈数组", "*/", "const", "pages", "=", "getCurrentPages()", "const", "currentPage", "=", "pages[pages.length", "-", "1]", "const", "options", "=", "currentPage.options", "return", "options", "}", "复制代码后记前面几个问题是我初次使用", "mpvue", "开发小程序遇到的最大的坑了吧。（好久没有写东西了，写得好烂。）不过确实使用", "mpvue", "开发小程序，能组件化，支持", "npm", "，比原生开发舒服很多。体验还是很好的。", "小程序现在是真的太火了。感觉是个前端都要去玩一下。", "再次推一下项目地址，有兴趣的朋友可以参考一下。", "github.com/cheesekun/w…作者：芝士君原文：https://juejin.im/post/5b7bd9ea51882542d23a0e3d"]}
{"author": "Rolan", "title": "微信小程序 canvas圆角矩形的绘制 ", "content": ["作者：", "清夜原文：https://juejin.im/post/5b7cecd7e51d4538e3318f27微信小程序允许对普通元素通过", "border-radius", "的设置来进行圆角的绘制，但有时候在使用", "canvas", "绘图的时候，也需要圆角，例如需要将页面上某块区域导出为图片下载到本地的时候，常用的解决方法就是使用", "canvas", "将这块区域绘制出来，最后导出", "canvas", "即可，但是", "canvas", "没有直接提供圆角的绘制", "api", "，所以需要", "曲线救国圆角矩形与一般矩形的区别在于，前者的四个角都是圆弧，所以只需要将一般矩形的四个角切掉，换成圆弧即可，如下图就是一个一般矩形被切掉了四个角的样子：很明显，切掉了四个角的矩形，剩下其实就是四条", "line", "，既然如此，完全可以跳过绘制矩形然后切角这一步，因为切角的结果就是四条边(", "line", ")，直接绘制四条边即可。", "然后在每两条边的缺角处绘制弧度为", "0.5", "*", "Math.PI", "的圆弧，最后这四条边与四个圆弧所封闭的图形就是圆角矩形：原理知道了，代码就很好写了，这里只说几个注意点：封闭图形的", "fillStyle", "颜色设置为", "transparent想将封闭路径的图形绘制下来，需要调用", "stroke", "或", "fill", "方法，默认", "stroke", "或", "fill", "的颜色是", "black", "，但是这里有个问题，", "圆弧的绘制可能会出现锯齿或者糊边，如果", "stroke", "或", "fill的颜色，与你所需要绘制的圆角矩形的边缘色调不一致，这种糊边的感觉会比二者色调一致的更明显，", "下图第一个为色调一致，第二个为色调不一致的情况：不过据我观测，只要不是特意放大仔细看，无论是色调是否一致，其实一般人很难注意到糊边的事情clip绘制好了圆角选区之后，还需要调用", "ctx.clip", "方法来裁剪选区save", "与", "restore如果这个矩形选区只是", "canvas", "画布的一部分，为了避免对后续的影响，最好在", "beginPath", "之前，将之前的动作", "save", "，然后画完后再", "restore一个关于", "在", "canvas", "上绘制圆角图片，并下载到本地", "的可运行示例代码已经放到", "github", "上了，注释也比较详细，需要的可自取其中关键代码如下：/**", "*", "*", "@param", "{CanvasContext}", "ctx", "canvas上下文", "*", "@param", "{number}", "x", "圆角矩形选区的左上角", "x坐标", "*", "@param", "{number}", "y", "圆角矩形选区的左上角", "y坐标", "*", "@param", "{number}", "w", "圆角矩形选区的宽度", "*", "@param", "{number}", "h", "圆角矩形选区的高度", "*", "@param", "{number}", "r", "圆角的半径", "*/", "function", "roundRect(ctx,", "x,", "y,", "w,", "h,", "r)", "{", "//", "开始绘制", "ctx.beginPath()", "//", "因为边缘描边存在锯齿，最好指定使用", "transparent", "填充", "//", "这里是使用", "fill", "还是", "stroke都可以，二选一即可", "ctx.setFillStyle('transparent')", "//", "ctx.setStrokeStyle('transparent')", "//", "左上角", "ctx.arc(x", "+", "r,", "y", "+", "r,", "r,", "Math.PI,", "Math.PI", "*", "1.5)", "//", "border-top", "ctx.moveTo(x", "+", "r,", "y)", "ctx.lineTo(x", "+", "w", "-", "r,", "y)", "ctx.lineTo(x", "+", "w,", "y", "+", "r)", "//", "右上角", "ctx.arc(x", "+", "w", "-", "r,", "y", "+", "r,", "r,", "Math.PI", "*", "1.5,", "Math.PI", "*", "2)", "//", "border-right", "ctx.lineTo(x", "+", "w,", "y", "+", "h", "-", "r)", "ctx.lineTo(x", "+", "w", "-", "r,", "y", "+", "h)", "//", "右下角", "ctx.arc(x", "+", "w", "-", "r,", "y", "+", "h", "-", "r,", "r,", "0,", "Math.PI", "*", "0.5)", "//", "border-bottom", "ctx.lineTo(x", "+", "r,", "y", "+", "h)", "ctx.lineTo(x,", "y", "+", "h", "-", "r)", "//", "左下角", "ctx.arc(x", "+", "r,", "y", "+", "h", "-", "r,", "r,", "Math.PI", "*", "0.5,", "Math.PI)", "//", "border-left", "ctx.lineTo(x,", "y", "+", "r)", "ctx.lineTo(x", "+", "r,", "y)", "//", "这里是使用", "fill", "还是", "stroke都可以，二选一即可，但是需要与上面对应", "ctx.fill()", "//", "ctx.stroke()", "ctx.closePath()", "//", "剪切", "ctx.clip()", "}", "复制代码"]}
{"author": "Rolan", "title": "微信小程序 手势解锁组件（无卡顿） ", "content": ["本人博客文章地址：http://liuhuihao.com/fontend/js/mini-gestrue-lock/代码地址：", "Mpvue版本：", "https://github.com/geminate/mpvue-gesture-lock", "原生小程序版本：https://github.com/geminate/mini-gesture-lock一.", "简介最近在", "开发小程序的时候", "遇到了这种手势解锁的需求，网上逛了一圈基本都是使用Canvas实现的，经过本人测试，所有使用Canvas实现的解锁组件，在Android实机测试时均存在严重卡顿问题。原因是", "小程序的", "canvas", "onTouchMove事件效率很低（2018/08/17", "测试），吐槽一句，小程序现在有很多的坑官方都不去处理，论坛里一大堆问题也没人解决。。。。既然微信官方暂时没有要解决这个问题的意思，那咱们开发者就只能自己想办法了，于是本人**使用", "dom", "实现", "**了一个基础版本的", "手势解锁组件，有两个版本，分别使用mpvue", "和", "小程序原生写法。效果图：gesture.gif二.", "核心实现由于", "mpvue", "版本", "和", "小程序原生版本思路基本一致，仅代码写法略有不同，因此一下均以", "mpvue", "代码做说明。布局代码<div", "class=\"gesture-lock\"", ":class=\"{error:error}\"", ":style=\"{width:", "containerWidth", "+'rpx',", "height:containerWidth", "+'rpx'}\"", "@touchstart=\"onTouchStart\"", "@touchmove=\"onTouchMove\"", "@touchend=\"onTouchEnd\"", ">", "<!--", "9", "个圆", "-->", "<div", "v-for=\"(item,i)", "in", "circleArray\"", ":key=\"i\"", "class=\"cycle\"", ":class=\"{check:item.check}\"", ":style=\"{left:item.style.left,top:item.style.top,width:item.style.width,height:item.style.width}\">", "</div>", "<!--", "已激活锁之间的线段", "-->", "<div", "v-for=\"(item,i)", "in", "lineArray\"", ":key=\"i\"", "class=\"line\"", ":style=\"{left:item.activeLeft,top:item.activeTop,width:item.activeWidth,transform:'rotate('+item.activeRotate+')'}\">", "</div>", "<!--", "最后一个激活的锁与当前位置之间的线段", "-->", "<div", "class=\"line\"", ":style=\"{left:activeLine.activeLeft,top:activeLine.activeTop,width:activeLine.activeWidth,transform:'rotate('+activeLine.activeRotate+')'}\">", "</div>", "</div>布局代码主要分为", "3", "部分：9个圆形锁、已激活的锁之间的线段", "和", "最后一个激活的锁与当前手指位置之间的线段。全部", "线段", "与", "圆", "均通过", "dom和样式实现。避免canvas卡顿。2.", "JS逻辑(1).", "初始化constructor(containerWidth,", "cycleRadius)", "{", "//", "....", "this.windowWidth", "=", "wx.getSystemInfoSync().windowWidth;//", "窗口大小(用于rpx", "和", "px", "转换)", "this.initCircleArray();", "}", "//", "初始化", "画布上的", "9个圆", "initCircleArray()", "{", "const", "cycleMargin", "=", "(this.containerWidth", "-", "6", "*", "this.cycleRadius)", "/", "6;", "let", "count", "=", "0;", "for", "(let", "i", "=", "0;", "i", "<", "3;", "i++)", "{", "for", "(let", "j", "=", "0;", "j", "<", "3;", "j++)", "{", "count++;", "this.circleArray.push({", "count:", "count,", "x:", "this.rpxTopx((cycleMargin", "+", "this.cycleRadius)", "*", "(j", "*", "2", "+", "1)),", "y:", "this.rpxTopx((cycleMargin", "+", "this.cycleRadius)", "*", "(i", "*", "2", "+", "1)),", "radius:", "this.rpxTopx(this.cycleRadius),", "check:", "false,", "style:", "{", "left:", "(cycleMargin", "+", "this.cycleRadius)", "*", "(j", "*", "2", "+", "1)", "-", "this.cycleRadius", "+", "'rpx',", "top:", "(cycleMargin", "+", "this.cycleRadius)", "*", "(i", "*", "2", "+", "1)", "-", "this.cycleRadius", "+", "'rpx',", "width:", "this.cycleRadius", "*", "2", "+", "'rpx',", "}", "});", "}", "}", "}初始化的时候，需要将9个圆的对象数组初始化，根据输入的容器宽度", "和", "锁半径计算出9个锁的位置及对应的css样式。这里需要注意rpx与px之前的转换。(2).", "onTouchStartonTouchStart(e)", "{", "this.setOffset(e);", "this.checkTouch({x:", "e.pageX", "-", "this.offsetX,", "y:", "e.pageY", "-", "this.offsetY});", "}//", "检测当时", "触摸位置是否位于", "锁上", "checkTouch({x,", "y})", "{", "for", "(let", "i", "=", "0;", "i", "<", "this.circleArray.length;", "i++)", "{", "let", "point", "=", "this.circleArray[i];", "if", "(this.isPointInCycle(x,", "y,", "point.x,", "point.y,", "point.radius))", "{", "if", "(!point.check)", "{", "this.checkPoints.push(point.count);", "if", "(this.lastCheckPoint", "!=", "0)", "{", "//", "已激活锁之间的线段", "const", "line", "=", "this.drawLine(this.lastCheckPoint,", "point);", "this.lineArray.push(line);", "}", "this.lastCheckPoint", "=", "point;", "}", "point.check", "=", "true;", "return;", "}", "}", "}当手指按下的时候，首先需要获取到", "容器的", "offset，然后检查当前手指的位置是否位于", "锁圆", "内部，如果位于内部的化将这个锁变为已激活状态，并压入激活锁数组。(3).", "onTouchMoveonTouchMove(e)", "{", "this.moveDraw(e)", "}//", "移动", "绘制", "moveDraw(e)", "{", "//", "画经过的圆", "const", "x", "=", "e.pageX", "-", "this.offsetX;", "const", "y", "=", "e.pageY", "-", "this.offsetY;", "this.checkTouch({x,", "y});", "//", "画", "最后一个激活的锁与当前位置之间的线段", "this.activeLine", "=", "this.drawLine(this.lastCheckPoint,", "{x,", "y});", "}当手指在按下并移动的时候，实时检查当前手指的位置是否在未激活的锁上，如果位于未激活的锁上，则将其激活并压入激活锁数组，并按顺序绘制激活锁之间的连线。除此之外还需要绘制上一个激活锁到当前手指位置的连线。(4).onTouchEndonTouchEnd(e)", "{", "const", "checkPoints", "=", "this.checkPoints;", "this.reset();", "return", "checkPoints;", "}手指放开的时候", "清空全部状态作者：Madokami", "链接：https://www.jianshu.com/p/c7bd3a9486c5"]}
{"author": "Rolan", "title": "小程序中打开网页和pdf ", "content": ["打开网页的方法有两种第一种是最简单的微信官方提供的方法，直接把要打开的网页地址赋给web-view标签的src属性", "<web-view", "src=\"{{article}}\">", "</web-view>第二种需要引入一个第三方插件，下面的写法只适用于wepy框架中，其他框架中写法略有不同。<template><view>", "//插件中的固定写法", "<import", "src=\"../../wxParse/wxParse.wxml\"", "/>", "<template", "is=\"wxParse\"", "data=\"{{wxParseData:article.nodes}}\"", "/>", "<view", "wx:if='article'", "class='addclass'></view></view></template><script>//引入插件import", "WxParse", "from", "\"../../wxParse/wxParse\";export", "default", "class", "webview", "extends", "wepy.page", "{", "data", "=", "{", "//网页地址路径", "article:", "'',", "}", "methods", "=", "{", "}", "async", "onLoad(options)", "{", "let", "ret", "=", "await", "api.rentalContracts({", "id:", "this.id,", "method:", "'GET'", "});", "this.article", "=", "ret.data", "//调用插件中的方法设置article中的网页路径", "WxParse.wxParse('article',", "'html',", "this.article,", "this,", "1);", "}}打开phf文件给按钮定义一个preview方法，在downloadFile方法中调用wx.openDocument方法就可以实现。", "preview()", "{", "let", "that=this.", "wx.downloadFile({", "url:", "'https://www.*******.com/contract/default/pdf',", "success:", "function(res)", "{", "console.log(res)", "var", "Path", "=", "res.tempFilePath", "//返回的文件临时地址，用于后面打开本地预览所用", "that.webview=Path", "wx.openDocument({", "filePath:", "Path,", "success:", "function(res)", "{", "console.log('打开文档成功')", "}", "})", "},", "fail:", "function(res)", "{", "console.log(res)", "}", "})", "},作者：王炳祺", "链接：https://www.jianshu.com/p/098fd010d88b"]}
{"author": "Rolan", "title": "小程序手写签名（wepy） ", "content": ["对于手写签名组件组件晚上有很多种写法，我选择了一种进行了wepy的框架的改造。如果使用wepy框架做手写签名的话可以直接复制下面的代码。这里需要提醒的是：安卓手机和苹果手机有适配性的问题，苹果手机在签名的以后手机将无法进行文档的上下左右的滑动，而安卓手机没有影响。解决这个问题的方法是给canvas给disable-scroll属性绑定一个变量", "disable-scroll=\"true\"", "当进行滑动的时候讲disable-scroll属性设置成true,滑动完成时将属性还原为false.", "<template>", "<view", "class='content'>", "<canvas", "class='firstCanvas'", "canvas-id=\"firstCanvas\"", "bindtouchmove='move'", "bindtouchstart='start'", "bindtouchend='end'", "bindtouchcancel='cancel'", "bindlongtap='tap'", "disable-scroll='true'", "binderror='error'>", "</canvas>", "<button", "bindtap='clearClick'>清除</button>", "<button", "bindtap='saveClick'>保存图片</button>", "<image", "id='signatureImg'", "src='{{signImage}}'></image></view></template><script>import", "wepy", "from", "'wepy';var", "content", "=", "null;var", "touchs", "=", "[];var", "canvasw", "=", "0;var", "canvash", "=", "0;export", "default", "class", "Index", "extends", "wepy.page", "{", "config", "=", "{};", "components", "=", "{};", "data", "=", "{", "signImage:", "'',", "};", "events", "=", "{};", "methods", "=", "{", "start:", "function(event)", "{", "//", "console.log(\"触摸开始\"", "+", "event.changedTouches[0].x)", "//", "console.log(\"触摸开始\"", "+", "event.changedTouches[0].y)", "//获取触摸开始的", "x,y", "let", "point", "=", "{", "x:", "event.changedTouches[0].x,", "y:", "event.changedTouches[0].y", "}", "touchs.push(point)", "},", "//", "画布的触摸移动手势响应", "move:", "function(e)", "{", "let", "point", "=", "{", "x:", "e.touches[0].x,", "y:", "e.touches[0].y", "}", "touchs.push(point)", "if", "(touchs.length", ">=", "2)", "{", "this.draw(touchs)", "}", "},", "//", "画布的触摸取消响应", "cancel:", "function(e)", "{", "console.log(\"触摸取消\"", "+", "e)", "},", "//", "画布的长按手势响应", "tap:", "function(e)", "{", "console.log(\"长按手势\"", "+", "e)", "},", "error:", "function(e)", "{", "console.log(\"画布触摸错误\"", "+", "e)", "},", "//", "画布的触摸移动结束手势响应", "end:", "function(e)", "{", "console.log(\"触摸结束\"", "+", "e)", "//清空轨迹数组", "for", "(let", "i", "=", "0;", "i", "<", "touchs.length;", "i++)", "{", "touchs.pop()", "}", "},", "};", "async", "onShow()", "{}", "async", "onLoad(options)", "{", "//获得Canvas的上下文", "content", "=", "wx.createCanvasContext('firstCanvas')", "//设置线的颜色", "content.setStrokeStyle(\"#00ff00\")", "//设置线的宽度", "content.setLineWidth(5)", "//设置线两端端点样式更加圆润", "content.setLineCap('round')", "//设置两条线连接处更加圆润", "content.setLineJoin('round')", "}", "draw(touchs)", "{", "let", "point1", "=", "touchs[0]", "let", "point2", "=", "touchs[1]", "touchs.shift()", "content.moveTo(point1.x,", "point1.y)", "content.lineTo(point2.x,", "point2.y)", "content.stroke()", "content.draw(true)", "}", "clearClick()", "{", "//清除画布", "content.clearRect(0,", "0,", "canvasw,", "canvash)", "content.draw(true)", "}", "saveClick()", "{", "var", "that", "=", "this", "wx.canvasToTempFilePath({", "canvasId:", "'firstCanvas',", "success:", "function(res)", "{", "//打印图片路径", "console.log(res.tempFilePath)", "//设置保存的图片", "that.setData({", "signImage:", "res.tempFilePath", "})", "}", "})", "}}</script><style>.content", "{", "width:", "100%;", "height:", "500px;", "background-color:", "red;}.firstCanvas", "{", "background-color:", "blue;", "width:", "100%;", "height:", "200px;}image", "{", "width:", "100%;", "height:", "200px;", "background-color:", "orange;}</style>作者：王炳祺", "链接：https://www.jianshu.com/p/952169f45871"]}
{"author": "Rolan", "title": "微信小程序：拼图游戏 ", "content": ["微信小程序：拼图游戏源代码：https://github.com/lcp1551/lcpISfat游戏界面初始化游戏：游戏成功：思路&功能：1.初始化，将数字1~8存放在数组中，随机打乱后拼接一个9(空白格),修改空白格的样式2.点击数字，判断空白格对于其所在位置的方向，进行相应的上下左右移动3.上下左右移动，及把移动的两个数字互换在数组中的位置4.判断数组中元素是否是[1,2,3,4,5,6,7,8,9]，是则游戏成功，5.计时，利用定时器，结束，清除定时器代码：项目中所用到的数据：data:", "{", "num:", "['★',", "'★',", "'★',", "'★',", "'★',", "'★',", "'★',", "'★',", "'★'],", "//初始化前", "hidden:", "true,", "//隐藏空白格中的数字", "time:0,", "//秒数", "t:''", "//定时器", "},复制代码构建页面：index.wxml<view", "class=\"container\">", "<view", "class=\"row\"", "wx:for=\"{{num}}\"", "wx:for-item=\"item\"", "wx:for-index=\"index\">", "<button", "class=\"btn", "{{item", "==", "9?'active':''}}\"", "catchtap='onMoveTap'", "data-item=\"{{item}}\"", "data-index=\"{{index}}\">{{item}}</button>", "</view></view>复制代码需要传两个数据过去，一个是被点击块的下标index和块中的数字item动态为空白格[9]添加样式active{{item", "==", "9?'active':''}}复制代码游戏初始化：init:function(){", "this.setData({", "num:this.sortArr([1,2,3,4,5,6,7,8]).concat([9])", "})", "},复制代码初始化的时候，这里用了sortArr(arr)打乱数组，并拼接个空白格[9]，这样让空白格初始化的时候永远处于最后一位。随机打乱数组:sortArr:", "function", "(arr)", "{", "return", "arr.sort(function", "()", "{", "return", "Math.random()", "-", "0.5", "})", "}复制代码这里用了最简单的打乱方法，缺点就是打乱不完全给每个块添加点击事件onMoveTap:onMoveTap:", "function", "(e)", "{", "var", "index", "=", "e.currentTarget.dataset.index;", "var", "item", "=", "e.currentTarget.dataset.item;", "if", "(this.data.num[index", "+", "3]", "==", "9)", "{", "this.down(e);", "}", "if", "(this.data.num[index", "-", "3]", "==", "9)", "{", "this.up(e);", "}", "if", "(this.data.num[index", "+", "1]", "==", "9", "&&", "index", "!=", "2", "&&", "index", "!=", "5)", "{", "this.right(e);", "}", "if", "(this.data.num[index", "-", "1]", "==", "9", "&&", "index", "!=", "3", "&", "index", "!=", "6)", "{", "this.left(e);", "}", "}复制代码如果空白格的下标比所点击的块的下表大3，则表示空白格在所点击块的下方，那么点击后向下移动；如果空白格的下标比所点击的块的下表小3，则表示空白格在所点击块的上方，那么点击后向上移动；如果空白格的下标比所点击的块的下表大1，则表示空白格在所点击块的右方，那么点击后向右移动，需考虑点击快是否在容器右边缘；如果空白格的下标比所点击的块的下表小1，则表示空白格在所点击块的左方，那么点击后向左移动，需考虑点击快是否在容器左边缘；移动：以向上移动举例", "up:", "function", "(e)", "{", "var", "index", "=", "e.currentTarget.dataset.index;", "//当前数字下标", "var", "temp", "=", "this.data.num[index];", "this.data.num[index]", "=", "this.data.num[index", "-", "3]", "this.data.num[index", "-", "3]", "=", "temp;", "this.setData({", "num:", "this.data.num", "})", "if", "(this.data.num.toString()", "==", "[1,", "2,", "3,", "4,", "5,", "6,", "7,", "8,", "9].toString())", "{", "this.success();", "}", "}复制代码移动后，将所点击块与空白格互换在数组中的位置，并判断目前的数组是否满足游戏成功的条件，判断数组相等，我这里把数组转化成字符串做的比较游戏成功：success:", "function", "()", "{", "var", "that", "=", "this;", "wx.showToast({", "title:", "'闯关成功',", "icon:", "'success',", "success:", "function", "()", "{", "that.init();", "}", "})", "}复制代码游戏成功，弹出交互反馈窗口，并初始化重新打乱数组定时器：", "timeCount:function(){", "var", "that", "=", "this;", "var", "timer", "=", "that.data.time;", "that.setData({", "t:setInterval(function(){", "timer++;", "that.setData({", "time:timer", "})", "},1000)", "})", "}复制代码开始结束游戏：", "timeBegin:function(){", "clearInterval(this.data.t);", "this.setData({", "time:0", "})", "this.timeCount();", "this.init();", "},", "timeStop:function(){", "clearInterval(this.data.t);", "if", "(this.data.num.toString()", "!=", "[1,", "2,", "3,", "4,", "5,", "6,", "7,", "8,", "9].toString())", "{", "this.fail();", "}", "}复制代码给开始按钮绑定timeBegin事件，初始化游戏给结束按钮绑定timeStop事件，判断是否游戏成功试玩:源代码：github.com/lcp1551/lcp…待开发：选择难度自传图片"]}
{"author": "Rolan", "title": "撸个微信小程序的省市区选择器 ", "content": ["微信小程序虽然已经有现成的封装好的省市区选择器给开发者使用，然鹅不幸的是，微信地址库的数据和公司用的地址库数据很难一一对上，那就只能撸起袖子自己写个组件了。最终效果思维导图主要代码组件", "region-picker.js/*", "region-picker.js", "*/", "import", "area", "from", "'本地", "json", "数据';", "Component({", "properties:", "{", "showRegion:", "{", "type:", "Boolean,", "observer:", "function(newVal,", "oldVal)", "{", "this.setData({", "dialog:", "newVal,", "});", "},", "},", "regionValue:", "{", "type:", "Array,", "value:", "[],", "observer:", "function(newVal,", "oldVal)", "{", "if", "(newVal.length", ">", "0)", "{", "let", "select", "=", "-1;", "for", "(let", "i", "=", "newVal.length", "-", "1;", "i", ">=", "0;", "i--)", "{", "if", "(newVal[i].id", "!==", "'')", "{", "select", "=", "i;", "break;", "}", "}", "//", "除最低级别区（select", "=", "2）以外，需要获取当前级别下一级的数据", "this.setData({", "['region.tabs']:", "newVal,", "['region.select']:", "select", "<", "2", "?", "select+1", ":", "select,", "},", "()", "=>", "{", "this.setData({", "area:", "this.getChildArea(select", "<", "2", "?", "select+1", ":", "select),", "});", "});", "}", "},", "},", "},", "data:", "{", "dialog:", "false,", "area:", "area,", "region:", "{", "tabs:", "[", "{", "name:", "'请选择',", "id:", "'',", "},", "{", "name:", "'请选择',", "id:", "'',", "},", "{", "name:", "'请选择',", "id:", "'',", "},", "],", "select:", "0,", "},", "},", "methods:", "{", "//", "关闭", "picker", "触发的方法", "emitHideRegion:", "function()", "{", "if", "(this.data.region.tabs[2].id", "===", "'')", "{", "wx.showToast({", "title:", "'请选择所在地',", "icon:", "'none',", "duration:", "2000,", "});", "return", "false;", "}", "let", "myEventDetail", "=", "{};", "//", "detail对象，提供给事件监听函数", "let", "myEventOption", "=", "{};", "//", "触发事件的选项", "this.setData({", "dialog:", "!this.data.dialog,", "});", "myEventDetail", "=", "{", "showRegion:", "this.data.dialog,", "regionValue:", "this.data.region.tabs,", "};", "this.triggerEvent('myevent',", "myEventDetail,", "myEventOption);", "},", "bindRegionChange:", "function(e)", "{", "//", "获取当前选中项的name和id并赋值给data中的数据", "let", "id", "='region.tabs['", "+", "this.data.region.select", "+", "'].id';", "let", "name", "='region.tabs['", "+", "this.data.region.select", "+", "'].name';", "this.setData({", "[id]:", "e.target.dataset.id,", "[name]:", "e.target.dataset.name,", "});", "//", "除了三级以外的需要获取对应子选项", "if", "(this.data.region.select", "<", "2)", "{", "this.setData({", "['region.select']:", "++this.data.region.select,", "},", "()", "=>", "{", "//", "获取子选项", "this.setData({", "area:", "this.getChildArea(this.data.region.select),", "});", "});", "}", "else", "{", "//", "三级选项选择完毕关闭省市区选择器", "this.emitHideRegion();", "}", "},", "getChildArea:", "function(level)", "{", "let", "_id", "=", "'';", "//", "默认取完整的数据", "let", "_area", "=", "area;", "//", "根据层级取当前层级下的数据", "for", "(let", "i", "=", "0;", "i", "<", "level;", "i++)", "{", "_id", "=", "this.data.region.tabs[i].id;", "for", "(let", "j", "=", "0;", "j", "<", "_area.length;", "j++)", "{", "if", "(_area[j].id", "===", "_id)", "{", "_area", "=", "_area[j]._child;", "break;", "}", "}", "}", "return", "_area;", "},", "//", "省市区tab切换", "changeRegionLevel:", "function(e)", "{", "let", "level", "=", "e.target.dataset.level;", "//", "三级选项的tab点击无效果", "if", "(level", "===", "2)", "return", "false;", "//", "当前选中tab和级别小于当前选中tab的状态都置为初始化状态", "for", "(let", "i", "=", "level;", "i", "<", "3;", "i++)", "{", "let", "string", "=", "'region.tabs['+", "i", "+']';", "this.setData({", "[string]:", "{", "name:", "'请选择',", "id:", "'',", "},", "});", "}", "this.setData({", "['region.select']:", "level,", "});", "this.setData({", "area:", "this.getChildArea(level),", "});", "},", "},", "});", "复制代码组件", "region-picker.wxml/*", "region-picker.wxml", "*/", "<view", "class=\"free-dialog", "{{dialog", "?", "'free-dialog--show'", ":", "''}}\">", "<view", "class=\"free-dialog__mask\"", "bindtap=\"emitHideRegion\"></view>", "<view", "class=\"free-dialog__container\">", "<view", "class=\"free-dialog__container__header\">", "<view>选择所在地区</view>", "<image", "src=\"自行替换36rpx*36rpx的x图标\"", "class=\"close\"", "bindtap=\"emitHideRegion\">", "</image>", "</view>", "<view", "class=\"free-dialog__container__content\">", "<view", "class=\"free-content", "{{isIphoneX", "?", "'ipx'", ":", "''}}\">", "<view", "class=\"free-content__tabs\">", "<view", "class=\"free-content__tabs__tab", "{{region.select", "===", "index", "?", "'select'", ":", "''}}\"", "wx:for=\"{{region.tabs}}\"", "wx:key=\"{{index}}\"", "wx:if=\"{{index", "<=", "region.select}}\"", "data-level=\"{{index}}\"", "bindtap=\"changeRegionLevel\">", "{{item.name}}", "</view>", "</view>", "<scroll-view", "scroll-y", "class=\"free-content__scroll\">", "<view", "class=\"free-content__scroll__item\"", "wx:for=\"{{area}}\"", "wx:key=\"id\"", "data-id=\"{{item.id}}\"", "data-name=\"{{item.name}}\"", "bindtap=\"bindRegionChange\">", "{{item.name}}", "</view>", "</scroll-view>", "</view>", "</view>", "</view>", "</view>", "复制代码组件", "region-picker.wxss/*", "region-picker.wxss", "*/", ".free-dialog__mask", "{", "position:", "fixed;", "top:", "0;", "left:", "0;", "right:", "0;", "bottom:", "0;", "z-index:", "10;", "background:", "rgba(0,", "0,", "0,", "0.7);", "display:", "none;", "}", ".free-dialog__container", "{", "position:", "fixed;", "left:", "0;", "bottom:", "0;", "width:", "100%;", "background:", "#F1F1F1;", "transform:", "translateY(150%);", "transition:", "all", "0.4s", "ease;", "z-index:", "11;", "}", ".free-dialog--show", ".free-dialog__container", "{", "transform:", "translateY(0);", "}", ".free-dialog--show", ".free-dialog__mask", "{", "display:", "block;", "}", ".free-dialog__container__header", "{", "padding:", "24rpx", "30rpx;", "text-align:", "center;", "background:", "white;", "}", ".free-dialog__container__header", ".close", "{", "position:absolute;", "right:30rpx;", "top:31rpx;", "width:36rpx;", "height:36rpx;", "}", ".free-content", "{", "background:", "white;", "border-bottom:", "40rpx", "solid", "white;", "}", ".free-content.ipx", "{", "border-bottom:", "72rpx", "solid", "white;", "}", ".free-content__tabs__tab", "{", "display:", "inline-block;", "padding:", "12rpx", "46rpx;", "font-size:", "32rpx;", "color:", "#333;", "border-bottom:", "4rpx", "solid", "white;", "}", ".free-content__tabs__tab.select", "{", "border-color:", "#FA263C;", "}", ".free-content__scroll", "{", "padding:", "0", "40rpx;", "height:", "480rpx;", "box-sizing:", "border-box;", "}", ".free-content__scroll__item", "{", "margin-top:", "40rpx;", "height:", "40rpx;", "line-height:", "40rpx;", "font-size:", "28rpx;", "color:", "#333;", "}", "复制代码页面的", "WXML/*", "页面的", "WXML", "*/", "<view", "bindtap=\"chooseRegion\">请选择</view>", "<view>", "<text", "wx:if=\"{{regionValue[0].id}}\">{{regionValue[0].name}}</text>", "<text", "wx:if=\"{{regionValue[1].id}}\">{{regionValue[1].name}}</text>", "<text", "wx:if=\"{{regionValue[2].id}}\">{{regionValue[2].name}}</text>", "</view>", "...", "<region-picker", "region-value=\"{{regionValue}}\"", "show-region=\"{{showRegion}}\"", "bind:myevent=\"emitHideRegion\">", "</region-picker>", "复制代码页面的", "js/*", "页面的", "js", "*/", "Page({", "data:", "{", "regionValue:", "[],", "showRegion:", "false,", "},", "chooseRegion:", "function()", "{", "this.setData({", "showRegion:", "true,", "});", "},", "emitHideRegion:", "function(e)", "{", "this.setData({", "showRegion:", "e.detail.showRegion,", "regionValue:", "e.detail.regionValue,", "});", "},", "});", "复制代码总结需要注意下的是，最低级别区级别是个特殊的临界点，因为区后面没有更低级别，所以不需要获取下一级别的数据，也不能触发", "tab", "事件。然后父组件传递子自组件的值，如果后期父组件变更了这个值，子组件可以在响应函数", "observer", "里监听到值的变化。我本次使用的本地省市区", "JSON", "数据格式为：/*", "area.js", "*/", "module.exports", "=", "[{", "id:", "'...',", "name:", "'...',", "_child:", "[{", "id:", "'...',", "name:", "'...',", "_child:", "[{", "id:", "'...',", "name:", "'...'", "},", "...]", "},", "...]", "},", "...]", "复制代码写的不是特别好，也希望能帮助到有需要的人吧，有疑问戳微信小程序官方文档，没有什么比官方文档更靠谱的了！作者：", "掘金5025原文：https://juejin.im/post/5b7520966fb9a0099744a96f"]}
{"author": "Rolan", "title": "简易微信小程序签到功能 ", "content": ["一、效果图", "点击签到后二、数据库", "用一张数据表存用户签到的信息，每次用户签到都会往表中添加一条记录了用户id和签到日期的数据，如下图三、后端", "后端写两个接口，一个用于查询用户今日是否签到和签到记录总数，一个用于添加用户签到信息到数据库。这里用的是python的flask框架。", "（1）查询用户签到信息接口：@app.route('/get_sign/<user_id>')def", "get_sign(user_id):", "try:", "data=get_sign_info(user_id)", "except", "Exception", "as", "e:", "return", "jsonify({'status':0,'Exception':str(e)})", "return", "jsonify({'status':1,'data':data})def", "get_sign_info(user_id):", "conn", "=", "sqlite3.connect('test.sqlite')", "cursor", "=", "conn.cursor()", "cursor.execute('select", "date", "from", "sign", "where", "user_id=?',(user_id,))", "all_date=set([x[0]", "for", "x", "in", "cursor.fetchall()])", "now_date=date.today().strftime('%Y-%m-%d')//将日期字符串化", "if", "now_date", "in", "all_date:", "signed=True", "else:", "signed=False", "total=len(all_date)", "conn.close()", "return", "{'total':total,'signed':signed}", "查询到所有签到日期后用set去除重复项，然后判断一下当天的日期是否在其中，如果不在其中，signed=False表示今日未签到。签到总数就是all_date的长度", "使用了datetime库来获取日期信息。from", "datetime", "import", "date（2）添加用户签到信息接口：@app.route('/sign/<user_id>')def", "sign(user_id):", "try:", "update_sign(user_id)", "except", "Exception", "as", "e:", "return", "jsonify({'status':0,'Exception':str(e)})", "return", "jsonify({'status':1})def", "update_sign(user_id):", "now_date=date.today().strftime('%Y-%m-%d')", "conn", "=", "sqlite3.connect('test.sqlite')", "cursor", "=", "conn.cursor()", "cursor.execute('insert", "into", "sign", "(user_id,date)", "values(?,?)',\\", "(user_id,now_date))", "conn.commit()", "conn.close()小程序前端\"", "style=\"margin:", "35px", "0px", "20px;", "font-family:", "\"PingFang", "SC\",", "\"Hiragino", "Sans", "GB\",", "\"Helvetica", "Neue\",", "\"Microsoft", "Yahei\",", "\"WenQuanYi", "Micro", "Hei\",", "sans-serif;", "font-weight:", "500;", "line-height:", "40px;", "color:", "rgb(44,", "62,", "80);", "text-rendering:", "optimizeLegibility;", "font-size:", "26px;", "background-color:", "rgb(249,", "249,", "245);\">四、小程序前端wxml文件", "<view", "class=\"sign\"", "wx:if=\"{{isLogin", "==", "true}}\">", "<image", "class=\"image\"", "src='../../dist/images/sign.png'></image>", "<view", "class=\"sign_info\">", "<view", "wx:if=\"{{signed==false}}\"", "bindtap='sign'>点击此处签到</view>", "<view", "wx:if=\"{{signed==true}}\">今日已签到</view>", "<view>已签到{{total_sign}}天</view>", "</view>", "</view>wxss文件.image{", "float:left;", "width:", "140rpx;", "height:", "140rpx;", "margin-right:", "7%;", "margin-left:20%;}.sign{", "margin-top:", "10%;}.sign_info{", "width:", "100%;", "color:", "#666;", "font-size:", "43rpx;}js文件", "get_sign:", "function(){", "var", "that", "=", "this;", "var", "userId", "=", "wx.getStorageSync(\"userId\");", "wx.request({", "url:", "'http://服务器公网ip:80/get_sign/'+userId,", "method:", "\"GET\",", "success:", "function", "(res)", "{", "if", "(res.data.status", "==", "1)", "{", "that.setData({", "total_sign:", "res.data.data.total,", "signed:", "res.data.data.signed,", "})", "}", "else{", "console.log(\"status", "error:", "\"", "+", "res.data.Exception)", "}", "},", "})", "},", "sign:function(){", "var", "that", "=", "this;", "var", "userId", "=", "wx.getStorageSync(\"userId\");", "wx.request({", "url:", "'http://服务器公网ip:80/sign/'", "+", "userId,", "method:", "\"GET\",", "success:", "function", "(res)", "{", "if", "(res.data.status", "==", "1)", "{", "that.setData({", "total_sign:", "that.data.total_sign+1,", "signed:", "true,", "})", "wx.showToast({", "title:", "'成功',", "icon:", "'success',", "duration:", "2000", "})", "}", "else", "{", "console.log(\"status", "error:", "\"", "+", "res.data.Exception)", "}", "},", "})", "},", "用户登录后，会立即触发get_sign函数，从数据库获取用户签到信息存到page的data中，页面也会显示用户今日是否签到和签到总数。", "用户点击签到后，会保存签到信息，并更新data。用showToast弹窗提示签到成功。作者：luozx207地址：http://www.cnblogs.com/luozx207/p/9525042.html"]}
{"author": "Rolan", "title": "你还在发愁小程序自定义导航栏吗？ ", "content": ["先说一下我的需求吧，因为我们的小程序是嵌套了webview。", "点击webview里面的项目，点的层级太深，用户后退很麻烦。然后pm又找了一个自定义的导航的小程序，发现别人可以，然后我就开始研究。小程序自定义导航栏开发注意点与参考文档微信官方设计指导中关于胶囊按钮的描述", "由此推测胶囊宽度87pt=116px，设置之后，的确能产生较好的兼容性效果[2018-07-06]根据测试截图发现微信胶囊宽度应该在96px左右，还有待研究社区相关Q&A：自定义标题栏高度计算使用时注意方法与属性版本兼容性完善之路：开一个项目采集设备的screenHeight,windowHeight,pixelRatio等信息到一个数据库中微信提供这样一个数据库便于计算，或者微信优化自定义标题栏（譬如通知栏可以改变颜色但不要算在自定义范围内，给出胶囊宽高到通知栏距离到右侧屏幕边框距离等相关参数）非自定义导航栏高度怎么计算？wx.getSystemInfo", "和", "wx.getSystemInfoSync", "获取机器信息screenHeight", "-", "windowHeight", "计算标题栏高度标题栏高度'iPhone':", "64,'iPhone", "X':", "88,'android':", "68——", "不完全统计（ip6", ",", "ip5", ",", "ip6p", ",", "ipx", ",", "小米mix2", ",", "小米5等综合了开发工具提供的数据和真机数据）所得有了这些从网上找到的资料，还有名叫猫圈的小程序的例子。开始代码实现了。配置\"window\":", "{", "\"navigationBarBackgroundColor\":", "\"#fff\",", "\"navigationBarTextStyle\":", "\"black\",", "\"backgroundColor\":", "\"#fff\",", "\"navigationStyle\":", "\"custom\"", "},复制代码这里navigationStyle", "配置修改之后就只剩一个胶囊按钮，也就意味着所有页面的导航都的自定义实现，你可以选择模版或者组件来开发，这里我是选择用的组件开发。然后定义导航的各个数值，我是在app。js", "里面定义的title_height:", "\"64\",", "statusbarHeight:", "\"24\",", "titleIcon_height:", "\"32\",", "titleIcon_width:", "\"87\",", "title_top:", "\"24\",", "title_text:", "\"xxx\",", "//", "iphone", "X", "+", "24", "prefix:", "24", "复制代码组件wxml的代码<view>", "<view", "class=\"title\"", "style=\"height:{{title_height}}px;padding-top:{{statusbarHeight}}px;background-color:{{isIndex?'#175dc6':'#fff'}}\">", "<view", "class=\"title_text\"", "style=\"color:{{isIndex?'#fff':'#000'}}\">{{title_text}}</view>", "<view", "wx:if=\"{{isShow}}\"", "class=\"title_icon\"", "style=\"top:{{title_top}}px;height:{{titleIcon_height}}px;width:{{titleIcon_width}}px;background-color:{{isIndex?'#175dc6':'#fff'}}\">", "<image", "bindtap=\"_goBack\"", "class=\"floatL\"", "src=\"/img/fanhui_icon.png\"></image>", "<view", "class=\"floatL\"></view>", "<image", "bindtap=\"_goHome\"", "src=\"/img/home_icon.png\"></image>", "</view>", "</view>", "<view", "style='height:{{title_height}}px;'></view>", "</view>复制代码wxss的代码.title", "{", "width:", "100%;", "background-color:", "#175dc6;", "box-sizing:", "border-box;", "position:", "fixed;", "transform:", "translateZ(0);", "z-index:", "999990;}", ".title_text", "{", "text-align:", "center;", "font-size:", "37rpx;", "color:", "#fff;", "line-height:", "44px;}", ".title_icon", "{", "background-color:", "#175dc6;", "position:", "fixed;", "top:", "54rpx;", "left:", "16rpx;", "border-radius:", "64rpx;", "box-sizing:", "border-box;", "border:", "0.5px", "solid", "#ebe48e;", "display:", "flex;}", ".title_icon", "image", "{", "height:", "20px;", "width:", "20px;", "padding-top:", "5px;", "display:", "inline-block;", "overflow:", "hidden;}", ".title_icon", "view", "{", "height:", "18px;", "border-left:", "1px", "solid", "#bfb973;", "margin-top:", "6px;}", ".floatL", "{", "float:", "left;}", ".title_icon", "image:nth-of-type(1),", ".title_icon", "image:nth-of-type(2)", "{", "padding-right:", "10px;", "padding-bottom:", "10px;", "padding-left:", "10px;}复制代码js的代码const", "app", "=", "getApp();", "Component({", "properties:", "{", "isShow:", "{", "//", "是否显示后退按钮", "type:", "String,", "value:", "\"1\"", "},", "isIndex:", "{", "//", "是否主页", "type:", "Boolean,", "value:", "false,", "},", "title_height:", "{", "//", "type:", "String,", "value:", "app.config.title_height,", "},", "titleIcon_height:", "{", "type:", "String,", "value:", "app.config.titleIcon_height,", "},", "titleIcon_width:", "{", "type:", "String,", "value:", "app.config.titleIcon_width,", "},", "statusbarHeight:", "{", "type:", "String,", "value:", "app.config.statusbarHeight,", "},", "title_top:", "{", "type:", "String,", "value:", "app.config.title_top,", "},", "title_text:", "{", "type:", "String,", "value:", "app.config.title_text,", "},", "},", "methods:", "{", "_goBack:", "function()", "{", "wx.navigateBack({", "delta:", "1", "});", "},", "_goHome:", "function()", "{", "wx.switchTab({", "url:", "\"/pages/index/index\"", "});", "}", "}", "})复制代码这样组件就写好了", "只需要在你每个页面里面用这个组件传不同的值就可以了。应用<header", "isIndex=\"true\"", "title_text=\"首页\"", "isShow=\"\"></header>", "在首页的wxml应用。", "json", "文件里面的配置", "\"navigationBarTitleText\":", "\"啦啦啦\",", "\"navigationBarBackgroundColor\":", "\"#175dc6\",", "\"usingComponents\":", "{", "\"header\":", "\"/components/layout/header/header\"", "}复制代码效果如图适配上可能会有点问题，希望大神有更好的解决方案，告诉我哟。一步步记录自己的踩坑历程~我要做到我技术不是最好的，但我给你总结的小程序的东西是最简单粗暴的哈哈哈我的博客:tada:", "送我一朵小发发～这个代码的排版我服了，懒得高了，我会发到博客上让大家看的。作者：", "Jiyr来源：https://juejin.im/post/5b7d5f5551882542e32a99c6"]}
{"author": "Rolan", "title": "制作todo list微信小程序 ", "content": ["今天给大家分享如何制作todo", "list微信小程序。资源视频", "-", "BiliBili，制作ToDo", "List微信小程序http://v.youku.com/v_show/id_XMzc5NjgwMDM5Ng==.html，", "YouTube源码地址", "-", "https://github.com/JKooll/sha...工具微信开发者工具", "v1.02微信小程序框架文档weui", "for", "小程序", "基础样式库过程打开微信开发工具，创建新项目导入weui", "for", "小程序", "基础样式库下载weui", "for", "小程序源码在项目中创建目录src/wxss/复制dist/style/weui.wxss文件到项目src/wxss/目录下在全局引入weui基础样式库打开app.wxss文件添加代码到开头@import", "'./src/wxss/weui.wxss';创建todo页面打开app.json在pages数组第一行中添加pages/todo/todo,保存文件添加tasks数据打开pages/todo/todo.js在data对象中添加tasks数据tasks每个元素包含三个字段：content:", "内容key:", "键status:", "true", "-", "完成状态，", "false", "-", "未完成状态渲染tasks列表打开pages/todo/todo.wxml清空文件添加如下代码到文件，", "保存文件<view", "class=\"page\">", "<view", "class=\"page__bd\">", "<view", "class=\"weui-cell\">", "<view", "class=\"weui-cell__bd\">", "<input", "class=\"weui-input\"", "placeholder=\"添加新任务\"/>", "</view>", "<view", "class=\"weui-cell__ft\">", "<button", "class=\"weui-btn\"", "type=\"primary\">添加</button>", "</view>", "</view>", "<view", "class=\"weui-cells__title\">待办事项</view>", "<view", "class=\"weui-cells", "weui-cells__after-title\">", "<radio-group>", "<block", "wx:for=\"{{tasks}}\"", "wx:key=\"value\"", "wx:if=\"{{!item.status}}\">", "<label", "class=\"weui-cell", "weui-check__label\">", "<radio", "class=\"weui-check\"", "value=\"{{item.value}}\"></radio>", "<view", "class=\"weui-cell__hd", "weui-check__hd_in-checkbox\">", "<icon", "class=\"weui-icon-checkbox_circle\"", "type=\"circle\"", "size=\"23\"", "wx:if=\"{{!item.checked}}\"></icon>", "</view>", "<view", "class=\"weui-cell__bd\">{{item.content}}</view>", "<view", "class=\"weui-cell__ft\"><button", "class=\"weui-btn\"", "type=\"warn\">删除</button></view>", "</label>", "</block>", "</radio-group>", "</view>", "<view", "class=\"weui-cells__title\">完成事项</view>", "<view", "class=\"weui-cells", "weui-cells__after-title\">", "<radio-group>", "<block", "wx:for=\"{{tasks}}\"", "wx:key=\"value\"", "wx:if=\"{{item.status}}\">", "<label", "class=\"weui-cell", "weui-check__label\">", "<radio", "class=\"weui-check\"", "value=\"{{item.value}}\"></radio>", "<view", "class=\"weui-cell__hd", "weui-check__hd_in-checkbox\">", "<icon", "class=\"weui-icon-checkbox_success\"", "type=\"success\"", "size=\"23\"></icon>", "</view>", "<view", "class=\"weui-cell__bd\">{{item.content}}</view>", "<view", "class=\"weui-cell__ft\"><button", "class=\"weui-btn\"", "type=\"warn\">删除</button></view>", "</label>", "</block>", "</radio-group>", "</view>", "</view>", "</view>改变task状态打开pages/todo/todo.wxml待办事项和完成事项下的label更改为<label", "class=\"weui-cell", "weui-check__label\"", "data-value=\"{{item.value}}\"", "bindtap=\"changeTaskStatus\">bindtap=\"changeTaskStatus\"", "绑定点击事件data-value=\"{{item.value}}\"", "将task的value值传递给changeTaskStatus函数打开pages/todo/todo.js,", "添加changeTaskStatus,", "保存文件查看效果changeTaskStatus:", "function", "(e)", "{", "let", "value", "=", "e.currentTarget.dataset.value;", "let", "tasks", "=", "this.data.tasks;", "let", "index", "=", "tasks.findIndex(task", "=>", "task.value", "==", "value);", "if", "(index", "<", "0)", "{", "return;", "}", "tasks[index].status", "=", "!tasks[index].status;", "this.setData({", "tasks:", "tasks", "});", "}删除task打开pages/todo/todo.wxml待办事项和完成事项下的button更改为button", "class=\"weui-btn\"", "type=\"warn\"", "data-value=\"{{item.value}}\"", "catchtap=\"removeTask\">删除</button>catchtap=\"removeTask\"", "绑定点击事件，和bindtap区别在于它阻止事件冒泡", "【更多】data-value=\"{{item.value}}\"", "将task的value值传递给removeTask函数打开pages/todo/todo.js,", "添加removeTask函数,", "保存文件查看效果添加task创建task打开pages/todo/todo.wxml将添加新任务下的input更改为<input", "class=\"weui-input\"", "placeholder=\"添加新任务\"", "bindinput=\"typeNewTask\"", "value=\"{{newTask}}\"/>bindinput=\"typeNewTask\"", "绑定input事件value=\"{{newTask}}\"", "绑定newTask到input", "valu，可以用来初始化input中的内容打开pages/todo/todo.js在data对象中添加两个新的变量,", "newTask:", "'',", "key:", "''newTask", "保存新的task的内容key", "保存下一个task", "value值添加typeNewTask，更新newTask变量的值typeNewTask:", "function(e)", "{", "this.setData({", "newTask:", "e.detail.value.trim()", "});", "},保存task打开pages/todo/todo.wxml将添加新任务下的button更改为<button", "class=\"weui-btn\"", "type=\"primary\"", "bindtap=\"addTask\"", "disabled=\"{{newTask", "==", "''}}\">添加</button>bindtap=\"addTask\"", "绑定点击事件disabled=\"{{newTask", "==", "''}}\"", "当newTask为空时，禁用button打开pages/todo/todo.js清空data中tasks变量的内容，", "tasks:", "[]添加addTask函数，保存文件查看效果addTask:", "function", "()", "{", "let", "tasks", "=", "this.data.tasks;", "let", "key", "=", "this.data.key;", "let", "newTaskObj", "=", "{", "content:", "this.data.newTask,", "value:", "key++,", "status:", "false", "};", "tasks.push(newTaskObj);", "this.setData({", "tasks:", "tasks,", "key:", "key,", "newTask:", "''", "});", "},完成作者：jkol原文：https://segmentfault.com/a/1190000016151643"]}
{"author": "Rolan", "title": "小程序绘图工具painter-json文件绘制保存分享图-可点击任意元素触发函数 ... ... ", "content": ["Painter是由酷家乐移动前端团队打造的一款小程序绘图组件。", "原项目地址：github.com/Kujiale-Mob…", "新版地址：github.com/shesw/Paint…", "这款交互版原来是为了针对业务中的新需求而由我自己开发的，后来需求改动，所以并没有用上。组里大佬考虑种种原因（主要是项目没用上，=0=～～），让我先在自己的github上开源。这版painter与原版的区别在于：", "添加了交互事件。Painter本质是以canvas为基础的，小程序的canvas有许多限制。允许canvas上元素的交互点击事件，可以实现更为便捷的功能，比如原来需要在canvas上添加功能按钮，现在可以直接画在canvas上", "添加拖拽元素的功能。目前这个功能没有完善好，因为它的滑动动作会与小程序的全屏滑动事件冲突，因此，拖拽功能在固定的页面上效果才好，如在拖拽时设置overflow:", "hidden等。", "这里将新版的Painter称为dancing-painter。引入方式请参考readme和demo。", "演示：", "主要功能：", "指原版的painter的功能。这些功能依然是本项目的主(实)要(用)功能。", "简介：", "原版的使用简介请参见", "juejin.im/post/5b40b1…", "简单来讲，使用过程如下图所示，可以结合demo来看：", "距离首次开源Painter库已经有一段时间了，这期间获益于各路道友的帮助和提点，Painter进行了几波更新（原项目地址)：", "新增特性：", "增加align属性，可以使任意元素可以实现左中右对齐。", "加入文字换行的能力。对一段文字设置width或者maxLines，都有可能触发文字的换行。", "添加文字的一些属性：fontWeight,", "textDecoration,", "textStyel(fill,", "stroke),", "maxLines,", "lineHeight", "图片mode属性，实现图片裁剪、缩放，默认为aspectFill", "图片不设置width,", "heighti属性，使用默认宽高", "left,", "right,", "top,", "bottom对负数的支持", "修复问题：", "某些机型上切边会出现黑线。", "安卓机型上圆角无法显示", "使用文件前检查文件是否正常", "二维码大小显示异常", "交互功能：", "这一版的特色主要是具备元素的点击事件实现以及拖拽功能，做出来以后因为项目上暂时用不上，所以感觉功能上可能比较鸡肋。不过还蛮好玩的"]}
{"author": "Rolan", "title": "微信支付服务商接入指引 ", "content": ["微信支付服务商接入指引本文主要针对服务商下特约商户的小程序支付进行讲解。（扫码支付，", "h5支付大致流程都差不多，了解了小程序支付能够很快接入其他支付类型）说明：本文中的支付都是指在服务商模式下支付主体服务商:拥有支付开发能力的第三方提供商普通商户:", "拥有开发能力的商户特约商户:服务商下的商户一个商家主体可以在不同服务商下申请特约商户，每个服务商都会给商家主体在此服务商下一个特约商户号。普通商户申请需要花费大约300RMB，服务商申请特约商户不需要费用。一个商家主体可以申请", "普通商户，特约商户。同一个商户主体申请的普通商户与在服务商下申请的特约商户号是独立的。服务商服务商下的特约商户的资金流转不会直接经过服务商的支付账户，最终消费者的资金直接和服务商下的特约商户进行来往，但是服务商可以查看自己下的特约商户资金流水。服务商小程序开发文档开发支付开发之前申请注册服务商，通过之后登录微信商户平台,进入菜单:", "服务商功能", "-->", "特约商户管理", "-->新增商户（也就是申请服务商下的特约商户）申请如果没有问题会在三到五天通过，之后可以在特约商户管理下看到服务商自己的特约商户，我们在开发中需要", "服务商商户号及这里的商户号（特约商户号）支付需要接口:微信统一下单，及提供给微信的回调接口微信官方给的业务流程图：可以很清晰的理解业务流程走向。统一下单接口微信统一下单请求参数统一下单请求参数封装为我们可以处理的对象：此处我的命名是：", "WechatUnifiedorderRequest以下是我开发中遇到一些坑，主要是由于微信官方的文档给的参数很模糊，特别是小程序支付。在填充好了WechatUnifiedorderRequest对象后对我们填充的值按照字典排序，连接key进行签名，以xml格式字符向微信发起请求我们需要对对象按照字典序排序第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。字典排序后的字符连接key（需要在微信商户平台进行配置建议使用UUID生成32位）MD5加密签名，得到sign填充WechatUnifiedorderRequest对象WechatUnifiedorderRequest转换为微信需要的xml类型发起请求得到微信统一下单的响应（是xml字符格式),解析为对象（对返回的响应封装对象进行处理WechatUnifiedorderResponse），对返回的对象进行验证，通过验证返回给小程序", "需要的参数及签名", "小程序调起支付API小程序支付成功，微信开始回调在统一下单传给微信的回调地址获取下单用户的真实IP", "/**", "*", "获取用户真实IP", "*", "如果有代理，获取真实客户端IP", "*", "@param", "request", "*", "@return", "*/", "public", "static", "String", "getRealId(HttpServletRequest", "request){", "String", "xForwardedForHeader=", "request.getHeader(\"X-Forwarded-For\");", "if(xForwardedForHeader", "==", "null){", "return", "request.getRemoteAddr();", "}else", "{", "return", "new", "StringTokenizer(xForwardedForHeader,", "\",\").nextToken().trim();", "}", "}按照字典序排序", "/**", "*", "使用java反射机制，动态获取对象的属性和参数值，排除值为null的情况，并按字典序排序", "*", "@param", "object", "*", "@return", "*/", "public", "static", "String", "getSortMap(Object", "object)", "throws", "Exception{", "//1.得到属性的名称及值", "如果为null不存入map", "Field", "[]", "fields", "=", "object.getClass().getDeclaredFields();", "Map<String,String>", "map", "=", "new", "HashMap<>();", "for(Field", "field", ":", "fields){", "String", "name", "=", "field.getName();", "/*String", "methodName", "=", "\"get\"+name.replaceFirst(name.substring(0,", "1),", "name.substring(0,", "1)", ".toUpperCase());*/", "//通过get方法直接获取属性值", "field.setAccessible(true);", "Object", "value", "=", "field.get(object);", "if", "(value", "!=", "null){", "map.put(name,", "value.toString());", "}", "}", "//排序", "Map<String,", "String>", "sortMap", "=", "new", "TreeMap<String,String>(", "new", "Comparator<String>()", "{", "@Override", "public", "int", "compare(String", "arg0,", "String", "arg1)", "{", "return", "arg0.compareTo(arg1);", "}", "});", "sortMap.putAll(map);", "StringBuilder", "sortFeil", "=", "new", "StringBuilder();", "//得到键值对的格式（即key1=value1&key2=value2…", "sortMap.forEach((k,v)->", "{", "sortFeil.append(k+\"=\"+v+\"&\");", "});", "//移除最后一个", "&", "sortFeil.deleteCharAt(sortFeil.length()-1);", "return", "sortFeil.toString();", "}", "使用字典序返回的字符连接key，使用MD5进行加密，得到signWechatUnifiedorderRequest转换为微信需要的xml类型在WechatUnifiedorderRequest对象上使用注解@xmlAccessorType", "@xmlAccessorType(XmlAccessType.FIELD)@xmlRootElement", "@xmlRootElement(name", "=\"xml\")", "(", "name", "=", "\"xml", ":", "\"WechatUnifiedorderReques对象转换为xml的根名称)/**", "*", "微信统一下单请求对象", "*", "*", "@Author", "xuelongjiang", "*/", "@XmlAccessorType(XmlAccessType.FIELD)", "@XmlRootElement(name", "=", "\"xml\")//xml的根元素", "public", "class", "WechatUnifiedorderRequest", "implements", "Serializable{", "}", "对象转换为xml字符引入包：import", "javax.xml.bind.JAXBContext", "/**", "*", "对象转换为xml", "*", "@param", "object", "*", "@return", "*/", "public", "static", "String", "objectToXml(Object", "object){", "StringWriter", "sw", "=", "new", "StringWriter();", "try", "{", "JAXBContext", "context", "=", "JAXBContext.newInstance(object.getClass());", "Marshaller", "marshaller", "=", "context.createMarshaller();", "marshaller.marshal(object,sw);", "}catch", "(Exception", "e){", "e.printStackTrace();", "logger.error(\"对象解析xml出现异常，对象为\"+object.toString());", "}", "return", "sw.toString();", "}得到微信统一下单的响应（是xml字符格式),解析为对象封装对象：WechatUnifiedorderResponse", "表示微信统一下单响应的对象。请求微信统一下单返回示例：<xml>", "<return_code><![CDATA[SUCCESS]]></return_code>", "<return_msg><![CDATA[OK]]></return_msg>", "<appid><![CDATA[wx2421b1c4370ec43b]]></appid>", "<sub_appid><![CDATA[wx2421b1c4370ec11b]]></sub_appid>", "<mch_id><![CDATA[10000100]]></mch_id>", "<sub_mch_id>![CDATA[10000101]]></appid>", "<nonce_str><![CDATA[IITRi8Iabbblz1Jc]]></nonce_str>", "<sign><![CDATA[7921E432F65EB8ED0CE9755F0E86D72F]]></sign>", "<result_code><![CDATA[SUCCESS]]></result_code>", "<prepay_id><![CDATA[wx201411101639507cbf6ffd8b0779950874]]></prepay_id>", "<trade_type><![CDATA[JSAPI]]></trade_type>", "</xml>参数值用XML转义即可，CDATA标签用于说明数据不被XML解析器解析，在转为对象的时候我们需要解析<![CDATA[]]>WechatUnifiedorderResponse对象使用注解@XmlAccessorType(XmlAccessType.FIELD)@XmlRootElement(name", "=", "\"xml\")//解析xml的根元素以上的和WechatUnifiedorderRequest是一样，但是由于需要解析<![CDATA[]]>，我们创建CDataAdapter继承XmlAdapter", "，使用注解@XmlJavaTypeAdapter来处理，在WechatUnifiedorderResponse需要处理<![CDATA[]]>的域上使用注解如下：", "@XmlJavaTypeAdapter(CDataAdapter.class)//", "解析<![CDATA[]]>", "private", "String", "return_code;", "//返回状态码CDataAdapter解析<![CDATA[]]>", "/**", "*", "*", "注解使用，", "对象与xml转换的字段需要有", "<![CDATA[]]>", "*", "*", "@Author", "xuelongjiang", "*/", "public", "class", "CDataAdapter", "extends", "XmlAdapter<String,String>", "{", "private", "static", "Logger", "logger", "=", "LoggerFactory.getLogger(CDataAdapter.class);", "/**", "*", "Do-nothing", "constructor", "for", "the", "derived", "classes.", "*/", "protected", "CDataAdapter()", "{", "super();", "}", "/**", "*", "Convert", "a", "value", "type", "to", "a", "bound", "type.", "*", "*", "@param", "v", "The", "value", "to", "be", "converted.", "Can", "be", "null.", "*", "@throws", "Exception", "if", "there's", "an", "error", "during", "the", "conversion.", "The", "caller", "is", "responsible", "for", "*", "reporting", "the", "error", "to", "the", "user", "through", "{@link", "ValidationEventHandler}.", "*/", "@Override", "public", "String", "unmarshal(String", "v)", "throws", "Exception", "{", "if(\"<![CDATA[]]>\".equals(v)){", "return", "\"\";", "}", "String", "v1", "=", "null;", "String", "v2", "=", "null;", "String", "subStart", "=", "\"<![CDATA[\";", "int", "a", "=", "v.indexOf(subStart);", "if(a>=", "0){", "v1", "=", "v.substring(subStart.length(),v.length());", "}else", "{", "return", "v;", "}", "String", "subEnd", "=", "\"]]>\";", "int", "b", "=", "v1.indexOf(subEnd);", "if(b>=", "0){", "v2", "=", "v1.substring(0,b);", "}", "return", "v2;", "}", "/**", "*", "Convert", "a", "bound", "type", "to", "a", "value", "type.", "*", "*", "@param", "v", "The", "value", "to", "be", "convereted.", "Can", "be", "null.", "*", "@throws", "Exception", "if", "there's", "an", "error", "during", "the", "conversion.", "The", "caller", "is", "responsible", "for", "*", "reporting", "the", "error", "to", "the", "user", "through", "{@link", "ValidationEventHandler}.", "*/", "@Override", "public", "String", "marshal(String", "v)", "throws", "Exception", "{", "logger.info(\"对象转换xml:\"+\"<![CDATA[\"+", "v", "+\"]]>\");", "return", "\"<![CDATA[\"+", "v", "+\"]]>\";", "}", "}", "到此为止，我们已经得到微信统一下单的响应值了，后续的处理不是很复杂。按照文档不会有很大的坑。在做微信支付的时候，难点是以上的：请求参数说明模糊，在经历几次的传参试验及百度谷歌之后，才明白了参数的具体的使用，其实后续在做扫码支付的时候，发现扫码支付解释的比较清楚，小程序的文档确实比较坑。参考文档：https://developers.weixin.qq....https://segmentfault.com/a/11...https://developers.weixin.qq...."]}
{"author": "Rolan", "title": "轻松生成小程序分享海报 ", "content": ["作者：jasondu原文：https://segmentfault.com/a/1190000016121303小程序海报组件https://github.com/jasondu/wx...需求小程序分享到朋友圈只能使用小程序码海报来实现，生成小程序码的方式有两种，一种是使用后端方式，一种是使用小程序自带的canvas生成；后端的方式开发难度大，由于生成图片耗用内存比较大对服务端也是不小的压力；所以使用小程序的canvas是一个不错的选择，但由于canvas水比较深，坑比较多，还有不同海报需要重现写渲染流程，导致代码冗余难以维护，加上不同设备版本的情况不一样，因此小程序海报生成组件的需求十分迫切。在实际开发中，我发现海报中的元素无非一下几种，只要实现这几种，就可以通过一份配置文件生成各种各样的海报了。海报中的元素分类要解决的问题单位问题canvas隐藏问题圆角矩形、圆角图片多段文字超长文字和多行文字缩略问题矩形包含文字多个元素间的层级问题图片尺寸和渲染尺寸不一致问题canvas转图片IOS", "6.6.7", "clip问题关于获取canvas实例单位问题canvas绘制使用的是px单位，但不同设备的px是需要换算的，所以在组件中统一使用rpx单位，这里就涉及到单位怎么换算问题。通过wx.getSystemInfoSync获取设备屏幕尺寸，从而得到比例，进而做转换，代码如下：const", "sysInfo", "=", "wx.getSystemInfoSync();", "const", "screenWidth", "=", "sysInfo.screenWidth;", "this.factor", "=", "screenWidth", "/", "750;", "//", "获取比例", "function", "toPx(rpx)", "{", "//", "rpx转px", "return", "rpx", "*", "this.factor;", "}", "function", "toRpx(px)", "{", "//", "px转rpx", "return", "px", "/", "this.factor;", "},canvas隐藏问题在绘制海报过程时，我们不想让用户看到canvas，所以我们必须把canvas隐藏起来，一开始想到的是使用display:none;", "但这样在转化成图片时会空白，所以这个是行不通的，所以只能控制canvas的绝对定位，将其移出可视界面，代码如下：.canvas.pro", "{", "position:", "absolute;", "bottom:", "0;", "left:", "-9999rpx;", "}圆角矩形、圆角图片由于canvas没有提供现成的圆角api，所以我们只能手工画啦，实际上圆角矩形就是由4条线（黄色）和4个圆弧（红色）组成的，如下：圆弧可以使用canvasContext.arcTo这个api实现，这个api的入参由两个控制点一个半径组成，对应上图的示例canvasContext.arcTo(x1,", "y1,", "x2,", "y2,", "r)接下来我们就可以非常轻松的写出生成圆角矩形的函数啦/**", "*", "画圆角矩形", "*/", "_drawRadiusRect(x,", "y,", "w,", "h,", "r)", "{", "const", "br", "=", "r", "/", "2;", "this.ctx.beginPath();", "this.ctx.moveTo(this.toPx(x", "+", "br),", "this.toPx(y));", "//", "移动到左上角的点", "this.ctx.lineTo(this.toPx(x", "+", "w", "-", "br),", "this.toPx(y));", "//", "画上边的线", "this.ctx.arcTo(this.toPx(x", "+", "w),", "this.toPx(y),", "this.toPx(x", "+", "w),", "this.toPx(y", "+", "br),", "this.toPx(br));", "//", "画右上角的弧", "this.ctx.lineTo(this.toPx(x", "+", "w),", "this.toPx(y", "+", "h", "-", "br));", "//", "画右边的线", "this.ctx.arcTo(this.toPx(x", "+", "w),", "this.toPx(y", "+", "h),", "this.toPx(x", "+", "w", "-", "br),", "this.toPx(y", "+", "h),", "this.toPx(br));", "//", "画右下角的弧", "this.ctx.lineTo(this.toPx(x", "+", "br),", "this.toPx(y", "+", "h));", "//", "画下边的线", "this.ctx.arcTo(this.toPx(x),", "this.toPx(y", "+", "h),", "this.toPx(x),", "this.toPx(y", "+", "h", "-", "br),", "this.toPx(br));", "//", "画左下角的弧", "this.ctx.lineTo(this.toPx(x),", "this.toPx(y", "+", "br));", "//", "画左边的线", "this.ctx.arcTo(this.toPx(x),", "this.toPx(y),", "this.toPx(x", "+", "br),", "this.toPx(y),", "this.toPx(br));", "//", "画左上角的弧", "}如果是", "画线框", "就使用", "this.ctx.stroke();如果是", "画色块", "就使用", "this.ctx.fill();如果是", "圆角图片", "就使用this.ctx.clip();", "this.ctx.drawImage(***);clip()", "方法从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用", "clip()", "方法前通过使用", "save()", "方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过", "restore()", "方法）。多段文字如果是连续多段不同格式的文字，如果让用户每段文字都指定坐标是不现实的，因为上一段文字的长度是不固定的，这里的解决方案是使用", "ctx.measureText", "（基础库", "1.9.90", "开始支持）Api来计算一段文字的宽度，记住这里返回宽度的单位是px（", "坑", "），从而知道下一段文字的坐标。超长文字和多行文字缩略问题设置文字的宽度，通过", "ctx.measureText", "知道文字的宽度，如果超出设定的宽度，超出部分使用“...”代替；对于多行文字，经测试发现字体的高度大约等于字体大小，并提供lineHeight参数让用户可以自定义行高，这样我们就可以知道下一行的y轴坐标了。矩形包含文字这个同样使用", "ctx.measureText", "接口，从而控制矩形的宽度，当然这里用户还可以设置paddingLeft和paddingRight字段；文字的垂直居中问题可以设置文字的基线对齐方式为middle（", "this.ctx.setTextBaseline('middle');", "），设置文字的坐标为矩形的中线就可以了；水平居中", "this.ctx.setTextAlign('center');", ";多个元素间的层级问题由于canvas没有Api可以设置绘制元素的层级，只能是根据后绘制层级高于前面绘制的方式，所以需要用户传入zIndex字段，利用数组排序（Array.prototype.sort）后再根据顺序绘制。图片尺寸和渲染尺寸不一致问题绘制图片我们使用", "ctx.drawImage()", "API；如果使用", "drawImage(dx,", "dy,", "dWidth,", "dHeight)", "，图片会压缩尺寸以适应绘制的尺寸，图片会变形，如下图：在基础库1.9.0起支持", "drawImage(sx,", "sy,", "sWidth,", "sHeight,", "dx,", "dy,", "dWidth,", "dHeight)", "，sx和sy是源图像的矩形选择框左上角的坐标，sWidth和sHeight是源图像的矩形选择框的宽度和高度，如下图：如果绘制尺寸比源图尺寸宽，那么绘制尺寸的宽度就等于源图宽度；反之，绘制尺寸比源图尺寸高，那么绘制尺寸的高度等于源图高度；我们可以通过", "wx.getImageInfo", "Api获取源图的尺寸；canvas转图片在canvas绘制完成后调用", "wx.canvasToTempFilePath", "Api将canvas转为图片输出，这样需要注意，", "wx.canvasToTempFilePath", "需要写在", "this.ctx.draw", "的回调中，并且在组件中使用这个接口需要在第二个入参传入this（", "坑", "），如下this.ctx.draw(false,", "()", "=>", "{", "wx.canvasToTempFilePath({", "canvasId:", "'canvasid',", "success:", "(res)", "=>", "{", "wx.hideLoading();", "this.triggerEvent('success',", "res.tempFilePath);", "},", "fail:", "(err)", "=>", "{", "wx.hideLoading();", "this.triggerEvent('fail',", "err);", "}", "},", "this);", "});IOS", "6.6.7", "clip问题在IOS", "6.6.7版本中clip方法连续裁剪图片时,只有第一张有效，这是微信的bug，官方也证实了（", "https://developers.weixin.qq....", "）关于获取canvas实例我们可以使用", "wx.createCanvasContext", "获取小程序实例，但在组件中使用切记第二个参数需要带上this，如下this.ctx", "=", "wx.createCanvasContext('canvasid',", "this);如何使用组件https://github.com/jasondu/wx..."]}
{"author": "Rolan", "title": "小程序 | 注释级微信小程序demo，助你快速切入开发 ", "content": ["写在前面", "小程序开发渐进红利期，更多开发者慕名而来，网上的学习资料也层出不穷，有点眼花缭乱的意思了。在经过一个多月的摸索式学习后，我也终于写了不算精美的一个小程序。", "那为什么写这篇文章：", "总结经验", "-", "写文章能带来更多的思考，为后续开发做准备", "分享经验", "-", "网上的资料真的太多了，希望我这篇文章能有所用", "几个问题", "适合哪些读者？", "本文适合对小程序有兴趣，且已阅读过官网：微信小程序开发教程，体验过官方demo，想进一步学习开发的读者", "包含哪些技术点？", "主要包括：微信小程序常见语法、跨页面传参、缓存使用、本地数据模拟、第三方UI库的使用、富文本转义、数据结构设计、后端数据请求、nodejs服务代理转发", "有何特点？", "思路、注释、源代码", "正文", "简介", "取了一个很low的名字“全民精进阅读”，意为沉浸式阅读体验，是一款rss源阅读小程序，主要功能包括：已关注源、源列表、源文章详情、源中心。可直接阅读知乎每日精选、the", "week等优质中英文源。", "使用起来效果是这样的：", "也可以直接微信扫码体验：", "灵感来源", "信息大爆炸时代，每天可看的实在太多，头条、公众号、知乎、各垂直平台、大佬博客......只想找一个“安静”的地方，便捷地阅读一些精选的东西。于是乎就想起了RSS，想着将其与小程序结合，抱着试一试的心态写了一下，顺便当做练习。", "模块分析（这个部分是废话，干货请直接查阅“代码实现”部分或者下载源码体验）", "有了目标，接下来就是具体构思了。", "最终需求为实现对RSS源的关注、展示。拆解为如下原子功能：", "RSS源关注", "RSS源已关注展示", "RSS源内容列表展示", "RSS源文章详细内容展示", "RSS源取消关注", "同时，为了能够选择到想关注的RSS源以及能有一个有效的反馈渠道和声明，还需两个个功能：", "RSS源推荐列表", "RSS源简介", "RSS源反馈渠道、声明展示", "针对上述功能，进行模块设计，这里推荐使用UE在线编辑应用墨刀来尝试完成。", "根据《Do", "not", "make", "me", "think》的原则，可以设计为如下5模块（页面）：", "已关注源展示", "RSS源已关注展示", "RSS源取消关注", "源中心", "RSS源推荐列表", "RSS源简介", "RSS源关注", "源内容展示", "RSS源内容列表展示", "源文章详细展示", "RSS源文章详细内容展示", "更多", "RSS源简介", "RSS源反馈渠道、声明展示", "各模块间的交互如下图（省略返回）：", "关于UI设计，作为前端开发首先能想到的就是宫格--简明扼要，很符合预期。所以就没有做专门的UI设计，在开发过程中“随机应变”。", "说了辣么多，该亮代码了。。。", "代码实现", "技术准备", "根据以上部分的分析，已经把小程序的所有功能点罗列出来了，现在做技术分析：", "整体而言，需要第三方UI库。经过搜索，发现两款不错的：一个是有赞的zanui，一个是美丽说的minui。因为我对该小程序的预期样式和zanui更接近，且zanui可以只引入部分模块，我选择了zanui。", "针对各功能点", "RSS源关注：带参数页面跳转、弹框（微信弹框展示信息太少，需用zanui）", "RSS源已关注展示：宫格布局、数据结构设计", "RSS源内容列表展示：RSS数据结构分析、布局", "RSS源文章详细内容展示：跨页面传参、富文本展示（微信没有标签，需第三方库来实现）", "RSS源取消关注：长按取消、数据缓存刷新", "RSS源推荐列表：宫格布局、数据结构设计", "RSS源简介：文本展示（注意微信中标签中的才能被选中复制）", "RSS源反馈渠道、声明展示：简单文本展示", "具体实现", "做好准备之后，就可以在微信开发者工具内开发了。", "首先，初始化项目后，修改创建出如下目录：", "├──", "app.js", "├──", "app.json", "├──", "app.wxss", "├──", "data", "本地数据", "|", "└──", "rss.js", "├──", "pages", "页面", "|", "├──", "detail", "源文章详细展示", "|", "|", "├──", "detail.js", "|", "|", "├──", "detail.json", "|", "|", "├──", "detail.wxml", "|", "|", "└──", "detail.wxss", "|", "├──", "index", "源内容展示", "|", "|", "├──", "index.js", "|", "|", "├──", "index.json", "|", "|", "├──", "index.wxml", "|", "|", "└──", "index.wxss", "|", "├──", "more", "更多", "|", "|", "├──", "more.js", "|", "|", "├──", "more.json", "|", "|", "├──", "more.wxml", "|", "|", "└──", "more.wxss", "|", "├──", "rsscenter", "源中心", "|", "|", "├──", "rsscenter.js", "|", "|", "├──", "rsscenter.json", "|", "|", "├──", "rsscenter.wxml", "|", "|", "└──", "rsscenter.wxss", "|", "└──", "rssed", "已关注源展示", "|", "├──", "rssed.js", "|", "├──", "rssed.json", "|", "├──", "rssed.wxml", "|", "└──", "rssed.wxss", "├──", "project.config.json", "├──", "utils", "通用资源", "|", "└──", "util.js", "└──", "wxParse", "富文本转义库", "复制代码页面一：rssed", "已关注源展示", "考虑到用户实际操作流，进入小程序后首先进入的就应该是已关注的源展示，新用户访问到的是空页面。用户可在页面操作触发添加关注、删除已关注。", "宫格布局与第三方UI库的使用", "对于已关注的源，关键信息是源名称、源logo。因此，基于清爽设计，采用宫格布局，这里使用的是zanui的栅格系统。从zanui的源码（本文使用的是v1.9.91版本）中找到栅格系统组件dist/col/index.wxss，将内容复制到项目的app.wxss中，当作通用样式，wxml参照zanui源码中的/pages/layout/index.wxml。", "栅格系统中对高度没有做控制，需要自行实现正方形方块，添加如下wxss代码：", ".zan-col", "{", "background-color:", "#39a9ed;", "height:", "25vw;", "text-align:", "center;", "padding-top:", "60rpx;", "color:", "#fff;", "position:", "relative;", "}", ".zan-col:nth-child(odd)", "{", "background-color:", "#66c6f2;", "}", "复制代码值得一提的是，第三方UI库的引入方式除了这种部分引入外，还可以整体引入，方法为：已zanui为例，将其资源文件通过@import直接引入到app.wxss中。", "@import", "\"dist/index.wxss\";", "复制代码", "数据结构设计", "对于这个已关注源的集合，我们将需要的元数据放入数组，用于宫格渲染。", "const", "rssedData", "=", "[", "{", "title:", "'知乎每日精选',", "//", "源名称", "favicon:", "'https://www.zhihu.com/favicon.ico',", "//", "源logo", "rssUrl:", "'https://www.zhihu.com/rss',", "//", "源链接", "},", "{", "title:", "'the", "weak',", "favicon:", "'https://theweek.com/favicon.ico',", "rssUrl:", "'https://theweek.com/rss.xml',", "},", "];", "复制代码此数据，加载该页面后从Storage中的取值rssedData，rssedData", "在已关注是写入缓存。", "3.", "渲染与取消关注", "根据数据结构和UI设计，使用wx:for循环渲染出宫格。", "由于需要查看、取消关注某个源，因此就需要在元素上添加data-rss-id等值，用于事件绑定与跨页面传参。", "删除采用常见的长按出现删除按钮，点击按钮就删除的方案。", "4.", "其他页的关联设计", "作为主页面，需要有访问其他功能也的入口，这里将工业入口放入宫格最后，作为关联。", "页面二：rsscenter", "源中心", "对于新用户而言，访问过已关注页面后，紧接着需要访问的就是源中心了。需要完成下面的功能：", "RSS源推荐列表展示与数据结构设计", "采用和已关注页相同的布局方式--宫格，样式复用，数据格式类似但需扩充。", "{", "title:", "'知乎每日精选',", "//", "源名称", "link:", "'https://www.zhihu.com',", "//", "源官网链接", "description:", "'中文互联网最大的知识平台，帮助人们便捷地分享彼此的知识、经验和见解。',", "//", "源简介", "favicon:", "'https://www.zhihu.com/favicon.ico',", "//", "源logo", "rssUrl:", "'https://www.zhihu.com/rss',", "//", "源链接", "}", "复制代码另外，对于关注的源应该有特殊标识，所以需要对数据做处理，通过对比Storage中rssedData和rss.js文件中的数据，给页面数据添加rssed（type：boolean）字段。", "这里的数据来源于网络收集，暂时固定写死在小程序中，因此我提出来放到了项目的/data/rss.js文件中。后续版本，这个放到服务端管理，可以做到动态增删改。", "2.", "RSS源简介", "采用弹出框的形式，展示基本信息，提供关注按钮。这里使用了zanui的popup组件，引入方式同栅格系统。", "3.", "RSS源关注", "更新Storage，使用wx.reLaunch跳转至已关注页。", "wx.reLaunch({", "url:", "`../rssed/rssed`,", "});", "复制代码页面三：源内容展示", "采用经典设计，如下图。", "源数据处理与node服务", "rss是基于XML标准的数据，在小程序中无法直接解析，且小程序的合法requests域名有限，这里可以采用服务器代理的形式来处理。", "我这里使用的是基于nodejs的thinkjs框架，在框架内引入专门将rss数据转为json数据的插件。这个服务后续可以专门写一篇文章，这里就不展开了，思路就是这样的。另外rss数据格式有多种，需要做兼容处理。", "响应格式为：", "{", "\"errno\":", "0,", "\"errmsg\":", "\"\",", "\"data\":", "{", "\"rss\":", "{", "\"$\":", "{", "\"version\":", "\"2.0\",", "\"xmlns:atom\":", "\"http://www.w3.org/2005/Atom\"", "},", "\"channel\":", "{", "\"title\":", "\"知乎每日精选\",", "\"link\":", "\"http://www.zhihu.com\",", "\"description\":", "\"中文互联网最大的知识平台，帮助人们便捷地分享彼此的知识、经验和见解。\",", "\"atom:link\":", "{", "\"$\":", "{", "\"href\":", "\"http://www.zhihu.com/rss\",", "\"rel\":", "\"self\"", "}", "},", "\"language\":", "\"zh-cn\",", "\"copyright\":", "\"©", "2018", "知乎(http://www.zhihu.com)\",", "\"lastBuildDate\":", "\"Fri,", "03", "Aug", "2018", "16:30:25", "+0800\",", "\"ttl\":", "\"180\",", "\"item\":", "[{", "\"title\":", "\"如何评价", "2018", "年菲尔兹奖（fields", "medal", "2018）结果与四位得主的工作？\",", "\"link\":", "\"http://www.zhihu.com/question/287977241/answer/458776271?utm_campaign=rss&utm_medium=rss&utm_source=rss&utm_content=title\",", "\"description\":", "\"<p></p><br>\\n", "\",", "\"dc:creator\":", "{", "\"_\":", "\"知识分子\",", "\"$\":", "{", "\"xmlns:dc\":", "\"http://purl.org/dc/elements/1.1/\"", "}", "},", "\"pubDate\":", "\"Fri,", "03", "Aug", "2018", "16:30:25", "+0800\",", "\"guid\":", "\"http://www.zhihu.com/question/287977241/answer/458776271\"", "},]", "}", "}", "}", "}", "复制代码其中的description字段为该文章简介内容的hmtl文档，部分源将全部内容放到其中，所以加载的时候可能比较慢。", "2.", "列表渲染与带参数跳转", "拿到上述数据之后，对数据进行缓存放入Storage中。然后使用wx:for渲染列表。", "页面跳转至详情页时带上文章的数组index值：", "wx.navigateTo({", "url:", "`../detail/detail?id=${rssItemData}&favicon=${favicon}`,", "});", "复制代码在detail.js中取值", "onLoad:", "function", "(options)", "{", "this.showDetail(options.id,", "options.favicon);", "},", "复制代码", "为什么一次性缓存？", "rss源数据返回的就是全部返回", "利于用户体验，不至于加载列表页等待之后，切换详情页还需要等待。", "页面四：源文章详细展示", "核心就是读取Storage中的数据，将html富文本转为wxml。", "这里采用的是wxParse库。将wxParse源码下载后，拷贝至项目根目录，然后在/pages/detail/detail.js中引入、调用。", "const", "WxParse", "=", "require('../../wxParse/wxParse.js');", "...", "WxParse.wxParse('article',", "'html',", "rssDataItem.description,", "that,", "5);", "...", "复制代码ps：单独引入三方库的好处在于，可以自定义部分标签的展示，这个根据实际需求而定。", "页面五：更多", "从已关注页面跳转而来，展示一些额外信息。简单的文字排版，不赘述。", "最后", "小程序开发本身并不复杂，但是要做好做优还需要多学习和练习。这款小程序目前也只是停留在能用的阶段，还有很多需要完善和优化的地方，希望对大家学习有用。另外，有更好的建议请私我，谢谢大家。作者：保山链接：https://juejin.im/post/5b7f5ef46fb9a019d67c0f30"]}
{"author": "Rolan", "title": "微信小程序兼容性问题 ", "content": ["在微信小程序开发中，经常会遇到一些兼容性的问题，我最近就遇到了一个问题，就是在时间字符串转化为时间戳的方法中，我用的Date.parse(new", "Date())这个方法，但是在微信开发者工具中这个方法正常实现，但是在一些iphone设备和安卓的部分设备中不会实现相关功能，为了解决这个问题我只能导入了momentjs，不在调用系统方法了。这里我们就来讨论一下一些兼容性问题。运行环境差异微信小程序运行在三端：iOS、Android", "和", "用于调试的开发者工具。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：在", "iOS", "上，小程序的", "javascript", "代码是运行在", "JavaScriptCore", "中，是由", "WKWebView", "来渲染的，环境有", "iOS8以上", "在", "Android", "上，小程序的", "javascript", "代码是通过", "X5", "JSCore来解析，是由", "X5", "基于", "Mobile", "Chrome", "53/57", "内核来渲染的", "在", "开发工具上，", "小程序的", "javascript", "代码是运行在", "nwjs", "中，是由", "Chrome", "Webview", "来渲染的", "尽管三端的环境是十分相似的，但是还是有些许区别：ES6", "语法支持不一致", "语法上开发者可以通过开启", "ES6", "转", "ES5", "的功能来规避。wxss", "渲染表现不一致", "尽管可以通过开启样式补全来规避大部分的问题，还是建议开发者需要在", "iOS", "和", "Android", "上分别检查小程序的真实表现。ES6", "转", "ES5在", "0.10.101000", "以及之后版本的开发工具中，会默认使用", "babel", "将开发者", "ES6", "语法代码转换为三端都能很好支持的", "ES5", "的代码，帮助开发者解决环境不同所带来的开发问题。", "样式补全开启此选项，开发工具会自动检测并补全缺失样式，保证在低版本系统上的正常显示。尽管可以规避大部分的问题", "，还是建议开发者需要在", "iOS", "和", "Android", "上分别检查小程序的真实表现。样式补全兼容小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。文档会在组件，API等页面描述中带上各个功能所支持的版本号。可以通过", "wx.getSystemInfo", "或者", "wx.getSystemInfoSync", "获取到小程序的基础库版本号。可以通过", "wx.canIUse", "来判断是否可以在该基础库版本下直接使用对应的API或者组件获取系统信息同步let", "res", "=", "wx.getSystemInfoSync()", "console.log(\"同步获取系统信息：\"", "+", "res);", "console.log(res);异步：wx.getSystemInfo({", "success:", "function(res)", "{", "console.log(\"异步获取系统信息:\");", "console.log(res);", "},", "})版本比较微信客户端和小程序基础库的版本号风格为", "Major.Minor.Patch（主版本号.次版本号.修订号）。", "开发者可以根据版本号去做兼容function", "compareVersion(v1,", "v2)", "{", "v1", "=", "v1.split('.')", "v2", "=", "v2.split('.')", "var", "len", "=", "Math.max(v1.length,", "v2.length)", "while", "(v1.length", "<", "len)", "{", "v1.push('0')", "}", "while", "(v2.length", "<", "len)", "{", "v2.push('0')", "}", "for", "(var", "i", "=", "0;", "i", "<", "len;", "i++)", "{", "var", "num1", "=", "parseInt(v1[i])", "var", "num2", "=", "parseInt(v2[i])", "if", "(num1", ">", "num2)", "{", "return", "1", "}", "else", "if", "(num1", "<", "num2)", "{", "return", "-1", "}", "}", "return", "0}compareVersion('1.11.0',", "'1.9.9')//", "1该基础库版本下直接使用对应的API或者组件的APIwx.canIUse(String)判断小程序的API，回调，参数，组件等是否在当前版本可用。此接口从基础库", "1.1.1", "版本开始支持。String参数说明：", "使用{API}.{method}.{param}.{options}或者{component}.{attribute}.{option}方式来调用，例如：{API}", "代表", "API", "名字", "{method}", "代表调用方式，有效值为return,", "success,", "object,", "callback", "{param}", "代表参数或者返回值", "{options}", "代表参数的可选值", "{component}", "代表组件名字", "{attribute}", "代表组件属性", "{option}", "代表组件属性的可选值例子：wx.canIUse('openBluetoothAdapter')wx.canIUse('getSystemInfoSync.return.screenWidth')wx.canIUse('getSystemInfo.success.screenWidth')wx.canIUse('showToast.object.image')wx.canIUse('onCompassChange.callback.direction')wx.canIUse('request.object.method.GET')wx.canIUse('live-player')wx.canIUse('text.selectable')wx.canIUse('button.open-type.contact')Javascript", "标准库兼容性问题微信小程序的兼容性问题除了微信本身的", "Bug", "外，大部分是目标平台对", "JavaScript", "标准库支持程度不同造成的。像我最上面遇到的问题就是Javascript", "标准库兼容性问题。对于这类问题我们可以打补丁，从其他地方找到比较完善的js代码，然后我们拷贝到我们的项目中。作者：辉哥de简书", "链接：https://www.jianshu.com/p/0eabd560b5a8"]}
{"author": "Rolan", "title": "小程序接口加密 ", "content": ["场景小程序请求的所有接口参数必须加密，后台返回数据也需要加密，并且增加Token验证一、小程序端功能编写1.下载一份Js版的aesUtil.js源码。【注：文章末尾会贴出所有的相关类文件】", "2.下载一份Js版的md5.js源码。", "3.在pulic.js中进行加解密操作代码如下，其中秘钥和秘钥偏移量要与后台的一致。var", "CryptoJS", "=", "require('aesUtil.js');", "//引用AES源码jsvar", "md5", "=", "require('md5.js')var", "key", "=", "CryptoJS.enc.Utf8.parse(\"76CAA1C88F7F8D1D\");", "//十六位十六进制数作为秘钥var", "iv", "=", "CryptoJS.enc.Utf8.parse('91129048100F0494');", "//十六位十六进制数作为秘钥偏移量//解密方法function", "Decrypt(word)", "{", "var", "encryptedHexStr", "=", "CryptoJS.enc.Hex.parse(word);", "var", "srcs", "=", "CryptoJS.enc.Base64.stringify(encryptedHexStr);", "var", "decrypt", "=", "CryptoJS.AES.decrypt(srcs,", "key,", "{", "iv:", "iv,", "mode:", "CryptoJS.mode.CBC,", "padding:", "CryptoJS.pad.Pkcs7", "});", "var", "decryptedStr", "=", "decrypt.toString(CryptoJS.enc.Utf8);", "return", "decryptedStr.toString();}//加密方法function", "Encrypt(word)", "{", "var", "srcs", "=", "CryptoJS.enc.Utf8.parse(word);", "var", "encrypted", "=", "CryptoJS.AES.encrypt(srcs,", "key,", "{", "iv:", "iv,", "mode:", "CryptoJS.mode.CBC,", "padding:", "CryptoJS.pad.Pkcs7", "});", "return", "encrypted.ciphertext.toString().toUpperCase();}//暴露接口module.exports.Decrypt", "=", "Decrypt;module.exports.Encrypt", "=", "Encrypt;4.在网络请求帮助类中进行参数的加密和返回数据的解密操作。var", "aes", "=", "require('../utils/public.js')var", "md5", "=", "require(\"../utils/md5.js\").../**", "*", "网络请求", "*/function", "request(method,", "loading,", "url,", "params,", "success,", "fail)", "{", "var", "url", "=", "BASE_URL", "+", "url;", "//请求参数转为JSON字符串", "var", "jsonStr", "=", "JSON.stringify(params);", "console.log(url", "+", "'", "params=>", "'", "+", "jsonStr)", "//根据特定规则生成Token", "var", "token", "=", "productionToken(params);", "//加密请求参数", "var", "aesData", "=", "aes.Encrypt(jsonStr)", "console.log('请求=>明文参数：'", "+", "jsonStr)", "console.log('请求=>加密参数：'", "+", "aesData)", "...", "wx.request({", "url:", "url,", "method:", "method,", "header:", "{", "'Content-Type':", "'application/x-www-form-urlencoded;charset=utf-8',", "'Token':", "token", "},", "data:", "{", "aesData:", "aesData", "},", "//", "data:", "params,", "success:", "function(res)", "{", "//判断请求结果是否成功", "if", "(res.statusCode", "==", "200", "&&", "res.data", "!=", "''", "&&", "res.data", "!=", "null)", "{", "//解密返回数据", "console.log('返回=>加密数据：'", "+", "res.data);", "var", "result", "=", "aes.Decrypt(res.data);", "console.log('返回=>明文数据：'+result);", "success(JSON.parse(result))", "}", "else", "{", "fail()", "}", "},", "fail:", "function(res)", "{", "fail()", "},", "})}其中生成Token的规则，【生成Token的规则可根据具体的业务逻辑自己定义，我这里使用的规则是根据请求参数的字母排序取其value并加上当前时间戳再进行MD5加密】/**", "*", "生成Token", "*/function", "productionToken(params)", "{", "var", "obj", "=", "util.objKeySort(params);", "var", "value", "=", "'';", "for", "(var", "item", "in", "obj)", "{", "value", "+=", "obj[item];", "}", "//加上当前时间戳", "value", "+=", "util.getTokenDate(new", "Date())", "//去除所有空格", "value", "=", "value.replace(/\\s+/g,", "\"\")", "//进行UTF-8编码", "value", "=", "encodeURI(value);", "//进行MD5码加密", "value", "=", "md5.hex_md5(value)", "return", "value;}//util的排序函数function", "objKeySort(obj)", "{", "//先用Object内置类的keys方法获取要排序对象的属性名，再利用Array原型上的sort方法对获取的属性名进行排序，newkey是一个数组", "var", "newkey", "=", "Object.keys(obj).sort();", "//创建一个新的对象，用于存放排好序的键值对", "var", "newObj", "=", "{};", "//遍历newkey数组", "for", "(var", "i", "=", "0;", "i", "<", "newkey.length;", "i++)", "{", "//向新创建的对象中按照排好的顺序依次增加键值对", "newObj[newkey[i]]", "=", "obj[newkey[i]];", "}", "//返回排好序的新对象", "return", "newObj;", "}二、服务端功能编写由于初学SpringMVC，使用的方式不一定是最优最好的，如有不妥善之处，请各位看官多多指教", "思路：通过过滤器拦截请求参数，通过自定义参数包装器对参数进行解密。", "在拦截器获取请求的Token并生成服务器端Token进行验证。", "对返回参数通过JSON转换器进行加密处理。思路图", "1.重写HttpServletRequestWrapper，在自定义的HttpServletRequestWrapper", "中对参数进行处理/**", "*", "Describe：请求参数包装器", "主要作用的过滤参数并解密", "*", "Created", "by", "吴蜀黍", "on", "2018-08-07", "09:37", "**/@Slf4jpublic", "class", "ParameterRequestWrapper", "extends", "HttpServletRequestWrapper", "{", "private", "Map<String,", "String[]>", "params", "=", "new", "HashMap<>();", "@SuppressWarnings(\"unchecked\")", "public", "ParameterRequestWrapper(HttpServletRequest", "request)", "{", "//", "将request交给父类，以便于调用对应方法的时候，将其输出，其实父亲类的实现方式和第一种new的方式类似", "super(request);", "//将参数表，赋予给当前的Map以便于持有request中的参数", "this.params.putAll(request.getParameterMap());", "this.modifyParameterValues();", "}", "//重载一个构造方法", "public", "ParameterRequestWrapper(HttpServletRequest", "request,", "Map<String,", "Object>", "extendParams)", "{", "this(request);", "addAllParameters(extendParams);//这里将扩展参数写入参数表", "}", "private", "void", "modifyParameterValues()", "{//将parameter的值去除空格后重写回去", "//获取加密数据", "String", "aesParameter", "=", "getParameter(Constants.NetWork.AES_DATA);", "log.debug(\"[modifyParameterValues]==========>加密数据：{}\",", "aesParameter);", "//解密", "String", "decryptParameter", "=", "null;", "try", "{", "decryptParameter", "=", "AesUtils.decrypt(aesParameter,", "Constants.AES.AES_KEY);", "log.debug(\"[modifyParameterValues]==========>", "解密数据：{}\",", "decryptParameter);", "Map<String,", "Object>", "map", "=", "JSON.parseObject(decryptParameter);", "Set<String>", "set", "=", "map.keySet();", "for", "(String", "key", ":", "set)", "{", "params.put(key,", "new", "String[]{String.valueOf(map.get(key))});", "}", "aesFlag(true);", "}", "catch", "(CommonBusinessException", "e)", "{", "aesFlag(false);", "log.error(\"[modifyParameterValues]\",", "e);", "log.debug(\"[modifyParameterValues]==========>\",", "e);", "}", "}", "/**", "*", "解密成功标志", "*/", "private", "void", "aesFlag(boolean", "flag)", "{", "params.put(Constants.NetWork.AES_SUCCESS,", "new", "String[]{String.valueOf(flag)});", "}", "@Override", "public", "Map<String,", "String[]>", "getParameterMap()", "{//", "return", "super.getParameterMap();", "return", "params;", "}", "@Override", "public", "Enumeration<String>", "getParameterNames()", "{", "return", "new", "Vector<>(params.keySet()).elements();", "}", "@Override", "public", "String", "getParameter(String", "name)", "{//重写getParameter，代表参数从当前类中的map获取", "String[]", "values", "=", "params.get(name);", "if", "(values", "==", "null", "||", "values.length", "==", "0)", "{", "return", "null;", "}", "return", "values[0];", "}", "public", "String[]", "getParameterValues(String", "name)", "{//同上", "return", "params.get(name);", "}", "public", "void", "addAllParameters(Map<String,", "Object>", "otherParams)", "{//增加多个参数", "for", "(Map.Entry<String,", "Object>", "entry", ":", "otherParams.entrySet())", "{", "addParameter(entry.getKey(),", "entry.getValue());", "}", "}", "public", "void", "addParameter(String", "name,", "Object", "value)", "{//增加参数", "if", "(value", "!=", "null)", "{", "if", "(value", "instanceof", "String[])", "{", "params.put(name,", "(String[])", "value);", "}", "else", "if", "(value", "instanceof", "String)", "{", "params.put(name,", "new", "String[]{(String)", "value});", "}", "else", "{", "params.put(name,", "new", "String[]{String.valueOf(value)});", "}", "}", "}}新建过滤器，在拦截器中调用自定义的参数包装器/**", "*", "Describe：请求参数过滤器", "*", "Created", "by", "吴蜀黍", "on", "2018-08-07", "10:02", "**/@Slf4jpublic", "class", "ParameterFilter", "implements", "Filter", "{", "@Override", "public", "void", "init(FilterConfig", "filterConfig)", "throws", "ServletException", "{", "}", "@Override", "public", "void", "doFilter(ServletRequest", "servletRequest,", "ServletResponse", "servletResponse,", "FilterChain", "filterChain)", "throws", "IOException,", "ServletException", "{", "//使用自定义的参数包装器对参数进行处理", "ParameterRequestWrapper", "requestWrapper", "=", "new", "ParameterRequestWrapper((HttpServletRequest)", "servletRequest);", "filterChain.doFilter(requestWrapper,", "servletResponse);", "}", "@Override", "public", "void", "destroy()", "{", "}}web.xml中对过滤器进行配置", "<!--过滤器-->", "<filter>", "<filter-name>parameterFilter</filter-name>", "<filter-class>com.xxx.xxx.config.filter.ParameterFilter</filter-class>", "</filter>", "<filter-mapping>", "<filter-name>parameterFilter</filter-name>", "<!--", "过滤所有以.json结尾的资源-->", "<url-pattern>*.json</url-pattern>", "</filter-mapping>AES加解密操作", "/**", "*", "Describe：AES", "加密", "*", "Created", "by", "吴蜀黍", "on", "2018-08-03", "17:47", "**/public", "class", "AesUtils", "{", "private", "static", "final", "String", "CHARSET_NAME", "=", "\"UTF-8\";", "private", "static", "final", "String", "AES_NAME", "=", "\"AES\";", "private", "static", "final", "String", "ALGORITHM", "=", "\"AES/CBC/PKCS7Padding\";", "private", "static", "final", "String", "IV", "=", "Constants.AES.AES_IV;", "static", "{", "Security.addProvider(new", "BouncyCastleProvider());", "}", "/**", "*", "加密", "*/", "public", "static", "String", "encrypt(@NotNull", "String", "content,", "@NotNull", "String", "key)", "throws", "CommonBusinessException", "{", "try", "{", "Cipher", "cipher", "=", "Cipher.getInstance(ALGORITHM);", "SecretKeySpec", "keySpec", "=", "new", "SecretKeySpec(key.getBytes(CHARSET_NAME),", "AES_NAME);", "AlgorithmParameterSpec", "paramSpec", "=", "new", "IvParameterSpec(IV.getBytes());", "cipher.init(Cipher.ENCRYPT_MODE,", "keySpec,", "paramSpec);", "return", "ParseSystemUtil.parseByte2HexStr(cipher.doFinal(content.getBytes(CHARSET_NAME)));", "}", "catch", "(Exception", "ex)", "{", "throw", "new", "CommonBusinessException(\"加密失败\");", "}", "}", "/**", "*", "解密", "*/", "public", "static", "String", "decrypt(@NotNull", "String", "content,", "@NotNull", "String", "key)", "throws", "CommonBusinessException", "{", "try", "{", "Cipher", "cipher", "=", "Cipher.getInstance(ALGORITHM);", "SecretKeySpec", "keySpec", "=", "new", "SecretKeySpec(key.getBytes(CHARSET_NAME),", "AES_NAME);", "AlgorithmParameterSpec", "paramSpec", "=", "new", "IvParameterSpec(IV.getBytes());", "cipher.init(Cipher.DECRYPT_MODE,", "keySpec,", "paramSpec);", "return", "new", "String(cipher.doFinal(Objects.requireNonNull(ParseSystemUtil.parseHexStr2Byte(content))),", "CHARSET_NAME);", "}", "catch", "(Exception", "ex)", "{", "throw", "new", "CommonBusinessException(\"解密失败\");", "}", "}}2.新建拦截器，验证Token以及解密的判断", "@Override", "public", "boolean", "preHandle(HttpServletRequest", "httpServletRequest,", "HttpServletResponse", "httpServletResponse,", "Object", "handler)", "throws", "Exception", "{", "//如果不是映射到方法直接通过", "if", "(!(handler", "instanceof", "HandlerMethod))", "{", "return", "true;", "}", "//判断参数包装器中对请求参数的解密是否成功", "boolean", "aesSuccess", "=", "Boolean.parseBoolean(httpServletRequest.getParameter(Constants.NetWork.AES_SUCCESS));", "if", "(!aesSuccess)", "{", "this.sendMsg(Constants.NetWork.CODE_DECRYPTION_FAILURE,", "Constants.NetWork.MEG_AES_FAIL,", "httpServletResponse);", "return", "false;", "}", "//获取客户端上传Token", "String", "token", "=", "httpServletRequest.getHeader(Constants.NetWork.TOKEN_HEAD_KEY);", "if", "(StringUtils.isNullOrEmpty(token))", "{", "sendMsg(Constants.NetWork.CODE_TOKEN_INVALID,", "Constants.NetWork.MSG_TOKEN_EMPTY,", "httpServletResponse);", "return", "false;", "}", "//验证Token的有效性", "if", "(!TokenUtils.verificationToken(token,", "httpServletRequest.getParameterMap()))", "{", "sendMsg(Constants.NetWork.CODE_TOKEN_INVALID,", "Constants.NetWork.MSG_TOKEN_INVALID,", "httpServletResponse);", "return", "false;", "}", "return", "true;", "}", "/**", "*", "验证失败", "发送消息", "*/", "private", "void", "sendMsg(String", "msgCode,", "String", "msg,", "HttpServletResponse", "httpServletResponse)", "throws", "IOException", "{", "httpServletResponse.setContentType(\"application/json;", "charset=utf-8\");", "PrintWriter", "writer", "=", "httpServletResponse.getWriter();", "String", "jsonString", "=", "JSON.toJSONString(StandardResult.create(msgCode,", "msg));", "try", "{", "//对验证失败的返回信息进行加密", "jsonString", "=", "AesUtils.encrypt(jsonString,", "Constants.AES.AES_KEY);", "}", "catch", "(CommonBusinessException", "e)", "{", "e.printStackTrace();", "jsonString", "=", "null;", "log.error(\"[sendMsg]\",", "e);", "}", "writer.print(jsonString);", "writer.close();", "httpServletResponse.flushBuffer();", "}在spring中对拦截器注册", "<mvc:interceptors>", "<!--", "使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求", "-->", "<mvc:interceptor>", "<!--", "拦截所有请求", "-->", "<mvc:mapping", "path=\"/**\"/>", "<!--", "需排除拦截的地址", "-->", "<!--<mvc:exclude-mapping", "path=\"/\"/>-->", "<bean", "class=\"com.xxx.xxx.config.interceptor.AsyncHandlerInterceptor\"/>", "</mvc:interceptor>", "</mvc:interceptors>Token的验证/**", "*", "Describe：Token帮助类", "*", "Created", "by", "吴蜀黍", "on", "2018-08-04", "14:48", "**/@Slf4jpublic", "class", "TokenUtils", "{", "/**", "*", "验证Token", "*", "*", "@param", "token", "客户端上传Token", "*", "@param", "mapTypes", "请求参数集合", "*", "@return", "boolean", "*/", "public", "static", "boolean", "verificationToken(String", "token,", "Map", "mapTypes)", "{", "try", "{", "return", "StringUtils.saleEquals(token,", "getToken(mapTypes));", "}", "catch", "(UnsupportedEncodingException", "e)", "{", "log.error(\"[verificationToken]\",", "e);", "return", "false;", "}", "}", "/**", "*", "通过客户端请求参数产生Token", "*/", "private", "static", "String", "getToken(Map", "mapTypes)", "throws", "UnsupportedEncodingException", "{", "List<String>", "mapKes", "=", "new", "ArrayList<>();", "for", "(Object", "obj", ":", "mapTypes.keySet())", "{", "String", "value", "=", "String.valueOf(obj);", "//去除参数中的加密相关key", "if", "(StringUtils.saleEquals(value,", "Constants.NetWork.AES_SUCCESS)", "||", "StringUtils.saleEquals(value,", "Constants.NetWork.AES_DATA))", "{", "break;", "}", "mapKes.add(value);", "}", "//排序key", "Collections.sort(mapKes);", "StringBuilder", "sb", "=", "new", "StringBuilder();", "for", "(String", "key", ":", "mapKes)", "{", "String", "value", "=", "((String[])", "mapTypes.get(key))[0];", "sb.append(value);", "}", "//加上时间戳，去除所有空格", "进行MD5加密", "String", "string", "=", "sb.append(DateUtils.getDateStr(DateUtils.FORMAT_YYYYMMDDHH)).toString().replace(\"", "\",", "\"\");", "return", "MD5.getMD5(URLEncoder.encode(string,", "\"UTF-8\"));", "}}3.对返回数据进行加密处理，新建JSON转换器继承自阿里的FastJsonHttpMessageConverter/**", "*", "Describe：Json转换器", "将返回数据加密", "*", "Created", "by", "吴蜀黍", "on", "2018-08-07", "13:57", "**/@Slf4jpublic", "class", "JsonMessageConverter", "extends", "FastJsonHttpMessageConverter", "{", "@Override", "protected", "void", "writeInternal(Object", "object,", "HttpOutputMessage", "outputMessage)", "throws", "IOException,", "HttpMessageNotWritableException", "{", "OutputStream", "out", "=", "outputMessage.getBody();", "try", "{", "String", "jsonString", "=", "JSON.toJSONString(object);", "log.debug(\"[writeInternal]======>返回明文数据：{}\"", "+", "jsonString);", "//对返回数据进行AES加密", "jsonString", "=", "AesUtils.encrypt(jsonString,", "Constants.AES.AES_KEY);", "log.debug(\"[writeInternal]======>返回加密数据：{}\"", "+", "jsonString);", "out.write(jsonString.getBytes());", "}", "catch", "(CommonBusinessException", "e)", "{", "e.printStackTrace();", "log.error(\"[writeInternal]======>\",", "e);", "}", "out.close();", "}}spring中对JSON转换器进行配置<mvc:message-converters>", "<!--<bean", "class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter\">-->", "<bean", "class=\"com.xxx.xxx.config.converter.JsonMessageConverter\">", "<property", "name=\"supportedMediaTypes\">", "<list>", "<value>text/html;charset=UTF-8</value>", "<value>application/json</value>", "<value>application/xml;charset=UTF-8</value>", "</list>", "</property>", "<property", "name=\"features\">", "<list>", "<!--", "默认的意思就是不配置这个属性，配置了就不是默认了", "-->", "<!--", "是否输出值为null的字段", "，默认是false-->", "<value>WriteMapNullValue</value>", "<value>WriteNullNumberAsZero</value>", "<value>WriteNullListAsEmpty</value>", "<value>WriteNullStringAsEmpty</value>", "<value>WriteNullBooleanAsFalse</value>", "<value>WriteDateUseDateFormat</value>", "</list>", "</property>", "</bean>", "</mvc:message-converters>三、测试1.控制器/**", "*", "Describe：加解密测试", "*", "Created", "by", "吴蜀黍", "on", "2018-08-08", "11:13", "**/@Slf4j@Controller@RequestMapping(value", "=", "\"/test\")public", "class", "TestController", "{", "@RequestMapping(value", "=", "\"/test.json\")", "@ResponseBody", "private", "StandardResult", "test(Test", "test)", "{", "log.debug(\"[TestController]======>", "接口参数:{}\",", "test.toString());", "return", "StandardResult.createSuccessObj(\"测试成功\");", "}}2.测试结果客户端服务端", "在后台自动加解密模块中，原本是打算都在JSON转换器中处理，通过readInternal()解密，再通过writeInternal()加密，奈何调试的过程中总会出现一些未知错误，如有相关大神，请帮忙指点迷津！通过过滤器来处理参数有些大材小用的意思，如果哪位有更好的方案和处理方式欢迎留言，感激不尽！！！", "四、客户端JS下载客户端JS下载，密码：qxql作者：吴蜀黍", "链接：https://www.jianshu.com/p/4b136750bdea"]}
{"author": "Rolan", "title": "微信小程序里绘制Echart的一些问题 ", "content": ["基于本人所用框架是wepy,最近在微信小程序里需要绘制一些echarts图表，搜索很多都是原生代码集成，总之也是费了一番功夫，记录一下实践过程：1.将echarts.js", "和", "wx-canvas.js", "集成到项目里；2.在page页中引入上述两个文件，就可以在画布上开始绘制所需要的图表了，需要注意的有几点，a.绘图需要指定宽和高；b.图中绿框标注的class名称必须和第二张图片中的名称一致，但不需要和canvas-id保持一致；c.图中红框标注的canvas-id必须保持一致；d.canvas绘图的canvas-id是唯一的，即如果需要绘制两个图表，若两个图表的canvas-id相同，第二个图表不会正常显示；另外canvas-id不能动态赋值，本人尝试过将一个变量传入进去，图表也不能正常显示，具体详情可以查看微信小程序官网的canvas组件；画布", "·", "小程序e.使用canvas绘图它的层级将会是最高的，我遇到一个问题，就是页面会弹框，但遮不住echarts图表，目前官网没有给出解决办法，所以我使用但方法是在弹框但时候将echarts图表隐藏，算是曲线救国了这是我在使用echarts时遇到但一些问题，希望可以帮助到你哦！作者：爱吃荔枝的张长弓", "链接：https://www.jianshu.com/p/60adc03aa371"]}
{"author": "Rolan", "title": "小程序开发实践总结 ", "content": ["css样式不能引用本地图片资源，只能引用线上资源(", "background-image", ")，引用本地图片资源只能用", "<image>", "标签。{{}}", "不能执行函数方法，", "{{}}", "只支持基本的简单运算和ES6拓展运算符。如价格格式化这种常用的处理，只能在js代码中处理好然后再模板中渲染。this.setData({", "price:", "this.formatPrice(this.data.price)", "})", "复制代码可以通过", "wxs", "模块解决", "{{}}", "中不能执行函数的问题。可以做到模拟vue.js中过滤器的功能。<!--", "wxml模板", "-->", "<wxs", "src=\"../../modules/formatPrice.wxs\"", "module=\"tools\"", "/>", "<view>价格：{{tools.formatPrice(price)}}</view>", "复制代码//", "wxs模块", "var", "formatPrice", "=", "function", "(price){", "price", "=", "price", ">>", "0;", "return", "Number(price", "/", "100).toFixed(2);", "}", "module.exports", "=", "{", "formatPrice", "}", "复制代码小程序不支持分享链接到朋友圈，暂时的通用做法是生成保存有页面小程序吗的图片到本地相册。又用户自行发朋友圈转发。前端可以利用", "canvas", "来实现，减轻服务端压力。但是会有图片锯齿不清晰的问题。建议预览图和保存到真机的图片采用不同的尺寸。保存在真机的图片按照750的宽度实现。相比于预览图要大一些，这样保存到手机的图片会清晰很多。小程序布局采用rpx单位，UI稿按照750的宽度出图。可直接使用UI稿的尺寸。但是在某些机型上", "1rpx", "会无法显示。可以用H5的方式实现1px效果。iphoneX吸底按钮的适配，可以用媒体查询获取wx.getSystemInfo获取机型。参考@media", "only", "screen", "and", "(device-width", ":", "375px)", "and", "(device-height", ":", "812px)", "and", "(-webkit-device-pixel-ratio", ":", "3)", "{", "}", "复制代码页面A", "->", "页面B，页面B的操作触发了页面A的数据更新。返回更新页面A的数据，通常有两种方式来实现(我司采用了方案二)：在页面A监听onShow事件，在onShow事件触发时无脑更新页面数据。通过EventBus来实现跨页面通信。复杂组件的开发，省市区三级联动选择器的开发，获取微信地址库的地址的编码和业务采用的省市区编码对不上。页面路径的层级，最大不能超过10层。小程序小程序分包加载，微信对小程序包的大小有如下限制。整个小程序所有分包大小不超过", "8M单个分包/主包大小不能超过", "2M微信小程序主流框架对比wepympvueTarowepywepy应该算是最早发布的小程序开发框架，提供了类vue.js的语法风格和特性，现阶段应该也是应用最广泛的框架吧。我开发的几个小程序也都是采用了wepy这个框架。我先来说说当初为什么选择这个框架的原因吧。类Vue.js的语法风格，适合我们团队原有的的技术栈支持组件化（当时微信官方的API还不支持组件化）支持加载外部npm包支持ES6的写法前期使用wepy的过程中，wepy自带bug。不过好在开发者响应及时，基本上都能覆盖大部分场景。但是有个最大的坑点就是，wepy组件的实现方式。", "组件使用的是静态编译组件，即组件是在编译阶段编译进页面的，每个组件都是唯一的一个实例。", "多个组件共享同一个数据。并且静态编译组件。导致组件A，在页面A和页面B被引用，会copy两份代码到页面A和页面B内部。导致拆分组件并没有对包的体积有任何减少。后期微信官方API支持组件化编程后，我们逐步把一些比较核心，体积较大的组件用原声API重构了。mpvue由美团团队开发，mpvue和wepy一样也是在小程序上提供了类vue.js的开发体验。作为后来者，抢占了很多wepy的市场份额（ps：我们团队近期也在考虑从wepy迁移到mpvue）。这个框架的原理相比wepy要更加复杂一点，mpvue", "修改了", "Vue.js", "的", "runtime", "和", "compiler", "实现，提供了更加接近于vue.js的开发体验。TaroTaro是由京东团队开源的一套遵循", "React", "语法规范的多端开发解决方案。本身我对React和Taro都不是很了解，就不多解释了。具体可以看开发团队的博客和代码了解更多细节", "多端统一开发框架", "-", "Taro我看小程序我想从技术的角度来谈谈我对微信小程序的理解，我觉得小程序本身是一个非常优秀的Hybrid", "App的技术方案。有很多值得学的地方，可以应用到我们Hybrid", "App的技术方案设计中来。了解和学习小程序技术原理也能更好的优化我们的代码。渲染层和逻辑层分离相比于之前常见的Hybrid的方案，", "小程序使用了双线程模型：小程序的渲染层和逻辑层是是分开的，逻辑层通过JSCore来解析和执行，渲染层是通过webview来渲染。之前的常见Hybrid离线包的方案大多使用webview同时实现页面的渲染和js的解析。这样做的的结果就是隔离了js的runtime，在js代码中无法操作webview中的DOM对象和BOM对象。Js无法做任何和页面渲染有关的操作。只能通过setData把数据从JsCore传递到webview。独立的JS运行环境，相比于webview同时处理页面的渲染和JS的执行带来了一些好处：js无法动态的在页面插入节点和干预页面的渲染，解决了安全和管控的问题，否则小程序的上线审核就变得毫无意义。渲染层和逻辑层的分离，减轻了webview的压力，js的执行和页面的渲染可以并行，不会出现js执行卡主页面渲染的情况。多个页面可以共享一个JS运行环境，数据很方便的共享，整个小程序的生命周期共享同一个上下文，接近App的体验。坏处在于：多了很多webview和JSCore数据传输的消耗，数据需要序列化成字符串格式进行传输。离线包加载离线包加载，常见的Hybrid", "App通过webview加载H5页面，前端页面都是放在服务器端。虽说保证了灵活性。但是加载性能收网速影响大。页面切换白屏时间长。小程序离线包的加载方式。一次性加载所有的前端资源到本地再解压。大大提升了用户体验。不过微信官方为了防止下载离线包的时间过程，也严格限制了小程序包的体积。（分包加载情况下子包大小不能超过2M，也就是初次打开加载的资源不能超过2M）多webview架构多webview的页面架构，小程序每新开一个页面，都会用一个新的webview来渲染。为了防止webview对内存的消耗。小程序限制层级不能超过10层。预加载webview预加载webview，微信会预加载多一个wkwebview(ios平台)放后台，用户打开小程序时省去初始化wkwebview时间。"]}
{"author": "Rolan", "title": "微信小程序实时搜索并高亮关键字效果 ", "content": ["很多项目中会有搜索，有时是要点击搜索按钮时搜索，有时是点击键盘完成搜索，还有时需要实时搜索，而高亮关键字也是一个常见的需求。今天写一个实时搜索并高亮关键字的微信小程序demo，已上传GitHub，需要自取微信小程序实时搜索高亮关键字demo这是一个我项目中的截图，但是数据结构又略微有点复杂，不好演示，所以单独又写了一个demo，数据来自干活集中营", "实时搜索高亮关键字", "关键函数：将字符串使用关键字分割：//返回一个使用key切割str后的数组，key仍在数组中getHilightStrArray:", "function(str,", "key)", "{", "return", "str.replace(new", "RegExp(`${key}`,", "'g'),", "`%%${key}%%`).split('%%');}一、新建一个自定义组件，作为显示有高亮字符串的组件1、在自定义组件wxml中循环数组并判断是否是关键字然后设置不同的class，代码如下：<view>", "<text", "wx:for=\"{{searchArray}}\"", "wx:key=\"*this\"", "class=\"{{item", "==", "keyName", "?", "'highlight'", ":", "'normal'", "}}\">{{item}}</text></view>2、在自定义组件js中，定义传入key和str的属性对象datas", "properties:", "{", "/**", "*", "{key:'关键字',name:'待匹配字符串'}", "*/", "datas:", "{", "type:", "Object,", "observer:", "\"_propertyDataChange\"", "}", "},开始是单独传入key和name，表现正常，但是发现在某些特殊情况得不到想要的结果，这里就不列出来了，有兴趣的朋友可以自己尝试。", "3、在自定义组件js中，处理传入的数据methods:", "{", "_propertyDataChange:", "function(newVal)", "{", "console.log(newVal)", "let", "searchArray", "=", "this.getHilightStrArray(newVal.name,", "newVal.key)", "this.setData({", "keyName:", "newVal.key,", "searchArray:", "searchArray", "})", "},", "getHilightStrArray:", "function(str,", "key)", "{", "return", "str.replace(new", "RegExp(`${key}`,", "'g'),", "`%%${key}%%`).split('%%');", "}", "}自定义组件就此完成了二、在搜索页面使用1、在json文件中引入自定义组件{", "\"usingComponents\":", "{", "\"searchHighlightTextView\":", "\"../../component/searchHighlightTextView/searchHighlightTextView\"", "},", "\"navigationBarTitleText\":", "\"搜索\"}2、在搜索页面wxml中编写input，和自定义组件searchHighlightTextView：<view", "class=\"search\">", "<input", "focus='auto'", "bindinput=\"searchInputAction\"", "placeholder=\"输入你要搜索的内容\"", "/></view><!--", "搜索时内容", "--><view", "wx:if=\"{{searchResultDatas.length", ">", "0}}\"", "class=\"search-content-body\">", "<block", "wx:for=\"{{searchResultDatas}}\">", "<view", "class=\"search-result-item\">", "<searchHighlightTextView", "class=\"result-item\"", "datas='{{searchData[index]}}'", "bindtap=\"chooseSearchResultAction\"", "data-id='{{item.ganhuo_id}}'", "/>", "</view>", "</block></view>3、在搜索页面获取输入内容并请求网络赋值，这里有个关键点我们使用的datas是一个Object，所以在获取到数据中先组searchData这个Object:", "wx.request({", "url:", "'https://gank.io/api/search/query/'", "+value", "+", "'/category/all/count/10/page/1',", "data:", "'',", "success:", "function", "(res)", "{", "//", "console.log(res)", "let", "searchData", "=", "res.data.results.map(function(res){", "return", "{", "key:", "value,name:res.desc}", "})", "that.setData({", "searchData,", "searchResultDatas:", "res.data.results", "})", "}效果：搜索关键词高亮", "完整微信小程序demo源码已上传GitHub，需要自取，GitHub地址：微信小程序实时搜索高亮关键字demo作者：韦弦Zhy", "链接：https://www.jianshu.com/p/86d73745e01c"]}
{"author": "Rolan", "title": "微信小程序-仿微信朋友圈 ", "content": ["自学小程序已有2个月，经手的项目及demo也已经让我快速入门当前最火热的语言之一，小程序确实有着移动APP不可比拟的优势，开发快，上线快，迭代也快......本篇简书文章只为给大家讲解思路及怎么处理，有任何不当之处，欢迎大家指出！！！结构解析：剖析图", "1、不管是拿到何种需求，我们第一步骤不是直接撸起袖子就写代码，而是先把结构弄清楚，把UI拆分成N多小模块。①", "左边left-view", "+", "右边right-view列表里面先包一层view，再在该view的基础上进行布局，这样子容易修改整体的背景啊或者进行板块的挪动②", "弹性盒子模型", "flex所有的内容都以盒子模型为基础进行布局③", "图片展示：可以判断显示，如果是一张图，可以单独显示缩略图。（建议所有小图显示加载缩略图）④", "点赞+评论弹出框：点赞和评论弹出框只创建一个，每次修改其y值，距离右侧值为固定值，y值为点击部位的top", "-", "控件height/2点击时动画控制宽度变化", "⑤", "点赞", "+", "评论：点赞和评论部分是一个view下面的两个单独的view，之所以多层view是防止外部的布局影响内部view上控件的布局效果点赞：list横向列表创建，float：left", "靠右布局评论：list纵向列表布局，只能设置line-height，不能设置height链接:https://pan.baidu.com/s/1dPYb-OfaKJE8QXeCoyaxAA", "密码:b9k1作者：带你去旅行", "链接：https://www.jianshu.com/p/67c011bce1e6"]}
{"author": "Rolan", "title": "唱吧小程序之初体验 ", "content": ["项目背景2017年1月9日，我们迎来了微信小程序，而在今年，小程序已经在完全融入到我们的生活中，可以说无处不在，迎来了一场真正的大爆发。微信之父张小龙在形容小程序时，是这样说的小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。而网友们在形容小程序的时候，是这么说的App就像原配，一年用不了几次；", "服务号就像小三，每个月固定用几次；", "小程序就像炮友，用完即走；那么在你点击启动一个小程序的时候，这个“p友”是如何做到无需安装卸载，触手可及，用完即走的呢，这个过程中在交互方面又发生了哪些不可告人的事情，让它如此特殊，下面以我最近接触到的一款小程序为例，简单总结一下小程序底层框架和一些api接口方面的设计思路。小程序框架浅析大家都说小程序体验好，即开即用，和普通Webview渲染的H5相比页面启动速度、流畅度等方面好很多，这个问题我认为需要从几个方面考虑，首先，抛开产品业务层面的设计和优化，就是小程序底层框架的设计和实现方面的特点。当我们新建或打开一个小程序项目（以唱吧比赛小程序为例），即可看到如下图的项目结构。小程序入口文件为app.js，", "全局样式文件为app.wxss，全局配置文件为app.json，", "每个页面中再分视图wxml，wxss和逻辑js、文件配置json等，从这里我们可以看出，整个小程序的上层框架，也就是大体分为视图层和逻辑层两个部分。", "（摘自官方文档https://developers.weixin.qq.com/miniprogram/dev/framework/structure.html）小程序采用的MINA框架，View层主要用来渲染页面结构，App", "Service层用来逻辑处理、数据请求、接口调用，它们在两个线程里运行，整个小程序是只有一个App", "Service的，并且整个小程序的生命周期内它是常驻内存的。View层主要使用WebView渲染，而App", "Service逻辑层是使用JSCore运行。通信方面，View和AppService是双线程通信的，主要通过系统层的JSBridage进行通信，AppService把数据变化通知到View，表现方法也就是setData方法，触发View页面更新，View把触发的事件通知到AppService进行业务处理。这里要说的是，小程序是没有DOM结构的，那么视图层的渲染是如何做到的呢，就是运行环境中会把pages中的WXML的节点树结构，转化为JS的对象，进行渲染，这也是小程序体验优于普通分享页面的一大原因，省去了很多关于浏览器DOM的操作，由JS运行环境之间进行渲染解析。唱吧小程序底层搭建那么话说回来，基于良好的框架，这次在搭建唱吧小程序底层的时候，我们其实做了哪些事情呢。首先，我们并没有进行纯Native层的搭建和改造，而是对上述提到的API层的一次的封装，尤其是在关于网络请求的改造和小程序启动的登录流程方面，我们前端团队尝试去做一些分层和优化。网络请求方面首先网络请求优化方面，微信提供的请求接口基本长这样：wx.request({", "url:", "'test.php',", "//仅为示例，并非真实的接口地址", "data:", "{", "x:", "''", ",", "y:", "''", "},", "header:", "{", "'content-type':", "'application/json'", "//", "默认值", "},", "success:", "function(res)", "{", "console.log(res.data)", "}})是不是感觉和之前的某种请求模式很像，没错，就是古老的$.ajax，这时候我们又想起了ajax的回调地狱，如果页面的请求很多，请求的顺序还有限定，瞬间又是各种嵌套，可以说是要从请求到懵逼了。所以为了解决回调地狱和同时优化请求代码逻辑，我们在封装wx.request的同时，我们在小程序开发中，引入了async/await语法糖，用到了来自facebook的regenerator模块（详情请戳：https://github.com/facebook/regenerator），async、await函数经babel编译后，再用regenerator-runtime模块用于提供功能实现，这一方面也得力于小程序支持ES6语法的编译。实现过程中，单独用一个公共方法封装，返回wx.request的promise//wechat.jsconst", "request", "=", "(url,options)", "=>", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "wx.request({", "url:", "url,", "method:", "options.method,", "data:", "Object.assign({},", "options.data),", "header:", "options.header,", "success:", "resolve,", "fail:", "reject", "})", "})}之后在我们的上层公共库中，编写与请求相关的处理逻辑。//", "changba.jsconst", "regeneratorRuntime", "=", "require('./regenerator-runtime.js')const", "wechat", "=", "require('./wechat')const", "URI", "=", "'xxx'const", "requestAPI", "=", "async", "(url,opt)", "=>", "{", "const", "app", "=", "getApp()", "let", "options", "=", "Object.assign({data:", "{}},opt)", "if", "(/^\\/api\\/(.+)$/.test(url))", "{", "url", "=", "URI", "+", "url;", "}", "if", "(!options.method)", "{", "options.method", "=", "'POST';", "}", "let", "header", "=", "{", "'Content-Type':", "'application/x-www-form-urlencoded'", "}", "options.header", "=", "options.header", "||", "header", ";", "//除了login方法", "其余接口都要加入sessionInfo也就是后端加密过的session_key", "if", "(!url.includes('/checkCode'))", "{", "options.data['sessionInfo']", "=", "app.globalData.sessionkey;", "}", "let", "isTimeout", "=", "false;", "try", "{", "const", "ree", "=", "await", "wechat.checkSession();", "}", "catch", "(error)", "{", "isTimeout", "=", "true;", "};", "try", "{", "if", "(isTimeout)", "{", "let", "aaa", "=", "await", "login(app);", "}", "wx.showLoading({", "title:", "'加载中'", "});", "const", "res", "=", "await", "wechat.request(url,options)", "if", "(res", "&&", "res.statusCode)", "{", "if", "(res.statusCode", "!=", "200)", "{", "if", "(wx.hideLoading)", "{", "wx.hideLoading()", "}", "wx.showModal({", "content:", "wechat.errMsg(res.statusCode).message", "||", "'请求失败，请重新尝试',", "title:", "'提示',", "showCancel:", "false", "})", "}", "else", "{", "if", "(res.data", "&&", "res.data.code", "===", "1)", "{", "if", "(wx.hideLoading)", "{", "wx.hideLoading()", "}", "return", "res.data", "}", "else", "{", "//", "xxx", "其他情况业务逻辑处理", "}", "}", "}", "}", "catch", "(error)", "{", "console.log('请求异常信息：'", "+", "error)", "if", "(wx.hideLoading)", "{", "wx.hideLoading()", "}", "wx.showModal({", "content:", "'请求信息异常',", "title:", "'',", "showCancel:", "false", "})", "}}上述封装过程中，所以除了考虑到请求超时、检查用户身份等操作，还可以加入session过期等相关其他的业务处理逻辑，这也是自己搭建请求的好处，针对自己的业务需求，进行匹配和改造。然而在经历这样两层封装之后，在写业务逻辑代码的过程中，就可以一目了然的发送请求了，达到逻辑清晰且书写自如，如果习惯了fetch以及axios的朋友应该都会比较喜欢这种方式。", "async", "getdata()", "{", "let", "self", "=", "this;", "let", "cb_getdata", "=", "await", "app.changba.requestAPI('/api/xxx',", "{", "data:", "{", "id:", "self.data.id", "}", "});", "if", "(cb_getdata", "&&", "cb_getdata.code", "===", "1)", "{", "//", "xxx", "}", "}登录流程方面下面说下，启动小程序后的登录流程方面，在这一方面，小程序与其他不同的是，没有固定的登录启动页面，而是完全后台交互，当然根据产品定位和需求，也可以自己做一套登录系统，但是微信官方给出的文档基本长这样：没错，看着很头大，然而最头大的不是你按部就班的实现了这个流程，而是实现了之后，你还会遇到很多意想不到的问题。基本的流程不用多说，按部就班即可，就是使用wx.login()可以获得开发者服务器向微信接口服务器请求获得sessionkey等数据时所需要的参数code，开发者服务器以code+appid+appsecret换取用户唯一标识openid和会话密钥sessionkey。但每一次调用wx.login()都会更新微信接口服务器上的session_key。同样，改造微信api先，//", "wechat", "登录封装const", "login", "=", "()", "=>", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "wx.login({", "success:", "resolve,", "fail:", "reject", "})", "})}而后，在做自己的登录封装时，可以先去请求微信的code，然后用在自己的请求中，获取并存储自己的登录态。let", "we_login", "=", "await", "wechat.login()", "//", "微信登录let", "cb_login", "=", "await", "requestAPI('xxxx/checkCode',", "{", "data:", "{code:", "we_login.code}})if", "(cb_login", "&&", "cb_login.code", "===", "1)", "{", "//", "xxxx", "业务逻辑", "}", "catch", "(error)", "{", "wx.showModal({", "title:", "'登录提示',", "content:", "'登录失败',", "showCancel:", "false", "})", "}而在完成上面整套业务逻辑过程中，可能会遇到一些意想不到的坑，这里面我印象比较深刻的有两个，第一个是关于授权的问题，另一个就是关于小程序生命周期与页面生命周期初始化过程中异步请求回调顺序的问题。授权问题先说第一个问题，关于授权框唤起的问题，也就是你常见的下面这个框。只有用户授权后，才可以进一步获取用户的信息，这个框在最初是可以通过wx.getUserinfo()方法直接唤起，而在5月份以后，微信去掉了这个方法的功能，只能通过固定的button", "open-type去引导用户授权。所以在底层逻辑的设计过程中，就要抛弃之前login之后获取用户授权信息的设计思路，而是进行拆分，将login和授权的逻辑分开。在必须要授权操作的地方例如我们小程序中需要“参赛”或者“关注”的地方，进行单独授权的处理，通过使用wx.getSetting获取用户的授权情况", "1)", "如果用户已经授权，直接调用wx.getUserInfo获取用户最新的信息", "2)", "用户未授权，在界面中显示一个按钮提示用户登入，当用户点击并授权后就获取到用户的最新信息。onLaunch和onLoad异步回调顺序问题这个问题简单来说，就是小程序启动有自己的生命周期onLaunch->onShow->onHide，而每个page的实例化也有自己的生命周期，onLoad->onShow->onReady->onHide->onUnload然而在开发过程中，会遇到这种情况，在App启动onLaunch的时候，发起登录请求，并注册到我们自己的服务器上以便使用，这个过程中，app", "on", "launch", "->", "request", "->", "success", "->", "page", "onload是无法判断success和page", "onload哪个先，会导致页面初始化数据失败的情况，为了解决这个问题，我们团队也是想到了几种常见的解决方案。解决方案一", "就是在request", "success中处理，使用getCurrentPages方法获取是否页面先于success生成，如果生成我们就强制让页面再次渲染。这显然是一种hack的方式，", "在实际使用过程当中，如果登录逻辑比较复杂，这个方法不是十分便利，page", "onload在一些特殊情况也会被调用，这显然不是我们想看到的if", "(getCurrentPages().length", "!=", "0)", "{", "getCurrentPages()[getCurrentPages().length", "-", "1].onLoad()", "}解决方案二（目前我在开发中使用的是这种方案）在login的逻辑里，增加一个回调函数cbLoginCallBack。Page页面判断一下当前app.globalData.sessionKey是否存在，如果没有（第一次）则定义定义一个app方法（回调函数）//", "Login", "Request", "if", "(app.cbLoginCallBack)", "{", "typeof", "app.cbLoginCallBack", "==", "'function'", "&&", "app.cbLoginCallBack(cb_login.data)", "}", "//", "逻辑页面", "if", "(app.globalData.sessionkey)", "{", "//", "init", "data", "}", "else", "{", "app.cbLoginCallBack", "=", "res", "=>", "{", "if", "(res)", "{", "//", "init", "data", "}", "}", "}App页面在请求success后判断时候有Page页面定义的回调方法，如果有就执行该方法。因为回调函数是在Page里面定义的所以方法作用域this是指向Page页面。总结杂七杂八写了很多，基本都是近期开发和学习过程中自己对小程序体验和交互方面的一点总结，在这里跟大家分享，以便遇到同样的问题，可以一起探讨，找出最优的解决方案，今年小程序的热度还将持续一阵，各大小公司持续发力，未来在这个领域还会有哪些事情发生，让我们拭目以待。最后，感兴趣的票友们欢迎来唱吧比赛小程序参加比赛。文章来源：微信公众号ChangbaDev"]}
{"author": "Rolan", "title": "小程序实现长按录音，上划取消发送 ", "content": ["最近在使用mpvue开发小程序，需要用到录音功能，于是打算参照微信的录音方案：\"长按录音松开发送，上划取消发送\"。在网上找了一圈都没发现相似的案例，没办法只能自己实现。下面讲解只贴上关键代码1.", "html部分。微信小程序事件接口：//html部分", "class部分只是控制样式", "与功能无关分析:长按录音需要longpress事件，松开发送需要touchend事件，上滑取消发送需要touchmove事件。由此可有以下html代码<div", "class=\"input", "weui-grid\"", "hover-class=\"weui-grid_active\"", ":class=\"record.type\"", "@longpress=\"handleRecordStart\"", "@touchmove=\"handleTouchMove\"", "@touchend=\"handleRecordStop\">", "<image", "class=\"weui-grid__icon\"", ":src=\"record.iconPath\"/>", "<div", "class=\"weui-grid__label\">{{record.text}}</div>", "</div>", "2.", "JS部分2.1.", "首先定义录音的数据结构：旧版的小程序录音接口wx.startRecord和wx.stopRecord在1.6.0版本后不再维护了，所以使用其建议的wx.getRecordManager接口。注意:使用wx.getRecordManager接口的话,应调用相应的音频控制接口wx.createInnerAudioContext()来播放和控制录音.data(){", "record:", "{", "text:", "\"长按录音\",", "type:", "\"record\",", "iconPath:", "require(\"@/../static/icons/record.png\"),", "handler:", "this.handleRecordStart", "},", "//与录音相关的数据结构", "recorderManager:", "wx.getRecorderManager(),", "//录音管理上下文", "startPoint:", "{},", "//记录长按录音开始点信息,用于后面计算滑动距离。", "sendLock:", "true,", "//发送锁，当为true时上锁，false时解锁发送", "},", "2.2.", "监听录音stoponLoad(){", "this.recorderManager.onStop(res", "=>", "{", "if", "(this.sendLock)", "{", "//上锁不发送", "}", "else", "{//解锁发送，发送网络请求", "if", "(res.duration", "<", "1000)", "wx.showToast({", "title:", "\"录音时间太短\",", "icon:", "\"none\",", "duration:", "1000", "});", "else", "this.contents", "=", "[...this.contents,{", "type:", "\"record\",", "content:", "res", "}];//contents是存储录音结束后的数据结构,用于渲染.", "}", "});", "}2.3.", "长按录音方法在这个方法中需要做的事:记录长按的点信息,用于后面计算手指滑动的距离,实现上滑取消发送.做一些界面样式的控制.开始录音", "handleRecordStart(e)", "{", "//longpress时触发", "this.startPoint", "=", "e.touches[0];//记录长按时开始点信息，后面用于计算上划取消时手指滑动的距离。", "this.record", "=", "{//修改录音数据结构，此时录音按钮样式会发生变化。", "text:", "\"松开发送\",", "type:", "\"recording\",", "iconPath:", "require(\"@/../static/icons/recording.png\"),", "handler:", "this.handleRecordStart", "};", "this.recorderManager.start();//开始录音", "wx.showToast({", "title:", "\"正在录音，上划取消发送\",", "icon:", "\"none\",", "duration:", "60000//先定义个60秒，后面可以手动调用wx.hideToast()隐藏", "});", "this.sendLock", "=", "false;//长按时是不上锁的。", "},", "2.4.", "松开发送在这个方法中需要做的事:做一些样式的控制.结束录音.", "handleRecordStop()", "{", "//", "touchend(手指松开)时触发", "this.record", "=", "{//复原在start方法中修改的录音的数据结构", "text:", "\"长按录音\",", "type:", "\"record\",", "iconPath:", "require(\"@/../static/icons/record.png\"),", "handler:", "this.handleRecordStart", "};", "wx.hideToast();//结束录音、隐藏Toast提示框", "this.recorderManager.stop();//结束录音", "}2.5.", "上划取消发送在这个方法中需要做的事:计算手指上滑的距离根据距离判断是否需要取消发送如果取消发送,最重要的是this.sendLock", "=", "true,上锁不发送", "handleTouchMove(e)", "{", "//touchmove时触发", "var", "moveLenght", "=", "e.touches[e.touches.length", "-", "1].clientY", "-", "this.startPoint.clientY;", "//移动距离", "if", "(Math.abs(moveLenght)", ">", "50)", "{", "wx.showToast({", "title:", "\"松开手指,取消发送\",", "icon:", "\"none\",", "duration:", "60000", "});", "this.sendLock", "=", "true;//触发了上滑取消发送，上锁", "}", "else", "{", "wx.showToast({", "title:", "\"正在录音，上划取消发送\",", "icon:", "\"none\",", "duration:", "60000", "});", "this.sendLock", "=", "false;//上划距离不足，依然可以发送，不上锁", "}", "},", "}2.6.", "演示GIF文章来源：Rychou个人博客"]}
{"author": "Rolan", "title": "微信小程序如何裁剪图片作为转发封面 ", "content": ["我们知道微信小程序的转发时的封面图片比例固定为5:4，具体内容详见小程序开发文档：但是，在实际开发时我们有时需要将某张动态请求的网络图片作为转发封面图（比如文章封面），而这张图片又往往不符合", "5:4", "的比例要求。这时，如果我们直接将这张图片作为封面图其实也是可以的，只不过将长宽比大于", "5:4", "作为转发封面时，封面下可能会留有部分空白。我们可以直接以简书为例，简书目前分享文章到微信时是以小程序的方式分享，而其分享封面也正是取自该文章的封面，所以，如果我们从小程序中转发可能会看到类似下图的转发封面图：可以看到，封面图下面存在大块空白，如果图片长宽比例更大，那么下面的空白也将更大。因此，为了更加美观，我们必须将图片按照", "5:4", "比例进行适当地裁剪，而我写本文的目的也正是如此。1.", "创建Canvas画布前端要裁剪图片，我们首先就要想到用Canvas，写H5如此，微信小程序当然也是如此。<canvas", "style=\"position:", "absolute;", "top:", "-1000px;", "left:", "-1000px;", "width:", "640px;", "height:", "640px;", "background:", "#000\"", "canvas-id=\"canvas\"></canvas>我们要用到的canvas当然不能直接在页面中显示，所以可以使用负定位值的方式将其隐藏。2.", "下载网络图片我们可以使用wx.downloadFile()来下载网络图片，也可以使用wx.getImageInfo()，因为我们这里需要获取到图片的宽高，所以这里就要用到wx.getImageInfo()来进行图片的下载。wx.getImageInfo({", "src:", "\"\",", "//", "这里填写网络图片路径", "success:", "(res)", "=>", "{", "//", "这个是我封装的裁剪图片方法（下面将会说到）", "clipImage(res.path,", "res.width,", "res.height,", "(img)", "=>", "{", "console.log(img);", "//", "img为最终裁剪后生成的图片路径，我们可以用来做为转发封面图", "});", "}});3.", "裁剪图片并导出以下是我封装的专门用于裁剪图片比例大于", "5:4", "的图片，裁剪方式是截取图片中间部分（当然你也可以试着写下裁剪小于", "5:4", "的图片）：/*", "裁剪封面，", "src为本地图片路径或临时文件路径，", "imgW为原图宽度，", "imgH为原图高度，", "cb为裁剪成功后的回调函数*/const", "clipImage", "=", "(src,", "imgW,", "imgH,", "cb)", "=>", "{", "//", "‘canvas’为前面创建的canvas标签的canvas-id属性值", "let", "ctx", "=", "wx.createCanvasContext('canvas');", "let", "canvasW", "=", "640,", "canvasH", "=", "imgH;", "if", "(imgW", "/", "imgH", ">", "5", "/", "4)", "{", "//", "长宽比大于5:4", "canvasW", "=", "imgH", "*", "5", "/", "4;", "}", "//", "将图片绘制到画布", "ctx.drawImage(src,", "(imgW", "-", "canvasW)", "/", "2,", "0,", "canvasW,", "canvasH,", "0,", "0,", "canvasW,", "canvasH)", "//", "draw()必须要用到，并且需要在绘制成功后导出图片", "ctx.draw(false,", "()", "=>", "{", "setTimeout(()", "=>", "{", "//", "导出图片", "wx.canvasToTempFilePath({", "width:", "canvasW,", "height:", "canvasH,", "destWidth:", "canvasW,", "destHeight:", "canvasH,", "canvasId:", "'canvas',", "fileType:", "'jpg',", "success:", "(res)", "=>", "{", "//", "res.tempFilePath为导出的图片路径", "typeof", "cb", "==", "'function'", "&&", "cb(res.tempFilePath);", "}", "})", "},", "1000);", "})}本文重点总结①", "使用Canvas画布进行图片裁剪②", "裁剪网络图片前，必须使用wx.getImageInfo()下载图片并同时获取图片的宽高作者：前端王睿", "链接：https://www.jianshu.com/p/12fdfb152906"]}
{"author": "Rolan", "title": "转转：微信小程序分包加载实战 ", "content": ["微信小程序采用的是类似离线包加载方案，以", "转转小程序", "为例，当用户第一次打开时会先下载好所有代码，然后再加载页面；当用户再次进入转转小程序时，会直接使用已下载的代码，省去了代码下载的过程，打开速度更快。看似很美好的设计，但有两个问题：第一次打开转转小程序时白屏时间很长，因为要下载接近2.5M的代码量，也就是说你的代码越多，白屏时间越长，而转转APP采用的网页离线机制体验更佳：在用户打开APP时就下载/更新离线包，这样在用户进入对应的网页时，代码已经下载好了，没有漫长的白屏过程。代码有部分更新时，没办法进行增量更新，导致每次发版后，用户都需要重新下载全部代码问题看似不大，但对转转有很大影响，例如进行微信广告投放时，用户从点击广告到加载第一个页面之间的流失率竟能到达", "40%", "，这显然是", "FE", "无法接受的性能，而小程序分包加载机制能够在一定程度上解决上述问题。分包加载小程序的分包加载机制实际上是离线包和", "M", "页的一种结合机制，即你可以把代码划分成主包", "+N", "个分包，官方定义：在小程序启动时，默认会下载主包并启动主包内页面，如果用户需要打开分包内某个页面，客户端会把对应分包下载下来，下载完成后再进行展示。总结如下：打开小程序，默认先加载主包进入分包页面时，再加载对应分包这样的好处是进入主包页面时，需要下载的代码量小了很多，白屏时间更短，体验更佳。特性1.7.3", "及以上基础库开始支持，不支持的版本默认使用整包的方式整个小程序所有分包大小不超过", "4M，单个分包/主包大小不能超过", "2M分包数量目前没有限制，也就是说你可以放", "N", "个分包，甚至每个页面一个分包入口页面", "/", "Tab", "页面必须在主包里关于主包第一次进入小程序，默认下载主包代码分包以外的所有代码，都会被打入主包分包内代码可以引用主包内代码关于分包因为存在资源依赖关系，微信的机制是先下载主包，后下载分包分包目录不能在主包目录下面分包可以引用自己包内、主包内的资源，不能引用其他分包内的资源坑小程序的打包机制仅仅是根据文件目录打包，分包内require/import的任何文件，只要不在同一个目录下面，都不会被打进分包，也就是说，类库及一些公共文件，只能放在主包里面，如果主包分包划分不好的话，主包的大小也很难降下来安卓系统进入分包页面时，会出现一个丑陋的系统级的loading层，这一定程度上影响了安卓的体验转转的分包加载转转小程序在使用分包之前，压缩后的代码量大概是2.45M，也就是说，每个新用户第一次都需要下载的2.45M代码才能进入页面，使用分包机制后，主包大小降为1M左右，也就是说，如果是进入主包页面，", "下载时间大约降低了60%文件结构：├──", "libs", "├──", "components", "├──", "pages", "主包根目录", "├────index", "首页", "├────post", "发布页", "├────...", "├──", "subPages", "分包根目录", "├────trade", "交易分包", "├────mine", "我的页面分包", "├────...", "复制代码我们根据用户访问的轨迹，分成了", "20", "个左右的分包。", "例如", "trade", "包，里面包含详情页、下单页、支付页、支付成功页等，这条线的页面，用户可能不需要一进入小程序就使用，但一旦使用可能是使用整个链条，因此可以作为一个分包。历史入口兼容一个页面放入分包之后，路径会发生变化，例如详情页由", "/pages/detail", "变为", "/subPages/trade/detail，意味着如果用户访问了以前的", "page", "则得不到正确的页面响应（例如：分享出去的小程序卡片、二维码、公众号推送消息等），这些静态不可改变的历史入口怎么办？我们目前采用如下方案：原来主包内的每个页面都保留，但代码只保留跳转逻辑，用户进来后立即跳到对应的分包页面，用户几乎是无感知的这样也会产生一点小问题：这些跳转页面也占用一定的空间，接下来我们会优化成在", "onLaunch、页面跳转时进行判断，直接跳入正确的分包页面。以上是转转在分包加载方面的实战记录，欢迎小程序开发者与我们交流经验。另外，本文作者", "转转前端负责人", "张所勇，也会在掘金开发者大会・微信小程序专场分享转转小程序开发经验，演讲主题是「小程序", "WebView", "应用实践」。"]}
{"author": "Rolan", "title": "小程序生成海报保存分享图片完全指南 ", "content": ["小程序生成海报保存分享图片完全指南（包括：头像，文字）作者：starkwang原文：https://segmentfault.com/a/1190000016039298业务在小程序中生成海报（包括用户头像和自定义文字）并且保存到本地实现思路利用canvas画布，把用户头像和自定义文字定位好，用户点击按钮保存到本地注意事项", "难点小程序canvas不支持自定义宽高，反正我没找到，canvas画布大部分业务都需要全屏，响应式，至少宽100%解决方案：判断到屏幕尺寸，传到wxml", "里面远程图片不能直接使用", "getImageInfo", "获取，需要保存到本地解决方案：canvas直接支持远程图片，不需要使用这个api先来个ui", "（嘿嘿！此图经过公司的设计授权过）技术栈canvaswx.createCanvasContextwx.canvasToTempFilePathPromise实战首先我们在wxml里面写一个canvas占位注意这里的宽度是100%，响应式，海报的高posterHeight", "是从js里面动态计算的<canvas", "canvas-id=\"starkImg\"", "style=\"width:100%;height:{{posterHeight}}px;\"></canvas>根据屏幕动态计算海报的尺寸data:", "{", "motto:", "'Hello", "World',", "hidden:", "true,", "userInfo:", "{},", "hasUserInfo:", "false,", "windowWidth:", "'',", "posterHeight:", "'',", "},", "onLoad:", "function", "()", "{", "const", "poster", "=", "{", "\"with\":", "375,", "\"height\":", "587", "}", "const", "systemInfo", "=", "wx.getSystemInfoSync()", "let", "windowWidth", "=", "systemInfo.windowWidth", "let", "windowHeight", "=", "systemInfo.windowHeight", "let", "posterHeight", "=", "parseInt((windowWidth", "/", "poster.with)", "*", "poster.height)", "this.setData({", "windowWidth:", "windowWidth,", "posterHeight:", "posterHeight", "})", "}背景图片生成", "const", "that", "=", "this", "//", "图片路径", "const", "imagePath", "=", "'../../static/image/common/'", "let", "bgimgPromise", "=", "new", "Promise(function", "(resolve,", "reject)", "{", "console.log('data',", "that.data)", "wx.getImageInfo({", "src:", "imagePath", "+", "\"base.png\",", "success:", "function", "(res)", "{", "resolve(res);", "}", "})", "});头像直接使用远程头像初始化的时候，调取，一定在生成海报之前此处可以存储本地，或使用状态都可以wxml//", "可以从后端接口获取", "或", "官方本身远程地址", "<button", "class=\"share\"", "type=\"primary\"", "open-type=\"getUserInfo\"", "bindgetuserinfo=\"getUserInfo\">开始答题（获取用户信息）</button>", "js", "getUserInfo:", "function", "(e)", "{", "app.globalData.userInfo", "=", "e.detail.userInfo", "let", "userInfo", "=", "e.detail.userInfo", "console.log('userInfo',", "userInfo)", "//", "更新用户信息", "//", "api.post('更新用户信息的url',", "userInfo)", "this.setData({", "userInfo:", "e.detail.userInfo,", "hasUserInfo:", "true", "})", "},生成海报背景和图片wxmlbgimgPromise.then(res", "=>", "{", "console.log('Promise.all',", "res)", "const", "ctx", "=", "wx.createCanvasContext('shareImg')", "ctx.width", "=", "windowWidth", "ctx.height", "=", "posterHeight", "console.log(windowWidth,", "posterHeight)", "//", "背景图", "ctx.drawImage('../../'", "+", "res[0].path,", "0,", "0,", "windowWidth,", "posterHeight,", "0,", "0)", "//", "头像", "ctx.drawImage(that.data.userInfo.avatarUrl,", "48,", "182,", "58,", "58,", "0,", "0)", "ctx.setTextAlign('center')", "ctx.setFillStyle('#000')", "ctx.setFontSize(22)", "//", "ctx.fillText('分享文字2：stark.wang出品',", "88,", "414)", "ctx.fillText('分享文字1我的博客：https://shudong.wang',", "55,", "414)", "ctx.stroke()", "ctx.draw()", "})保存到本地onLoad:", "function", "()", "{", "share:", "function", "()", "{", "var", "that", "=", "this", "wx.showLoading({", "title:", "'正在制作海报。。。'", "})", "new", "Promise(function", "(resolve,", "reject)", "{", "wx.canvasToTempFilePath({", "x:", "0,", "y:", "0,", "width:", "444,", "height:", "500,", "destWidth:", "555,", "destHeight:", "666,", "canvasId:", "'starkImg',", "success:", "function", "(res)", "{", "console.log(res.tempFilePath);", "that.setData({", "prurl:", "res.tempFilePath,", "hidden:", "false", "})", "wx.hideLoading()", "resolve(res)", "},", "fail:", "function", "(res)", "{", "console.log(res)", "}", "})", "}).then(res", "=>", "{", "console.log(res)", "this.save()", "})", "}", "}结果更新头像裁剪为圆形ctx.save()", "//", "对当前区域保存", "ctx.beginPath()", "//", "开始新的区域", "ctx.arc(73,", "224,", "38,", "0,", "2", "*", "Math.PI);", "ctx.clip();", "//", "从画布上裁剪出这个圆形", "ctx.drawImage(res[1],", "36,", "186,", "94,", "94,", "0,", "0)", "//", "把图片填充进裁剪的圆形", "ctx.restore()", "//", "恢复上面是远程连接容易发生请求失败把头像提前存到本地存储中解决getImg:", "function", "()", "{", "let", "avatarUrl", "=", "this.data.userInfo.avatarUrl", "downLoadFile(avatarUrl).then((res)", "=>", "{", "console.log(res)", "wx.saveFile({", "tempFilePath:", "res.data.tempFilePath,", "success:", "function", "(res)", "{", "wx.setStorageSync('avatarUrl',", "res.savedFilePath)", "}", "})", "})", "},获取头像//", "头像", "let", "promiseAvatarUrl", "=", "new", "Promise(function", "(resolve,", "reject)", "{", "resolve(wx.getStorageSync('avatarUrl'))", "}).catch(res=>{", "console.log('catch',res)", "});背景还是不变const", "that", "=", "this", "let", "promiseBdImg", "=", "new", "Promise(function", "(resolve,", "reject)", "{", "console.log('data',", "that.data)", "wx.getImageInfo({", "src:", "imagePath", "+", "\"base1.png\",", "success:", "function", "(res)", "{", "console.log('promiseBdImg',", "res)", "resolve(res);", "}", "})此时生成canvas更新Promise.all([", "promiseBdImg,", "promiseAvatarUrl", "]).then(res", "=>", "{", "console.log('Promise.all',", "res)", "const", "ctx", "=", "wx.createCanvasContext('shareImg')", "ctx.width", "=", "windowWidth", "ctx.height", "=", "posterHeight", "console.log(windowWidth,", "posterHeight)", "//主要就是计算好各个图文的位置", "ctx.drawImage('../../'", "+", "res[0].path,", "0,", "0,", "windowWidth,", "posterHeight,", "0,", "0)", "ctx.save()", "//", "对当前区域保存", "ctx.beginPath()", "//", "开始新的区域", "ctx.arc(73,", "224,", "38,", "0,", "2", "*", "Math.PI);", "ctx.clip();", "//", "从画布上裁剪出这个圆形", "ctx.drawImage(res[1],", "36,", "186,", "94,", "94,", "0,", "0)", "//", "把图片填充进裁剪的圆形", "ctx.restore()", "//", "恢复", "ctx.setTextAlign('center')", "ctx.setFillStyle('#000')", "ctx.setFontSize(22)", "ctx.save()", "ctx.beginPath();", "ctx.fillText('作者：stark.wang',", "545", "/", "2,", "130)", "ctx.fillText('我的博客：http://shudong.wang',", "190,", "414)", "ctx.stroke()", "ctx.draw()", "})结果完美ok，如果能帮助你，请赞一个。感觉日后会需要，推荐收藏"]}
{"author": "Rolan", "title": "一个 JS 库就能解决小程序跨页传递事件消息和数据 ", "content": ["由于微信小程序", "wx.navigateBack", "方法并不支持返回传值，导致页面在返回后，不能方便地即时更新数据。一.需求分析此类需求大概意思是：A", "页面进入", "B", "页面，B", "页面返回并传值给", "A或在B页面触发事件时，A页面也有事件触发改变。业务分析普遍方法为：", "第一种：利用微信的", "wx.setStorage，将数据缓存在小程序实例内。从", "B", "页面返回", "A", "页面时，B", "页面先将数据缓存；然后在", "A", "页面的", "onshow", "方法里，调用", "wx.getStorage", "读取缓存来实现。但为日后维护带来大量隐患。（用全局变量方法类似）第二种：获取前一个", "page", "实例的方法，也可以实现此功能。部分代码如下：var", "pages", "=", "getCurrentPages();var", "currPage", "=", "pages[pages.length", "-", "1];", "//当前页面var", "prevPage", "=", "pages[pages.length", "-", "2];", "//上一个页面//直接调用上一个页面的", "setData()", "方法，把数据存到上一个页面中去prevPage.setData({", "mdata:1", "})这种方法的弊端：因为进入", "B", "页面的入口可能是很多个。这样做，可能会导致获取到的页面实例不正确。二.方法介绍（onfire.js的下载地址https://github.com/hustcc/onfire.js）", "下面进入正题介绍onfire.js（）", "onfire.js", "是一个很简单的事件分发", "JavaScript", "库（仅仅", "0.9kb），简洁实用。它可以应用于:", "1.简单的事件分发。", "2.在", "React、Vue.js、Angular", "中用于跨组件的轻量级实现。", "3.事件订阅和发布。使用思路：（做过移动端开发的都知道，类似于iOS的通知和安卓的广播）", "a.A", "页面先订阅一个事件，并定义处理方法；", "b.从", "B", "页面返回时，发送消息；", "c.A", "页面卸载时，解除订阅。我的使用方法为：", "A", "页面代码：var", "onfire", "=", "require(\"../utils/onfire.js\");var", "that;var", "eventObj", "=", "onfire.on('key',", "function", "()", "{", "//", "当消息被传递时，做具体的事});Page({", "data:", "{", "},", "onLoad:", "function(options)", "{", "//", "Do", "some", "initialize", "when", "page", "load.", "},", "onReady:", "function()", "{", "//", "Do", "something", "when", "page", "ready.", "},", "onUnload:", "function", "(e)", "{", "onfire.un('key');", "onfire.un(eventObj);//移除", "}})我们可以在", "A", "页面直接调用", "onfire.on", "方法，订阅一个名字为", "key", "的消息。在上面的代码中，消息附带的参数无传参。", "如果需要传参的话，直接在", "function", "里增加参数即可，例如：var", "eventObj", "=", "onfire.on('key',", "function", "(data){", "//", "执行操作})需要注意的是，一定要在", "onUnload", "里（在页面被关闭时）取消订阅消息，并取消绑定", "eventObj。B", "页面里代码在回调的地方加入以下代码：onfire.fire('key');//key", "为上文中订阅的消息", "//", "有参数时", "onfire.fire('key','test');三.分析库代码function", "_bind(eventName,", "callback,", "is_one,", "context)", "{", "if", "(typeof", "eventName", "!==", "string_str", "||", "typeof", "callback", "!==", "function_str)", "{", "throw", "new", "Error('args:", "'+string_str+',", "'+function_str+'');", "}", "if", "(!", "hasOwnKey(__onfireEvents,", "eventName))", "{", "__onfireEvents[eventName]", "=", "{};", "}", "__onfireEvents[eventName][++__cnt]", "=", "[callback,", "is_one,", "context];", "return", "[eventName,", "__cnt];", "}从代码中可以看出订阅", "on", "方法的时候，实际调用", "_bind", "方法。该方法利用一个二维数组，来存储订阅的对象。", "function", "_fire_func(eventName,", "args)", "{", "if", "(hasOwnKey(__onfireEvents,", "eventName))", "{", "_each(__onfireEvents[eventName],", "function(key,", "item)", "{", "item[0].apply(item[2],", "args);", "//执行订阅时的方法", "if", "(item[1])", "delete", "__onfireEvents[eventName][key];", "//", "当类型为只订阅一次时，通知后即移除自己。", "});", "}", "}而", "fire", "发送消息方法的实质，是调用", "_fire_func", "方法，通过名字（key）来遍历订阅者，然后通知订阅者。function", "un(event)", "{", "var", "eventName,", "key,", "r", "=", "false,", "type", "=", "typeof", "event;", "if", "(type", "===", "string_str)", "{", "//", "如果存在key值，则移除数组", "if", "(hasOwnKey(__onfireEvents,", "event))", "{", "delete", "__onfireEvents[event];", "return", "true;", "}", "return", "false;", "}", "else", "if", "(type", "===", "'object')", "{", "eventName", "=", "event[0];", "key", "=", "event[1];", "//如果找到这个对象则卸载", "if", "(hasOwnKey(__onfireEvents,", "eventName)", "&&", "hasOwnKey(__onfireEvents[eventName],", "key))", "{", "delete", "__onfireEvents[eventName][key];", "return", "true;", "}", "//否则返回false", "return", "false;", "}", "else", "if", "(type", "===", "function_str)", "{", "//两层循环来判断方法名", "_each(__onfireEvents,", "function(key_1,", "item_1)", "{", "_each(item_1,", "function(key_2,", "item_2)", "{", "if", "(item_2[0]", "===", "event)", "{", "delete", "__onfireEvents[key_1][key_2];", "r", "=", "true;", "}", "});", "});", "return", "r;", "}", "return", "true;", "}调用un方法，通过名字（key）来遍历订阅者，找到后移除。注：因为卸载支持按", "key、对象、方法卸载，所以需要先判断类型，然后按各自规则去解除绑定。作者：honey缘木鱼"]}
{"author": "Rolan", "title": "微信小程序有旋转动画效果的音乐组件 ", "content": ["在微信开发中，写过的一个简单的音乐播放组件，记录下。music", "音乐播放组件。属性代码properties:", "{", "//", "音乐路径", "music:", "{", "type:", "String,", "value:", "'',", "observer:", "function", "(newVal)", "{", "this._initMusic(newVal)", "}", "},", "//", "样式", "musicStyle:", "{", "type:", "String,", "value:", "'position:", "absolute;", "right:", "20rpx;", "top:", "20rpx;", "width:", "100rpx;", "height:", "100rpx;'", "},", "//", "播放时是否有旋转效果", "rotate:", "{", "type:", "Boolean,", "value:", "true", "},", "//", "播放时的icon路径", "iconOn:", "{", "type:", "String,", "value:", "'/resources/img/music-on.png'", "//", "请填写默认的图片地址", "},", "//", "暂停时的icon路径", "iconOff:", "{", "type:", "String,", "value:", "'/resources/img/music-off.png'", "//", "请填写默认的图片地址", "}", "}初始化音乐首先，在properties中接收页面传来的音乐文件地址，music:", "{", "type:", "String,", "value:", "'',", "observer:", "function", "(newVal)", "{", "this._initMusic(newVal)", "}}这里的处理是，一旦接收到页面传来的", "music", "地址，就初始化音乐：_initMusic:", "function", "(newVal)", "{", "//", "当页面传来新的music时，先销毁之前的audioCtx，否则页面会很嗨", "if", "(this.data.audioCtx)", "{", "this.data.audioCtx.destroy()", "}", "if", "(newVal)", "{", "var", "audioCtx", "=", "wx.createInnerAudioContext()", "this.setData({", "audioCtx:", "audioCtx", "})", "if", "(this.data.audioStatus", "==", "'1')", "{", "audioCtx.autoplay", "=", "true", "}", "audioCtx.loop", "=", "true", "audioCtx.src", "=", "newVal", "}}audioStatus", "用来记录音乐播放状态，在data中默认设置为1：data:", "{", "icon:", "'',", "audioStatus:", "1,", "audioCtx:", "'',", "musicClass:", "'music-on'}wxml文件里，只用一个", "标签：<image", "class='music", "{{", "rotate", "&&", "musicClass", "}}'", "style=\"{{", "musicStyle", "}}\"", "src=\"{{", "icon", "}}\"", "bindtap='_switch'", "wx:if=\"{{", "music", "}}\"></image>其中，", "icon", "在组件ready()时赋值成播放状态的icon：ready()", "{", "this.setData({", "icon:", "this.data.iconOn", "})}音乐旋转效果音乐播放时的旋转效果，是用css动画实现的，wxss文件如下：.music", "{", "position:", "absolute;", "z-index:", "99;", "-webkit-animation-iteration-count:", "infinite;}/*", "旋转class", "*/.music-on", "{", "animation:", "music-rotate", "4s", "linear", "infinite;}/*", "旋转动画", "*/@keyframes", "music-rotate", "{", "0%", "{", "transform:", "rotateZ(0deg);", "}", "100%", "{", "transform:", "rotateZ(360deg);", "}}当", "rotate", "为true时，使", "musicClass", "的值为", "music-on，就能实现旋转了。当然，", "musicClass", "需要用", "this.setData", "的方式来切换值。爆丑照：音乐控制手动切换手动点击时，用取反的逻辑控制音乐的播放和暂停：_switch:", "function", "()", "{", "//", "如果是播放就停止", "if", "(this.data.audioStatus)", "{", "this.setData({", "audioStatus:", "0,", "icon:", "this.data.iconOff,", "musicClass:", "''", "})", "this.data.audioCtx.pause()", "//", "如果是停止就播放", "}", "else", "{", "this.setData({", "audioStatus:", "1,", "icon:", "this.data.iconOn,", "musicClass:", "'music-on'", "})", "this.data.audioCtx.play()", "}}其它情况同时，还要对下列情况做处理：分享时，进入选好友界面、音乐停止，分享回来后，音乐没有继续播放", "从此页面跳转到下一个页面时，音乐还在继续", "从此页面撤回到上一个页面时，音乐还在继续", "解决的方法，是在组件的methods中又写了两个方法：//", "写在组件的methods中：//", "在引用组件页面的onShow()中调用//", "否则，如果当发生分享页面行为并返回时，音乐不会自动播放onShow:", "function", "()", "{", "if", "(this.data.music", "&&", "this.data.audioStatus)", "{", "this.data.audioCtx.play()", "}},//", "在引用组件页面的onHide()中调用//", "否则，在跳转到下一个页面后，音乐还在继续onHide:", "function", "()", "{", "if", "(this.data.music", "&&", "this.data.audioStatus)", "{", "this.data.audioCtx.pause()", "}", "this.setData({", "animationData:", "{}", "})}这两个方法分别在页面中的", "onShow", "和", "onHide", "中调用，调用方式就是父组件获取到子组件实例对象：例如，给组件加id为\"music-componet\"，调用时就是：//", "写在调用页面中onShow:", "function", "()", "{", "this.selectComponent('#music-component').onShow()},onHide:", "function", "()", "{", "this.selectComponent('#music-component').onHide()}最后，在组件的detached中也调用一下", "onHide", "方法：//", "页面关闭时销毁音乐detached()", "{", "this.onHide()}使用", "你可以通过阅读本文，根据自身实际情况写一个", "或者，直接凑合用"]}
{"author": "Rolan", "title": "关于mpvue的几个点 ", "content": ["微信小程序的框架众多，而现在我只想记录一下mpvue的几个点...祝你采坑成功。微信小程序在语法规范、API、组件外，因为多了个可组件化component，主要点始终落在app.json、app.wxss、app.js和每个页面和组件的配置上，都是相似雷同的事情，详情移步官方文档相对而已，mpvue是在vue基础上加入了微信小程序的支持，在loader和编译方面多做支持，编码规范以vue为标准。使用现在已vue-cli生成mpvue/mpvue-quickstart模板深入相对于原生小程序，mpvue在代码目录主要维护:App.vue:", "作为小程序的创建点和挂载点main.jsapp.jsonvue模型的组件页配置每页导航栏信息找到每页的的main.js,添加export", "default对应内容import", "Vue", "from", "'vue'", "import", "App", "from", "'./index'", "const", "app", "=", "new", "Vue(App)", "app.$mount()", "export", "default", "{", "config:", "{", "\"navigationBarBackgroundColor\":", "\"#ffffff\",", "\"navigationBarTextStyle\":", "\"black\",", "\"navigationBarTitleText\":", "\"微信接口功能演示\",", "\"backgroundColor\":", "\"#eeeeee\",", "\"backgroundTextStyle\":", "\"light\"", "}", "}", "网上说这是设置每页navigation内容和状态的方法，亲试不行暂时可以替代的方法：wx.setNavigationBarTitle({", "title:", "'关卡'", "})", "FAQS报错mpvue", "未找到入口", "app.json", "文件正常情况：npm", "run", "dev执行一下mpvue的编译在dist目录下会自动产生一个app.json题外话：安装依赖包的时候或者npm", "run", "dev的时候提示缺少依赖的话，直接把node_modules", "下面的文件全部删掉，然后重新npm", "intall", "简单粗暴解决问题分析：", "因为缺乏依赖而没自动生成app.json解决之道：", "只需要把packpage.json里的mpvue-loade后面的‘^’去掉，重新安装依赖即可。npm", "install", "npm", "run", "dev", "npm", "run", "dev", "无法编译成功情况如下：$", "npm", "run", "dev", ">", "color-life@1.0.0", "dev", "/home/happy/Dev/coding/color-life", ">", "node", "build/dev-server.js", "尝试如下也无法解决：1.npm", "run", "dev不行", "2.删除module重装也不行", "3.重新初始化项目也不行", "这主要是编译时遇到代码缺失解决：如果有组件只有纯template，加上即可：<script>", "export", "default", "{}", "</script>", "v-show使用失效分析v-show的特点：v-show只能简单的切换元素的css属性", "display不支持", "<template>", "元素不支持", "v-else使用v-show时，很容易将v-show直接下载创建的组件上，如<template>", "<components", "v-show=\"isShow\"></components>", "</template>", "因此组件的显隐状态无法根据isShow响应状态解决：只需要在组件外包括一层元素进行控制<template>", "<div", "v-show=\"isShow\">", "<components></components>", "</div>", "</template>", "科普：v-if直接是创建-销毁组件"]}
{"author": "Rolan", "title": "在小程序中集成redux/immutable/thunk第三方库 ", "content": ["小程序给我们暴露了两个参数", "require", "和", "module", "，", "require", "用来在模块中加载其他模块，module", "用来将模块中的方法暴露出去module.exports", "=", "function(){}", "所以只要需要让第三方库的代码使用这种形式的", "export", "就可以了二、构建Redux的微信小程序包打一个", "Redux", "包，让它可以兼容微信小城的加载方式git", "clone", "https://github.com/reactjs/redux.git", "npm", "install", "#", "详细内容可以到redux项目的package.json中查看", "#", "这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到", "npm", "run", "build:umd", "&&", "npm", "run", "build:umd", "用编辑器打开", "dist", "目录下的", "redux.js", "文件(function", "webpackUniversalModuleDefinition(root,", "factory)", "{", "if(typeof", "exports", "===", "'object'", "&&", "typeof", "module", "===", "'object')", "module.exports", "=", "factory();", "else", "if(typeof", "define", "===", "'function'", "&&", "define.amd)", "define([],", "factory);", "else", "if(typeof", "exports", "===", "'object')", "exports[\"Redux\"]", "=", "factory();", "else", "root[\"Redux\"]", "=", "factory();", "})(this,", "function()", "{", "...", "})", "这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来将第二行代码：", "if(typeof", "exports", "===", "'object'", "&&", "typeof", "module", "===", "'object')", "修改成：", "if(typeof", "module", "===", "'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入我们拷贝到", "libs", "目录下，那么我们在程序中使用时，只要当做是一个本地模块去", "require就可以了", "var", "redux", "=", "require('./libs/redux.js')我们可以通过类似的方法，使用", "Webpack", "打包第三方库，就可以集成任何库了三、集成Redux-devtools因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装", "redux-devtool", "的插件安装remote-redux-devtools原版的", "remote-redux-devtools", "使用的一个", "websocket", "的依赖会使用原生的", "WebSocket", "，小程序是不支持的，所以需要改成小程序的", "websocket", "实现,修改好的代码", "https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/remote-redux-devtools.js把代码下载到工程目录里面就可以用了安装和启动remotedev-servernpm", "install", "-g", "remotedev-server", "remotedev", "--hostname=localhost", "--port=5678", "因为没办法用", "npm", "安装到本地（微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动", "remotedev-server", "，", "hostname", "和", "port", "分别指定为", "localhost和", "5678集成devtool在", "store", "下集成", "devtoolconst", "{createStore,", "compose}", "=", "require('./libs/redux.js');", "const", "devTools", "=", "require('./libs/remote-redux-devtools.js').default;", "const", "reducer", "=", "require('./reducers/index.js')", "function", "configureStore()", "{", "return", "createStore(reducer,", "compose(devTools({", "hostname:", "'localhost',", "port:", "5678,", "secure:", "false", "})));", "}", "module.exports", "=", "configureStore;", "把", "devtool", "使用", "redux", "的", "compose", "加到", "store", "中去。", "hostname", "和", "port", "是指定为之前启动", "remotedev-server", "启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了可以在浏览器中访问", "localhost:5678四、小程序中集成immutableImmutable", "是", "Facebook", "开发的不可变数据集合。不可变数据一旦创建就不能被修改，是的应用开发更简单，允许使用函数式编程技术，比如惰性评估。微信小程序无法直接使用", "Immutable.js", "，下面就来说说微信小程序如何使用第三方库", "Immutable.jsImmutable使用了UMD模块化规范(function", "(global,", "factory)", "{", "typeof", "exports", "===", "'object'", "&&", "typeof", "module", "!==", "'undefined'", "?", "module.exports", "=", "factory()", ":", "typeof", "define", "===", "'function'", "&&", "define.amd", "?", "define(factory)", ":", "(global.Immutable", "=", "factory());", "}(this,", "function", "()", "{", "'use", "strict';var", "SLICE$0", "=", "Array.prototype.slice;", "....", "}));", "修改", "Immutable", "代码，注释原有模块导出语句，使用", "module.exports", "=", "factory()", "强制导出(function(global,", "factory)", "{", "/*", "typeof", "exports", "===", "'object'", "&&", "typeof", "module", "!==", "'undefined'", "?", "module.exports", "=", "factory()", ":", "typeof", "define", "===", "'function'", "&&", "define.amd", "?", "define(factory)", ":", "(global.Immutable", "=", "factory());", "*/", "module.exports", "=", "factory();", "}(this,", "function()", "{", "导入修改好的", "immutable", "到小程序中即可", "https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/immutable.js"]}
{"author": "Rolan", "title": "学了这么久，vue和微信小程序到底有什么样的区别？ ", "content": ["写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。相比之下，小程序的钩子函数要简单得多。写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。一、生命周期先贴两张图：vue生命周期小程序生命周期相比之下，小程序的钩子函数要简单得多。vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。onLoad:", "页面加载一个页面只会调用一次，可以在", "onLoad", "中获取打开当前页面所调用的", "query", "参数。onShow:", "页面显示每次打开页面都会调用一次。onReady:", "页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期onHide:", "页面隐藏当navigateTo或底部tab切换时调用。onUnload:", "页面卸载当redirectTo或navigateBack的时候调用。数据请求在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。二、数据绑定VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：1.", "<img", ":src=\"imgSrc\"/>", "复制代码小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：1.", "<image", "src=\"{{imgSrc}}\"></image>", "复制代码三、列表渲染直接贴代码，两者还是有些相似vue：1.", "<ul", "id=\"example-1\">", "2.", "<li", "v-for=\"item", "in", "items\">", "3.", "{{", "item.message", "}}", "4.", "</li>", "5.", "</ul>", "7.", "var", "example1", "=", "new", "Vue({", "8.", "el:", "'#example-1',", "9.", "data:", "{", "10.", "items:", "[", "11.", "{", "message:", "'Foo'", "},", "12.", "{", "message:", "'Bar'", "}", "13.", "]", "14.", "}", "15.", "})", "复制代码小程序：1.", "Page({", "2.", "data:", "{", "3.", "items:", "[", "4.", "{", "message:", "'Foo'", "},", "5.", "{", "message:", "'Bar'", "}", "6.", "]", "7.", "}", "8.", "})", "10.", "<text", "wx:for=\"{{items}}\">{{item}}</text>", "复制代码四、显示与隐藏元素vue中，使用v-if", "和v-show控制元素的显示和隐藏小程序中，使用wx-if和hidden控制元素的显示和隐藏五、事件处理vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:1.", "<button", "v-on:click=\"counter", "+=", "1\">Add", "1</button>", "2.", "<button", "v-on:click.stop=\"counter+=1\">Add1</button>", "//阻止事件冒泡", "复制代码小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：1.", "<button", "bindtap=\"noWork\">明天不上班</button>", "2.", "<button", "catchtap=\"noWork\">明天不上班</button>", "//阻止事件冒泡", "复制代码六、数据双向绑定1.设置值在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。1.", "<div", "id=\"app\">", "2.", "<input", "v-model=\"reason\"", "placeholder=\"填写理由\"", "class='reason'/>", "3.", "</div>", "5.", "new", "Vue({", "6.", "el:", "'#app',", "7.", "data:", "{", "8.", "reason:''", "9.", "}", "10.", "})", "复制代码但是在小程序中，却没有这个功能。那怎么办呢？当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。下面是代码，可以感受一下:1.", "<input", "bindinput=\"bindReason\"", "placeholder=\"填写理由\"", "class='reason'", "value='{{reason}}'", "name=\"reason\"", "/>", "2.", "Page({", "3.", "data:{", "4.", "reason:''", "5.", "},", "6.", "bindReason(e)", "{", "7.", "this.setData({", "8.", "reason:", "e.detail.value", "9.", "})", "10.", "}", "11.", "})", "复制代码当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。2.取值vue中，通过this.reason取值小程序中，通过this.data.reason取值七、绑定事件传参在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：1.", "<button", "@click=\"say('明天不上班')\"></button>", "2.", "new", "Vue({", "3.", "el:", "'#app',", "4.", "methods:{", "5.", "say(arg){", "6.", "consloe.log(arg)", "7.", "}", "8.", "}", "9.", "})", "复制代码在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有...1.", "<view", "class='tr'", "bindtap='toApprove'", "data-id=\"{{item.id}}\"></view>", "2.", "Page({", "3.", "data:{", "4.", "reason:''", "5.", "},", "6.", "toApprove(e)", "{", "7.", "let", "id", "=", "e.currentTarget.dataset.id;", "8.", "}", "9.", "})", "复制代码八、父子组件通信1.子组件的使用在vue中，需要：编写子组件在需要使用的父组件中通过import引入在vue的components中注册在模板中使用1.", "//子组件", "bar.vue", "2.", "<template>", "3.", "<div", "class=\"search-box\">", "4.", "<div", "@click=\"say\"", ":title=\"title\"", "class=\"icon-dismiss\"></div>", "5.", "</div>", "6.", "</template>", "7.", "<script>", "8.", "export", "default{", "9.", "props:{", "10.", "title:{", "11.", "type:String,", "12.", "default:''", "13.", "}", "14.", "}", "15.", "},", "17.", "methods:{", "18.", "say(){", "19.", "console.log('明天不上班');", "20.", "this.$emit('helloWorld')", "21.", "}", "22.", "}", "23.", "</script>", "25.", "//", "父组件", "foo.vue", "26.", "<template>", "27.", "<div", "class=\"container\">", "28.", "<bar", ":title=\"title\"", "@helloWorld=\"helloWorld\"></bar>", "29.", "</div>", "30.", "</template>", "32.", "<script>", "33.", "import", "Bar", "from", "'./bar.vue'", "34.", "export", "default{", "35.", "data:{", "36.", "title:\"我是标题\"", "37.", "},", "38.", "methods:{", "39.", "helloWorld(){", "40.", "console.log('我接收到子组件传递的事件了')", "41.", "}", "42.", "},", "43.", "components:{", "44.", "Bar", "45.", "}", "46.", "</script>", "复制代码在小程序中，需要：1.编写子组件2.", "在子组件的json文件中，将该文件声明为组件1.", "{", "2.", "\"component\":", "true", "3.", "}", "复制代码3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径1.", "\"usingComponents\":", "{", "2.", "\"tab-bar\":", "\"../../components/tabBar/tabBar\"", "3.", "}", "复制代码4.在父组件中，直接引入即可1.", "<tab-bar", "currentpage=\"index\"></tab-bar>", "复制代码具体代码:1.", "//", "子组件", "2.", "<!--components/tabBar/tabBar.wxml-->", "3.", "<view", "class='tabbar-wrapper'>", "4.", "<view", "class='left-bar", "{{currentpage===\"index\"?\"active\":\"\"}}'", "bindtap='jumpToIndex'>", "5.", "<text", "class='iconfont", "icon-shouye'></text>", "6.", "<view>首页</view>", "7.", "</view>", "8.", "<view", "class='right-bar", "{{currentpage===\"setting\"?\"active\":\"\"}}'", "bindtap='jumpToSetting'>", "9.", "<text", "class='iconfont", "icon-shezhi'></text>", "10.", "<view>设置</view>", "11.", "</view>", "12.", "</view>", "复制代码2.父子组件间通信在vue中父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例:1.", "//", "父组件", "foo.vue", "2.", "<template>", "3.", "<div", "class=\"container\">", "4.", "<bar", ":title=\"title\"></bar>", "5.", "</div>", "6.", "</template>", "7.", "<script>", "8.", "import", "Bar", "from", "'./bar.vue'", "9.", "export", "default{", "10.", "data:{", "11.", "title:\"我是标题\"", "12.", "},", "13.", "components:{", "14.", "Bar", "15.", "}", "16.", "</script>", "18.", "//", "子组件bar.vue", "19.", "<template>", "20.", "<div", "class=\"search-box\">", "21.", "<div", ":title=\"title\"", "></div>", "22.", "</div>", "23.", "</template>", "24.", "<script>", "25.", "export", "default{", "26.", "props:{", "27.", "title:{", "28.", "type:String,", "29.", "default:''", "30.", "}", "31.", "}", "32.", "}", "33.", "</script>", "复制代码子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。在小程序中父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：1.", "<tab-bar", "currentpage=\"index\"></tab-bar>", "复制代码此处，", "“index”就是要向子组件传递的值在子组件properties中，接收传递的值1.", "properties:", "{", "2.", "//", "弹窗标题", "3.", "currentpage:", "{", "//", "属性名", "4.", "type:", "String,", "//", "类型（必填），目前接受的类型包括：String,", "Number,", "Boolean,", "Object,", "Array,", "null（表示任意类型）", "5.", "value:", "'index'", "//", "属性初始值（可选），如果未指定则会根据类型选择一个", "6.", "}", "7.", "}", "复制代码子组件向父组件通信和vue也很类似，代码如下:1.", "//子组件中", "2.", "methods:", "{", "3.", "//", "传递给父组件", "4.", "cancelBut:", "function", "(e)", "{", "5.", "var", "that", "=", "this;", "6.", "var", "myEventDetail", "=", "{", "pickerShow:", "false,", "type:", "'cancel'", "}", "//", "detail对象，提供给事件监听函数", "7.", "this.triggerEvent('myevent',", "myEventDetail)", "//myevent自定义名称事件，父组件中使用", "8.", "},", "9.", "}", "10.", "//父组件中", "11.", "<bar", "bind:myevent=\"toggleToast\"></bar>", "12.", "//", "获取子组件信息", "13.", "toggleToast(e){", "14.", "console.log(e.detail)", "15.", "}", "复制代码如果父组件想要调用子组件的方法vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：1.", "//子组件", "2.", "<bar", "ref=\"bar\"></bar>", "3.", "//父组件", "4.", "this.$ref.bar.子组件的方法", "复制代码小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：1.", "//子组件", "2.", "<bar", "id=\"bar\"></bar>", "3.", "//", "父组件", "4.", "this.selectComponent('#id').syaHello()", "复制代码小程序和vue在这点上太相似了，有木有。。。九、废话还有好多地方没写，之后再慢慢加上、精简。感觉自己写的有点冗余，大佬勿喷！！！原来地址：", "https://segmentfault.com/a/1190000015684864"]}
{"author": "Rolan", "title": "小程序 textarea组件层级过高导致文字穿透浮层的一个解决方法 ... ... ", "content": ["最近做的一个小程序需求，其中一个页面使用到了", "textarea这个小程序组件，然后点击页面上的某个元素，会触发页面弹起一个弹窗，这时发现", "textarea的", "placeholder文字或者输入的文字内容，会直接穿透遮罩层和浮动弹窗，显示在最上面，开始时我以为是遮罩层和浮动弹窗的层级舍得小了，于是改大，谁知道没用，改到了", "99999也没用，于是我意识到这应该不是我代码的问题，网上一搜，果然有故事。", "解决方案", "隐藏", "textarea", "这是最简单的解决手段，一般弹窗的时候，都会带个遮罩层，把遮罩层下面的内容隐藏一部分，用户基本上不会注意的，然后再去掉弹窗和遮罩层的时候再把", "textarea显示出来。", "这种方法简单有效，大部分情况下都可以这么解决。", "<textarea", "wx:if=\"{{", "showMask", "}}\">textarea>", "复制代码", "使用替代元素", "有时候，", "textarea穿透的不是遮罩层，或者遮罩层以一种半透明而非完全遮住页面内容的形式呈现，担心用户能够看到因为", "textarea的消失而导致页面跳动，产生不好的用户体验，那么就可以使用替代元素来替代", "textarea而非将之直接隐藏掉。", "基本的", "textarea组件只接受文本的输入，抛开可输入性的话，外观上看就是一个含有文本节点的简单元素，只需要获取当前状态下的", "textarea中输入的文字，将之赋予给一个样式与", "textarea相同的普通元素，就达到了临时替代的效果。", "<textarea", "id=\"text-area\"", "value=\"{{txtRealContent}}\"", "bindinput='txtInput'", "wx:if=\"{{!showMask}}\"", "/>", "<view", "class='rich-text'", "style=\"{{('height:'", "+", "txtHeight", "+", "'px')}}\"", "wx:else>", "<rich-text", "nodes=\"{{txtRealContent}}\">rich-text>", "view>", "复制代码如上所示", "由于需要实时获取", "textarea中已经输入的内容，所以给", "textarea元素加了个", "bindinput的监听器", "showMask用于标识是否显示遮罩层(或者其他可能会被", "textarea穿透的浮动元素)，如果显示遮罩层，则隐藏", "textarea元素，并显示替代原宿", "这里", "textarea的隐藏使用了", "wx:if，会使其彻底地从页面中消失，而重新显示出来的时候，textarea元素会重新创建，丢失原先输入，所以给其加了个", "value属性，其值", "txtRealContent就是缓存的", "textarea已经输入的文本内容；如果你不用这种方法，不让", "textarea完全显示，而仅仅是隐藏，例如使用", "hidden=\"{{", "showMask", "?", "true", ":false", "}}\"，因为不涉及到", "textarea的删除与重建，所以就无需添加", "value属性来控制文本内容了。", "textarea是可以输入可换行的文本内容的，所以这里使用了", "rich-text组件，在使用的时候，我发现", "rich-text好像不支持溢出隐藏，所以又额外在其外面包了一层", "view组件，并将其高度设置为和", "textarea相同", "上面四个步骤，都比较简单，稍微需要注意的是，如果", "textarea的内容包含了换行文本，则需要对换行符进行处理：", "textareaContent.replace(/\\n/g,", "'')", "复制代码如果你想让", "textarea自动增加高度而不是固定高度，给", "textarea加了个", "auto-height，那么就需要“实时”获取其高度", "说是", "“实时”，其实也并不是那么实时，不考虑其他样式的变化，", "textarea的高度与行数有关，每增减一行，其高度才会变化，所以只需要监控其内容行数的变化即可，恰好", "textarea组件也已经提供了这个监控器：bindlinechange。", "原理说完了，完整实例代码如下：", "index.wxml", "<view", "class=\"page-body\">", "<button", "bindtap=\"changeMaskVisible\">切换maskbutton>", "<view", "class=\"textarea-wrp\">", "<textarea", "id=\"text-area\"", "value=\"{{txtContent}}\"", "bindinput='txtInput'", "bindlinechange=\"textAreaLineChange\"", "wx:if=\"{{!showMask}}\"", "auto-height", "/>", "<view", "class='rich-text'", "style=\"{{('height:'", "+", "txtHeight", "+", "'px')}}\"", "wx:else>", "<rich-text", "nodes=\"{{txtRealContent}}\">rich-text>", "view>", "view>", "<button>Footerbutton>", "<view", "wx:if=\"{{showMask}}\"", "bindtap=\"changeMaskVisible\"", "class=\"mask\">", "<view", "class=\"mask-content\">view>", "view>", "view>", "复制代码index.js", "Page({", "data:", "{", "txtRealContent:", "'',", "txtContent:", "'',", "showMask:", "false,", "txtHeight:", "0", "},", "textAreaLineChange(e)", "{", "this.setData({", "txtHeight:", "e.detail.height", "})", "},", "txtInput(e)", "{", "this.setData({", "txtContent:", "e.detail.value", "})", "},", "changeMaskVisible(e)", "{", "if", "(!this.data.showMask)", "{", "//", "将换行符转换为wxml可识别的换行元素", "const", "txtRealContent", "=", "this.data.txtContent.replace(/\\n/g,", "'')", "this.setData({", "txtRealContent", "})", "}", "this.setData({", "showMask:", "!this.data.showMask", "})", "}", "})", "复制代码index.wxss", ".rich-text", "{", "overflow:", "hidden;", "}", ".mask", "{", "position:", "fixed;", "top:", "0;", "right:", "0;", "bottom:", "0;", "left:", "0;", "background-color:", "rgba(0,", "0,", "0,", ".6);", "z-index:", "10;", "}", ".mask-content", "{", "position:", "fixed;", "top:", "44%;", "left:", "50%;", "height:", "60%;", "width:", "60%;", "transform:", "translate(-50%,", "-50%);", "background-color:", "yellowgreen;", "z-index:", "12;", "}作者：清夜链接：https://juejin.im/post/5b6ab1f951882539766ea558"]}
{"author": "Rolan", "title": "微信小程序实现常见的user效果 ", "content": ["用户个人页面", "为了便于以后的使用，所以把这个效果记录下来，以后直接复制粘贴本篇的代码。wxml<view", "class='circle'>", "<view", "class='userAvatar'>", "<open-data", "type=\"userAvatarUrl\"", "></open-data>", "</view>", "</view>代码说明：", "open-data没有办法直接给一个class然后控制类名，但是可以通过控制外部盒子达到控制它本身的大小以及形状的目的。wxss.circle{", "width:930rpx;", "height:930rpx;", "border-radius:465rpx;", "background-color:#2ca6cb;", "margin-top:-666rpx;", "margin-left:-90rpx;", "display:flex;", "align-items:center;", "flex-direction:column-reverse;}.userAvatar{", "width:80px;", "height:80px;", "border-radius:40px;", "margin-bottom:-30px;", "overflow:", "hidden;}说明：通过flex布局控制头像的位置。作者：王月_92f2", "链接：https://www.jianshu.com/p/b2fd8ae61660"]}
{"author": "Rolan", "title": "小程序各种姿势实现登录 ", "content": ["喜闻乐见的背景时间--由于最近接触小程序比较多，又刚好经历过小程序的自动登录时代以及现在的点击登录时代。结合自己的实践以及观察到其他小程序的做法，就有了这篇小分享~本文可能涉及的内容--本文的小程序登录指的是什么？在本篇文章所讲的登录不仅仅指的是wx.login而是包括以下三点--获取用户基本信息调用微信wx.login接口实现服务器端登录我需要获取用户头像和昵称要怎么做？用户头像和昵称对于我们开发小程序几乎算是刚需，那么我们应该怎么样正确高效的获取&利用它们呢？旧时代--自动授权一把梭新时代--使用小程序的open-data使用open-data时需要注意小程序基础库的版本。具体使用方式如下其实可以将open-data看作图片或字符串，想要控制样式在外层加上view标签以及相应的class即可。相比之前获取用户基本信息的方式，这个方案还是比较走心的，如果一些小程序只是对用户的头像昵称等基本信息有需求的话就不需要和以前一样大费周章的调一个getUserInfo，拿回来一堆用不上的东西。我需要用户在服务器端实现登录该怎么做？按照微信小程序的文档，能在服务器端完成登录（获取用户session_key/openid等），有三个前端传回的参数是必不可少的：codeencryptedDataivcode是通过wx.login获取的，而encryptedData", "&", "iv是从wx.getUserInfo中获取的。但是，因为微信基础库更新，取消通过api调用getUserInfo的能力，需要使用button组件的开放能力[open-type]去调用getUserInfo方法。上述获取数据的方法具体建议阅读官方文档：有关getUserInfo的文档有关login的文档踩坑心得：请确保wx.login早于getUserInfo，不仅是代码执行层面的早，最好是login回调成功之后才去getUserInfo，不然可能会出现后端解密失败的情况，导致登录失败。（还可以通过API方式调用getUserInfo的时候如何实现后端登录就不在此赘述了。）尽管已经无法自动授权，我们还可以这样实现小程序的登录授权总体来说有两种授权模式，一种是强制授权，另一种则是按需授权，无论是怎么样的流程基本都可以归类为这两种授权。强制授权适用范围：对用户身份强依赖的小程序，用户一进来就必须要知道用户的相关信息，或者是用户一进来就必须根据用户id来拉取相关资源。授权模式：模式多种，但共同特点都是会打断用户正常进入小程序的流程，体验上有点瑕疵，在此列出两种模式：不跳转页面，无论点击页面中的任何地方都会弹出授权弹窗，如图所示(没有将鼠标点击录进去，实际是无论点哪都会触发授权)↓↓这种方案的实现方式其实很简单也很粗暴--将一个覆盖全屏的button组件以position:", "fixed的方式盖在需要这样登录的页面上，然后将其opacity设为0即可。跳转页面，检测到非登录用户则强制跳转到登录页，在里面进行登录逻辑的处理。就个人而言，还是比较喜欢这种授权模式的，和微信自己生态内的授权有些许相似，对用户来说不会那么突兀。具体实现方式--相比上一种就复杂一些了，这一种方式属于全局性质的拦截授权，会中断当前页面的所有动作，跳转至登录专用的页面，在登录页登录成功后再返回原页面。按需授权适用范围：对用户身份规划十分明确、可以接受在用户做出某些动作之后再获取用户身份的小程序。授权模式：不会打断小程序页面的主流程，将授权加入主流程中。实现方式也是十分灵活，无论是列表或是图片甚至是一段文字，只要是需要用户手动触发的，都可以作为授权的发起时机。与上述强制授权中不跳转页面的方式类似，但是有一个巨大的差异--这种方式不会强制用户授权，而是在需要授权时才会出现，相对没有这么骚扰使用小程序的用户。"]}
{"author": "Rolan", "title": "微信小程序之如何使用自定义组件封装原生 image 组件 ", "content": ["零、问题的由来", "一般在前端展示图片时都会碰到这两个常见的需求：", "图片未加载完成时先展示占位图，等到图片加载完毕后再展示实际的图片。", "假如图片链接有问题（比如", "404），依然展示占位图。甚至你还可以增加点击图片再次加载的功能。（例如知乎）", "然鹅，小程序原生组件", "image", "并没有提供这些常用功能...", "注：这里加了", "2s", "的延迟", "一、常规操作", "在小程序没还没推出自定义组件功能时，只能通过改变", "Page", "中的", "data", "来展示兜底的占位图，所以当时的处理方式十分蛋疼...", "1.1.相同默认图", "由于需要知道这个图片的数据路径，所以不得不在每个", "image", "上加上类似", "data-img-path", "的东西。", "<view", "wx:for=\"{{", "obj.arr", "}}\"", "wx:key=\"imgSrc\"", "wx:for-item=\"item\"", "wx:for-index=\"itemIdx\"", ">", "<image", "src=\"{{", "item.imgSrc", "}}\"", "binderror=\"onImageError\"", "data-img-path=\"obj.arr[{{", "itemIdx", "}}].imgSrc\"", "/>", "</view>", "复制代码const", "DEFAULT_IMG", "=", "'/assets/your_default_img'", "Page({", "data:", "{", "obj:", "{", "arr:", "[", "{", "imgSrc:", "'your_img1'", "},", "{", "imgSrc:", "'your_img2'", "},", "],", "},", "},", "onImageError", "({", "target:", "{", "dataset:", "{", "imgPath", "}", "},", "})", "{", "this.setData({", "[imgPath]:", "DEFAULT_IMG,", "})", "},", "})", "复制代码1.2.不同默认图", "如果默认图片不同呢？例如球员、球队和", "feed", "的默认图片一般都是不同的。", "那么一般只好再增加一个属性例如", "data-img-type", "来标识默认图的类型。", "<!--", "球队图", "-->", "<image", "...", "data-img-type=\"team\"", "/>", "<!--", "球员图", "-->", "<image", "...", "data-img-type=\"player\"", "/>", "复制代码const", "DEFAULT_IMG_MAP", "=", "{", "feed:", "'/assets/default_feed',", "team:", "'/assets/default_team',", "player:", "'/assets/default_player',", "}", "Page({", "data:", "{", "obj:", "{", "arr:", "[", "{", "imgSrc:", "'your_img1'", "},", "{", "imgSrc:", "'your_img2'", "},", "],", "},", "},", "onImageError", "({", "target:", "{", "dataset:", "{", "imgPath,", "imgType", "}", "},", "})", "{", "this.setData({", "[imgPath]:", "DEFAULT_IMG_MAP[imgType],", "})", "},", "})", "复制代码1.3.图片在模板中", "页面层级浅倒还好，如果跨模板了，那么模板就可能要用一个类似于", "pathPrefix", "的属性来传递模板数据的路径前缀。", "<!--", "球员排行模板", "pathPrefix:", "String", "playerList:", "Array", "...", "-->", "<template", "name=\"srPlayerRank\">", "<view", "wx:for=\"{{", "playerList", "}}\"", "wx:key=\"imgSrc\"", "wx:for-item=\"item\"", "wx:for-index=\"itemIdx\"", ">", "<image", "src=\"{{", "item.imgSrc", "}}\"", "binderror=\"onImageError\"", "data-img-type=\"player\"", "data-img-path=\"{{", "pathPrefix", "}}.playerList[{{", "itemIdx", "}}].imgSrc\"", "/>", "</view>", "</template>", "复制代码最后在失败回调里调用", "setData({", "[path]:", "DEFAULT_IMG", "})", "重新设置图片地址。", "就问你蛋不蛋疼？这一坨", "data-img-path=\"{{", "pathPrefix", "}}.playerList[{{", "itemIdx", "}}].imgSrc\"", "代码真让人无发可脱...", "二、自定义组件", "有了自定义组件后，用领袖【窃·格瓦拉】的话来说的话就是：“感觉好", "door", "了~”", "2.1.原生自定义组件", "原生写法一般要写4个文件：.json/.wxml/.js/.wxss", "TuaImage.json", "{", "\"component\":", "true", "}", "复制代码", "TuaImage.wxml", "<!--", "加载中的图片", "-->", "<image", "hidden=\"{{", "!isLoading", "}}\"", "src=\"{{", "errSrc", "}}\"", "style=\"width:", "{{", "width", "}};", "height:", "{{", "height", "}};", "{{", "styleStr", "}}\"", "mode=\"{{", "imgMode", "}}\"", "/>", "<!--", "实际加载的图片", "-->", "<image", "hidden=\"{{", "isLoading", "}}\"", "src=\"{{", "imgSrc", "||", "src", "}}\"", "mode=\"{{", "imgMode", "}}\"", "style=\"width:", "{{", "width", "}};", "height:", "{{", "height", "}};", "{{", "styleStr", "}}\"", "bindload=\"_onImageLoad\"", "binderror=\"_onImageError\"", "lazy-load=\"{{", "true", "}}\"", "/>", "复制代码", "TuaImage.js", "const", "DEFAULT_IMG", "=", "'/assets/your_default_img'", "Component({", "properties:", "{", "//", "图片地址", "src:", "String,", "//", "图片加载中，以及加载失败后的默认地址", "errSrc:", "{", "type:", "String,", "//", "默认是球队图标", "value:", "DEFAULT_IMG,", "},", "width:", "{", "type:", "String,", "value:", "'48rpx',", "},", "height:", "{", "type:", "String,", "value:", "'48rpx',", "},", "//", "样式字符串", "styleStr:", "{", "type:", "String,", "value:", "'',", "},", "//", "图片裁剪、缩放的模式（详见文档）", "imgMode:", "{", "type:", "String,", "value:", "'scaleToFill',", "},", "},", "data:", "{", "imgSrc:", "'',", "isLoading:", "true,", "},", "methods:", "{", "//", "加载图片出错", "_onImageError", "(e)", "{", "this.setData({", "imgSrc:", "this.data.errSrc,", "})", "this.triggerEvent('onImageError',", "e)", "},", "//", "加载图片完毕", "_onImageLoad", "(e)", "{", "this.setData({", "isLoading:", "false", "})", "this.triggerEvent('onImageLoad',", "e)", "},", "},", "})", "复制代码布吉岛大家使用原生写法时有木有一些感觉不方便的地方：", "4个文件：.json/.wxml/.js/.wxss，这样老需要切来切去的降低效率", "properties", "是什么鬼？大家（React/Vue）一般不都用", "props", "么？", "style=\"width:", "{{", "width", "}};", "height:", "{{", "height", "}};", "{{", "styleStr", "}}\"", "样式字符串怎么辣么长...", "2.2.TuaImage.vue", "所以以下是一个使用单文件组件封装原生", "image", "组件的例子。", "使用单文件组件将配置、模板、脚本、样式写在一个文件中，方便维护。", "使用计算属性", "computed", "将样式字符串写在", "js", "中。", "使用", "this.imgSrc", "=", "this.errSrc", "而不是", "this.setData", "来改变", "data。", "<config>", "{", "\"component\":", "true", "}", "</config>", "<template", "lang=\"wxml\">", "<!--", "加载中的图片", "-->", "<image", "hidden=\"{{", "!isLoading", "}}\"", "src=\"{{", "errSrc", "}}\"", "style=\"{{", "imgStyleStr", "}}\"", "mode=\"{{", "imgMode", "}}\"", "/>", "<!--", "实际加载的图片", "-->", "<image", "hidden=\"{{", "isLoading", "}}\"", "src=\"{{", "imgSrc", "||", "src", "}}\"", "mode=\"{{", "imgMode", "}}\"", "style=\"{{", "imgStyleStr", "}}\"", "bindload=\"_onImageLoad\"", "binderror=\"_onImageError\"", "lazy-load=\"{{", "true", "}}\"", "/>", "</template>", "<script>", "/**", "*", "图片组件，能够传递备用图片以防图片失效", "*", "https://developers.weixin.qq.com/miniprogram/dev/component/image.html", "*/", "//", "也可以设置为网络图片如：", "https://foo/bar.png", "const", "DEFAULT_IMG", "=", "'/assets/your_default_img'", "export", "default", "{", "props:", "{", "//", "图片地址", "src:", "String,", "//", "图片加载中，以及加载失败后的默认地址", "errSrc:", "{", "type:", "String,", "//", "默认是球队图标", "default:", "DEFAULT_IMG,", "},", "width:", "{", "type:", "String,", "default:", "'48rpx',", "},", "height:", "{", "type:", "String,", "default:", "'48rpx',", "},", "//", "样式字符串", "styleStr:", "{", "type:", "String,", "default:", "'',", "},", "//", "图片裁剪、缩放的模式（详见文档）", "imgMode:", "{", "type:", "String,", "default:", "'scaleToFill',", "},", "},", "data", "()", "{", "return", "{", "imgSrc:", "'',", "isLoading:", "true,", "}", "},", "computed:", "{", "//", "样式字符串", "imgStyleStr", "()", "{", "return", "`width:", "${this.width};", "height:", "${this.height};", "${this.styleStr}`", "},", "},", "methods:", "{", "//", "加载图片出错", "_onImageError", "(e)", "{", "this.imgSrc", "=", "this.errSrc", "this.$emit('onImageError',", "e)", "},", "//", "加载图片完毕", "_onImageLoad", "(e)", "{", "this.isLoading", "=", "false", "this.$emit('onImageLoad',", "e)", "},", "},", "}", "</script>", "<style", "lang=\"scss\">", "</style>", "复制代码采用框架是", "tua-mp：", "github", "源码地址", "相关文章：", "终极蛇皮上帝视角之微信小程序之告别", "setData", "终极蛇皮上帝视角之微信小程序之告别“刀耕火种”作者：佯真愚链接：https://juejin.im/post/5b70193c6fb9a0096a05e397"]}
{"author": "Rolan", "title": "小程序导航滚动到头部后固定 ", "content": ["小程序的导航写法及滑动后固定在头部,", "直接看效果图如果导航效果满足要求继续查看代码前段代码这里是比较重要的", "<scroll-view", "scroll-x=\"true\"", "class=\"nav", "{{navFixed?", "'positionFixed':''}}\"", "scroll-left=\"{{navScrollLeft}}\"", "scroll-with-animation=\"{{true}}\">", "<block", "wx:for=\"{{navData}}\"", "wx:for-index=\"idx\"", "wx:for-item=\"navItem\"", "wx:key=\"idx\">", "<view", "class=\"nav-item", "{{currentNavTab", "==", "idx", "?'active':''}}\"", "data-current=\"{{idx}}\"", "bindtap=\"switchNav\">{{navItem.text}}</view>", "</block>", "</scroll-view>前段整体布局要使用scroll-view<scroll-view", "class=\"layout\"", "bindscroll='layoutScroll'", "scroll-y=\"true\"", "style=\"height:", "{{windowHeight}}px;\">这里可以监听滑动的距离", "然后进行逻辑处理", "主要逻辑是判断滑动位置后来处理导航的", "class", "这个class", "就是定位属性.positionFixed{", "position:", "fixed;", "left:", "0;", "top:", "0;}data配置信息看好", "data:", "{", "adData:", "['http://pic.qiantucdn.com/58pic/17/70/72/02U58PICKVg_1024.jpg',", "'http://pic2.ooopic.com/12/09/64/46bOOOPICf5_1024.jpg'],", "navData:", "[", "{", "text:", "'首页'", "},", "{", "text:", "'健康'", "},", "{", "text:", "'情感'", "},", "{", "text:", "'职场'", "},", "{", "text:", "'育儿'", "},", "{", "text:", "'纠纷'", "},", "{", "text:", "'青葱'", "},", "{", "text:", "'上课'", "},", "{", "text:", "'下课'", "}", "],", "currentNavTab:", "0,", "scrollTop:", "'',", "//滑动的距离", "navFixed:", "false,", "//导航是否固定", "onLoad", "方法获取宽高wx.getSystemInfo({", "success:", "(res)", "=>", "{", "this.setData({", "pixelRatio:", "res.pixelRatio,", "windowHeight:", "res.windowHeight,", "windowWidth:", "res.windowWidth", "})", "},", "})js主要事件//导航点击", "switchNav(event)", "{", "var", "cur", "=", "event.currentTarget.dataset.current;", "//每个tab选项宽度占1/5", "var", "singleNavWidth", "=", "this.data.windowWidth", "/", "5;", "//tab选项居中", "this.setData({", "navScrollLeft:", "(cur", "-", "2)", "*", "singleNavWidth", "})", "if", "(this.data.currentNavTab", "==", "cur)", "{", "return", "false;", "}", "else", "{", "this.setData({", "currentNavTab:", "cur", "})", "}", "},", "//监听滑动", "layoutScroll:", "function", "(e)", "{", "this.data.scrollTop", "=", "this.data.scrollTop", "*", "1", "+", "e.detail.deltaY", "*", "1;", "console.log(this.data.scrollTop)", "console.log(this.data.navFixed)", "if", "(this.data.scrollTop", "<=", "-342)", "{", "this.setData({", "navFixed:", "true", "})", "}", "else", "{", "this.setData({", "navFixed:", "false", "})", "}", "}以上代码自己完善后即刻达到效果图", "方法不一欢迎讨论."]}
{"author": "Rolan", "title": "把微信小程序异步API为Promise，简化异步编程 ", "content": ["把微信小程序异步API转化为Promise。用Promise处理异步操作有多方便，谁用谁知道。微信官方没有给出Promise", "API来处理异步操作，而官方API异步的又非常多，这使得多异步编程会层层回调，代码一复杂，回调起来就想砸电脑。于是写了一个通用工具，把微信官方的异步API转化为Promise，方便处理（多）异步操作。你可以这样用：准备转化后的方法并暴露出//", "/utils/wx-promise.js", "import", "toPromise", "from", "'/module/to-promise/src/index'", "const", "toPromiseWx", "=", "toPromsie(wx)", "export", "const", "request", "=", "toPromiseWx('requset')", "export", "const", "getLocation", "=", "toPromiseWx('getLocation')", "export", "const", "setStorage", "=", "toPromiseWx('setStorage')", "//export", "其他你项目中可能用到的异步API在其他文件中使用在App.js中使用：//App.js", "import", "{", "request", "}", "from", "'./utils/wx-promise.js'", "App({", "onLanuch:", "()", "=>", "{", "request({", "url:", "'http://api.yourapi.com'", "})", ".then(()", "=>", "{", "//成功后处理", "})", ".then(()", "=>", "{", "//失败后处理", "})", "}", "})在其他page中使用：//", "/page/index.js", "import", "{", "request,", "setStorage", "}", "from", "'../utils/wx-promise.js'", "page({", "onLoad:", "()", "=>", "{", "request({", "url:", "'http://api.yourapi.com'", "})", ".then(()", "=>", "{", "//成功后处理", "})", ".then(()", "=>", "{", "//失败后处理", "})", "},", "onHide:", "()", "=>", "{", "setStorage({", "key:", "'yourkey',", "data:", "'yourvalue'", "})", ".then(()", "=>", "{", "//保存成功", "})", ".then(()", "=>", "{", "//保存失败", "})", "}", "})项目地址：to-promise其他更多更具体用法，直接粘贴README了，如下。to-promise是一个转换微信小程序异步API为Promise的一个工具库优点：避免小程序异步编程多次回调带来的过多回调导致逻辑不清晰，篇幅过长等问题。借助于Promise异步编程特点，支持链式操作，像同步一样写异步。转化后得API几乎和微信官方API一样。使用方法：安装使用git安装到项目根目录/module,git", "clone", "https://github.com/tornoda/to-promise或直接下载放入项目目录下如：/module在需要用到的地方引入import", "toPromise", "from", "'/module/to-promise/src/index'绑定微信全局对象(wx)到函数，以便可以取到微信得APIconst", "toPromiseWx", "=", "toPromise(wx)开始转化你需要得异步API//apiName为微信异步方法名，如对wx.request()进行转化", "const", "request", "=", "toPromiseWx('request')", "//直接使用request方法举例：import", "toPromise", "from", "'/module/to-promise/src/index'", "//转换wx.getStorage()", "const", "getStorage", "=", "toPromsie(wx)('getStorage')", "//使用", "getStorage({", "key:", "'test'", "})", ".then(", "(res)", "=>", "{", "//res的值与wx.getStorage({", "success:", "(res)", "=>", "{}", "})中的res值一样", "//res", "=", "{data:", "'keyValue'}", "console.log(res.data)//控制台打印storage中key对于的value", "return", "res.data//如果需要继续链式调用转化后的api，需要把值显示返回", "},", "(err)", "=>", "{", "//err的值与wx.getStorage({", "success:", "(err)", "=>", "{}", "})中的err值一样", "throw", "err", "}", ")关于Promise对象的使用，请参见PromiseAPItoPromise(global)参数(wx):", "wx全局对象。即toPromise(wx)这样调用返回(function):", "参数(string)为小程序异步方法名。返回一个函数，该函数的参数与返回值如下。参数：(object)", "对应wx小程序异步方法中的参数(OBJECT)除去success与fail后的对象。例如：官方APIwx.getLocation(OBJECT)的OBJECT接受如下属性：", "type", "altitude", "success", "fail", "complete，那么去除（success", "fail）后为：type", "altitude", "complete。返回:", "(pending", "Promsise)", "返回一个未知状态的Promise对象，在该对象上调用.then(onFulfilled,", "onRejected)方法来处理对用成功或失败的情况。onFulfilled为请求成功后调用的回调函数，参数为返回值，onRejected为请求失败后的回调函数，参数为返回的错误信息。简单点来说，const", "getLocation", "=", "toPromiseWx('getLocation')", "getLocation({", "type:", "'wgs84',", "altitude:", "true,", "complete:", "()", "=>", "{", "console.log('to-promsise", "is", "awesome')", "}", "}).then(", "(res)", "=>", "{//dosomething", "if", "succeed},", "(err)", "=>", "{//dosomething", "if", "failed}", ")与下面官方调用等价wx.getLocation({", "type:", "'wgs84',", "altitude:", "true,", "complete:", "()", "=>", "{", "console.log('to-promsise", "is", "awesome')", "},", "success:", "(res)", "=>", "{//dosomething", "if", "succeed},", "fail:", "(err)", "=>", "{//dosomething", "if", "failed}", "})应用场景举例单次异步调用，参见API最后多次异步操作调用，且每下一次调用都会用到前一次返回的结果。如：获得GPS信息后，根据GPS信息获取天气信息，取得天气信息后立马存入localStorage。import", "toPromise", "from", "'/module/to-promise/src/index'", "const", "toPromiseWx", "=", "toPrmise(wx)", "//方法转换", "const", "getLocation", "=", "toPromiseWx('getLocation')", "const", "request", "=", "toPromiseWx('request')", "const", "setStorage", "=", "toPromiseWx('setStorage')", "//链式写逻辑", "getLocation()", "//获取位置信息", ".then(", "(res)", "=>", "{", "//位置获取成功后的处理，res为返回信息", "//处理res后返回有用的信息，这里直接返回res，用于演示", "return", "Promise.resolve(res)", "//必须", "},", "(err)", "=>", "{", "//位置获取失败后的错误处理，err为错误信息", "//错误处理", "return", "Promise.resolve(err)", "//必须", "}", ")", ".then(", "(res)", "=>", "{", "//根据位置获取成功后的信息，请求天气信息", "return", "request({", "url:", "'http://api.weather.com'})", "//返回一个pending", "状态下的Promise", "}", ")", ".then(", "(res)", "=>", "{", "//天气获取成功后存入storage的回调", "setStorage({", "key:", "'test',", "data:", "'res'", "})", "},", "(err)", "=>", "{", "//天气获取失败后执行这里，err为获取天气失败的错误信息", "}", ")如果使用官方的API写上述逻辑，代码是这样的：wx.getLocation({", "success:", "(res)", "=>", "{", "//some", "transformation", "with", "res", "wx.request({", "url:", "'http://api.weather.com',", "success:", "(res)", "=>", "{", "wx.setStorage({", "success:", "()", "=>", "{", "//do", "something", "},", "fail:", "(err)", "=>", "{", "//do", "something", "if", "err", "happend", "}", "})", "},", "fail:", "(err)", "=>", "{", "//do", "something", "if", "err", "happend", "}", "})", "},", "fail:", "(err)", "=>", "{", "//do", "something", "if", "err", "happend", "})", "//层层回调，如果逻辑再复杂点，可能就疯了"]}
{"author": "Rolan", "title": "微信小程序 - 如何通过button按钮实现分享（转发）功能 ", "content": ["小程序官方APIhttps://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0", "有两种方式，一种是页面内按钮分享，一种是菜单转发.", "1.页面内按钮分享", "可以自定义以下内容", "wxml", "js", "2.菜单分享"]}
{"author": "Rolan", "title": "小程序居然可以用WXS模拟实现过滤器！ ", "content": ["小程序目前官方还没有出过滤器，特别不方便，但是可以用wxs来模拟过滤器，话不多说，直接上代码。当然，不熟悉wxs的可以先看一下", "官方文档1.新建一个filter.wxs的文件我个人建议是一个过滤器写一个wxs，避免引用用不到的过滤器，不过都写到一个里面也是可以的。2.在filter.wxs里写需要的方法（我这里以订单状态为例）3.在需要的wxml里引入filter.wxs<wxs", "module=\"_orderFilter\"", "src=\"../../filter/orderStatus.wxs\"></wxs>", "<view>", "{{_orderFilter.orderStatus(order.status)}}", "</view>这样就ok啦～作者：我是敏敏啦链接：https://juejin.im/post/5b7148da51882560fd2340c7"]}
{"author": "Rolan", "title": "把微信小程序异步API转为Promise，简化异步编程，告别层层回调 ... ", "content": ["把微信小程序异步API转化为Promise。用Promise处理异步操作有多方便，谁用谁知道。微信官方没有给出Promise", "API来处理异步操作，而官方API异步的又非常多，这使得多异步编程会层层回调，代码一复杂，回调起来就想砸电脑。于是写了一个通用工具，把微信官方的异步API转化为Promise，方便处理（多）异步操作。你可以这样用：准备转化后的方法并暴露出//", "/utils/wx-promise.js", "import", "toPromise", "from", "'/module/to-promise/src/index'", "const", "toPromiseWx", "=", "toPromsie(wx)", "export", "const", "request", "=", "toPromiseWx('requset')", "export", "const", "getLocation", "=", "toPromiseWx('getLocation')", "export", "const", "setStorage", "=", "toPromiseWx('setStorage')", "//export", "其他你项目中可能用到的异步API在其他文件中使用在App.js中使用：//App.js", "import", "{", "request", "}", "from", "'./utils/wx-promise.js'", "App({", "onLanuch:", "()", "=>", "{", "request({", "url:", "'http://api.yourapi.com'", "})", ".then(()", "=>", "{", "//成功后处理", "})", ".then(()", "=>", "{", "//失败后处理", "})", "}", "})在其他page中使用：//", "/page/index.js", "import", "{", "request,", "setStorage", "}", "from", "'../utils/wx-promise.js'", "page({", "onLoad:", "()", "=>", "{", "request({", "url:", "'http://api.yourapi.com'", "})", ".then(()", "=>", "{", "//成功后处理", "})", ".then(()", "=>", "{", "//失败后处理", "})", "},", "onHide:", "()", "=>", "{", "setStorage({", "key:", "'yourkey',", "data:", "'yourvalue'", "})", ".then(()", "=>", "{", "//保存成功", "})", ".then(()", "=>", "{", "//保存失败", "})", "}", "})项目地址：to-promise其他更多更具体用法，直接粘贴README了，如下。to-promise是一个转换微信小程序异步API为Promise的一个工具库优点：避免小程序异步编程多次回调带来的过多回调导致逻辑不清晰，篇幅过长等问题。借助于Promise异步编程特点，支持链式操作，像同步一样写异步。转化后得API几乎和微信官方API一样。使用方法：安装使用git安装到项目根目录/module,git", "clone", "https://github.com/tornoda/to-promise或直接下载放入项目目录下如：/module在需要用到的地方引入import", "toPromise", "from", "'/module/to-promise/src/index'绑定微信全局对象(wx)到函数，以便可以取到微信得APIconst", "toPromiseWx", "=", "toPromise(wx)开始转化你需要得异步API//apiName为微信异步方法名，如对wx.request()进行转化", "const", "request", "=", "toPromiseWx('request')", "//直接使用request方法举例：import", "toPromise", "from", "'/module/to-promise/src/index'", "//转换wx.getStorage()", "const", "getStorage", "=", "toPromsie(wx)('getStorage')", "//使用", "getStorage({", "key:", "'test'", "})", ".then(", "(res)", "=>", "{", "//res的值与wx.getStorage({", "success:", "(res)", "=>", "{}", "})中的res值一样", "//res", "=", "{data:", "'keyValue'}", "console.log(res.data)//控制台打印storage中key对于的value", "return", "res.data//如果需要继续链式调用转化后的api，需要把值显示返回", "},", "(err)", "=>", "{", "//err的值与wx.getStorage({", "success:", "(err)", "=>", "{}", "})中的err值一样", "throw", "err", "}", ")关于Promise对象的使用，请参见PromiseAPItoPromise(global)参数(wx):", "wx全局对象。即toPromise(wx)这样调用返回(function):", "参数(string)为小程序异步方法名。返回一个函数，该函数的参数与返回值如下。参数：(object)", "对应wx小程序异步方法中的参数(OBJECT)除去success与fail后的对象。例如：官方APIwx.getLocation(OBJECT)的OBJECT接受如下属性：", "type", "altitude", "success", "fail", "complete，那么去除（success", "fail）后为：type", "altitude", "complete。返回:", "(pending", "Promsise)", "返回一个未知状态的Promise对象，在该对象上调用.then(onFulfilled,", "onRejected)方法来处理对用成功或失败的情况。onFulfilled为请求成功后调用的回调函数，参数为返回值，onRejected为请求失败后的回调函数，参数为返回的错误信息。简单点来说，const", "getLocation", "=", "toPromiseWx('getLocation')", "getLocation({", "type:", "'wgs84',", "altitude:", "true,", "complete:", "()", "=>", "{", "console.log('to-promsise", "is", "awesome')", "}", "}).then(", "(res)", "=>", "{//dosomething", "if", "succeed},", "(err)", "=>", "{//dosomething", "if", "failed}", ")与下面官方调用等价wx.getLocation({", "type:", "'wgs84',", "altitude:", "true,", "complete:", "()", "=>", "{", "console.log('to-promsise", "is", "awesome')", "},", "success:", "(res)", "=>", "{//dosomething", "if", "succeed},", "fail:", "(err)", "=>", "{//dosomething", "if", "failed}", "})应用场景举例单次异步调用，参见API最后多次异步操作调用，且每下一次调用都会用到前一次返回的结果。如：获得GPS信息后，根据GPS信息获取天气信息，取得天气信息后立马存入localStorage。import", "toPromise", "from", "'/module/to-promise/src/index'", "const", "toPromiseWx", "=", "toPrmise(wx)", "//方法转换", "const", "getLocation", "=", "toPromiseWx('getLocation')", "const", "request", "=", "toPromiseWx('request')", "const", "setStorage", "=", "toPromiseWx('setStorage')", "//链式写逻辑", "getLocation()", "//获取位置信息", ".then(", "(res)", "=>", "{", "//位置获取成功后的处理，res为返回信息", "//处理res后返回有用的信息，这里直接返回res，用于演示", "return", "Promise.resolve(res)", "//必须", "},", "(err)", "=>", "{", "//位置获取失败后的错误处理，err为错误信息", "//错误处理", "return", "Promise.resolve(err)", "//必须", "}", ")", ".then(", "(res)", "=>", "{", "//根据位置获取成功后的信息，请求天气信息", "return", "request({", "url:", "'http://api.weather.com'})", "//返回一个pending", "状态下的Promise", "}", ")", ".then(", "(res)", "=>", "{", "//天气获取成功后存入storage的回调", "setStorage({", "key:", "'test',", "data:", "'res'", "})", "},", "(err)", "=>", "{", "//天气获取失败后执行这里，err为获取天气失败的错误信息", "}", ")如果使用官方的API写上述逻辑，代码是这样的：wx.getLocation({", "success:", "(res)", "=>", "{", "//some", "transformation", "with", "res", "wx.request({", "url:", "'http://api.weather.com',", "success:", "(res)", "=>", "{", "wx.setStorage({", "success:", "()", "=>", "{", "//do", "something", "},", "fail:", "(err)", "=>", "{", "//do", "something", "if", "err", "happend", "}", "})", "},", "fail:", "(err)", "=>", "{", "//do", "something", "if", "err", "happend", "}", "})", "},", "fail:", "(err)", "=>", "{", "//do", "something", "if", "err", "happend", "})", "//层层回调，如果逻辑再复杂点，可能就疯了"]}
{"author": "Rolan", "title": "WebStorm格式化代码，微信小程序rpx出现空格问题 ", "content": ["格式化", "rpx出现空格问题//windows系统", "sed", "-i", "s/\"\\", "rpx\"/rpx/g", "$FilePath$", "//MacOS系统", "sed", "-i", "\"\"", "s/\"\\", "rpx\"/rpx/g", "$FilePath$windows系统如图所示配置苹果系统如图所示配置注意：windows系统需要下载sed这个软件才行下载地址：https://github.com/mbuilov/se...参考来源：https://zhuanlan.zhihu.com/p/35604120"]}
{"author": "Rolan", "title": "微信小程序 wx.setStorage 缓存字典策略 ", "content": ["官方提供了wx.setStorage", "等接口给开发者缓存数据，但是对于使用Array()来缓存字典数据似乎存在bug？在设置后并不能成功。", "var", "arr", "=", "Array()", "arr['key']", "=", "'value'", "wx.setStorage({", "key:", "'test_key',", "data:", "arr", "})控制台里是这样的！并没有缓存成功", "投机取巧：使用数组模拟字典的效果解决方案如下根据key取值", "根据key、data更新数组", "我的需求是缓存一个阅读记录的字典其数据格式如下read_record:", "{", "keys:", "Array(),", "//", "[小说id]", "datas:", "Array()", "//", "[章节id]}可以根据小说id去获取最近阅读的章节的id", "data:", "{", "read_record:", "{", "keys:", "Array(),", "datas:", "Array()", "}", "},", "//", "初始化阅读记录", "initReadRecord:", "function()", "{", "let", "key", "=", "'chapter_read_record'", "var", "data", "=", "wx.getStorageSync(key)", "if", "(data)", "{", "this.data.read_record", "=", "data", "}", "},", "//", "获取阅读记录", "根据小说的id获取上次阅读的章节的id", "getReadRecord:", "function(novel_id)", "{", "let", "keys", "=", "this.data.read_record.keys", "let", "datas", "=", "this.data.read_record.datas", "let", "idx", "=", "keys.indexOf(novel_id)", "return", "datas[idx]", "},", "//", "保存阅读记录", "根据小说id、章节id保存", "setReadRecord:", "function(novel_id,", "chapter_id)", "{", "let", "key", "=", "'chapter_read_record'", "let", "keys", "=", "this.data.read_record.keys", "let", "datas", "=", "this.data.read_record.datas", "let", "idx", "=", "keys.indexOf(novel_id)", "//", "如果没有找到索引，会返回-1", "if", "(idx", "==", "-1)", "{", "keys.push(novel_id)", "datas.push(chapter_id)", "}", "else", "{", "datas[idx]", "=", "chapter_id", "}", "let", "that", "=", "this", "wx.setStorage({", "key:", "key,", "data:", "that.data.read_record,", "})", "},缓存结果作者：一本大书", "链接：https://www.jianshu.com/p/f002faef5fbc"]}
{"author": "Rolan", "title": "微信小程序：text文本的展开与收起 ", "content": ["间隔了几个月，又被拉来做小程序了~~~", "页面中有一段说明文字，要求默认收起，只展示3行；点击按钮可以查看完整内容。看了下微信文档，没发现有控件满足要求，于是决定通过js实现", "h5", "ellipsis.gif先看看布局文件，关键在与{{ellipsis?'ellipsis':'unellipsis'}}，样式根据js中的ellipsis改变。<view", "class='bg-white", "marginTop10", "vertical'>", "<text", "class='pay-hint-tille'>挂号支付须知</text>", "<text", "class=\"pay-hint-content", "{{ellipsis?'ellipsis':'unellipsis'}}\"", ">1.支付成功后，将会推送排队号；就诊当日可直接前往诊室等待叫号就诊，无需再现场缴费、排队。\\n2.", "已完成支付挂号费用的用户，如在就诊前一日取消预约订单，成功申请取消订单后，正常情况下系统将会在7个工作日内自动退费至用户支付账号内。\\n3.", "订单在正常状态下（非系统故障、非医生临时停诊）被爽约，由于占用了医院号源，此类订单不予以退费。</text>", "<view", "class='bg-white-ellipsis'", "bindtap='ellipsis'>", "<image", "class='img-ellipsis'", "src=\"{{ellipsis?'../images/ellipsis.png':'../images/unellipsis.png'}}\"></image>", "</view></view>接下来看下css，其他的css都是常规配置，不需要看，", "我们看下pay-hint-content及后面的ellipsis与unellipsis：.pay-hint-content{", "margin-left:", "5%;", "margin-right:", "5%;", "margin-top:", "10px;", "font-size:", "13px;", "color:", "#888;", "display:", "-webkit-box;", "-webkit-box-orient:vertical;", "text-overflow:", "ellipsis;", "overflow:hidden;", "//", "通过以上四行实现收缩功能}.ellipsis{", "-webkit-line-clamp:3;", "//", "最多显示3行", "opacity:", "0.75", "//", "透明度75%}.unellipsis{", "-webkit-line-clamp:0;", "//", "全部显示", "opacity:", "1", "//", "不透明}这里需要注意的有overflow：hidden，如果不设置overflow会是神马效果呢？如下图（可以看到厦航文字后，下面的文字还是显示了，只是未占据控件位置而已）：h5", "ellipsis", "has", "no", "overflow.jpg", "我们再看看js：Page({", "data:", "{", "ellipsis:", "true,", "//", "文字是否收起，默认收起", "},", "/**", "*", "收起/展开按钮点击事件", "*/", "ellipsis:", "function", "()", "{", "var", "value", "=", "!this.data.ellipsis;", "this.setData({", "ellipsis:", "value", "})", "},作者：ThinkinLiu", "链接：https://www.jianshu.com/p/f5b42ebe0a1f"]}
{"author": "Rolan", "title": "vue和微信小程序的区别、比较 ", "content": ["写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。一、生命周期先贴两张图：vue生命周期小程序生命周期相比之下，小程序的钩子函数要简单得多。vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。onLoad:", "页面加载一个页面只会调用一次，可以在", "onLoad", "中获取打开当前页面所调用的", "query", "参数。onShow:", "页面显示每次打开页面都会调用一次。onReady:", "页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期onHide:", "页面隐藏当navigateTo或底部tab切换时调用。onUnload:", "页面卸载当redirectTo或navigateBack的时候调用。数据请求在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。二、数据绑定VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：<img", ":src=\"imgSrc\"/>", "小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：<image", "src=\"{{imgSrc}}\"></image>", "三、列表渲染直接贴代码，两者还是有些相似vue：<ul", "id=\"example-1\">", "<li", "v-for=\"item", "in", "items\">", "{{", "item.message", "}}", "</li>", "</ul>", "var", "example1", "=", "new", "Vue({", "el:", "'#example-1',", "data:", "{", "items:", "[", "{", "message:", "'Foo'", "},", "{", "message:", "'Bar'", "}", "]", "}", "})", "小程序：Page({", "data:", "{", "items:", "[", "{", "message:", "'Foo'", "},", "{", "message:", "'Bar'", "}", "]", "}", "})", "<text", "wx:for=\"{{items}}\">{{item}}</text>", "四、显示与隐藏元素vue中，使用v-if", "和v-show控制元素的显示和隐藏小程序中，使用wx-if和hidden控制元素的显示和隐藏五、事件处理vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:<button", "v-on:click=\"counter", "+=", "1\">Add", "1</button>", "<button", "v-on:click.stop=\"counter+=1\">Add1</button>", "//阻止事件冒泡", "小程序中，全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：<button", "bindtap=\"noWork\">明天不上班</button>", "<button", "catchtap=\"noWork\">明天不上班</button>", "//阻止事件冒泡", "六、数据双向绑定1.设置值在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。<div", "id=\"app\">", "<input", "v-model=\"reason\"", "placeholder=\"填写理由\"", "class='reason'/>", "</div>", "new", "Vue({", "el:", "'#app',", "data:", "{", "reason:''", "}", "})", "但是在小程序中，却没有这个功能。那怎么办呢？当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。下面是代码，可以感受一下:<input", "bindinput=\"bindReason\"", "placeholder=\"填写理由\"", "class='reason'", "value='{{reason}}'", "name=\"reason\"", "/>", "Page({", "data:{", "reason:''", "},", "bindReason(e)", "{", "this.setData({", "reason:", "e.detail.value", "})", "}", "})", "当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。2.取值vue中，通过this.reason取值小程序中，通过this.data.reason取值七、绑定事件传参在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：<button", "@click=\"say('明天不上班')\"></button>", "new", "Vue({", "el:", "'#app',", "methods:{", "say(arg){", "consloe.log(arg)", "}", "}", "})", "在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有...<view", "class='tr'", "bindtap='toApprove'", "data-id=\"{{item.id}}\"></view>", "Page({", "data:{", "reason:''", "},", "toApprove(e)", "{", "let", "id", "=", "e.currentTarget.dataset.id;", "}", "})", "八、父子组件通信1.子组件的使用在vue中，需要：编写子组件在需要使用的父组件中通过import引入在vue的components中注册在模板中使用", "//子组件", "bar.vue", "<template>", "<div", "class=\"search-box\">", "<div", "@click=\"say\"", ":title=\"title\"", "class=\"icon-dismiss\"></div>", "</div>", "</template>", "<script>", "export", "default{", "props:{", "title:{", "type:String,", "default:''", "}", "}", "},", "methods:{", "say(){", "console.log('明天不上班');", "this.$emit('helloWorld')", "}", "}", "</script>", "//", "父组件", "foo.vue", "<template>", "<div", "class=\"container\">", "<bar", ":title=\"title\"", "@helloWorld=\"helloWorld\"></bar>", "</div>", "</template>", "<script>", "import", "Bar", "from", "'./bar.vue'", "export", "default{", "data:{", "title:\"我是标题\"", "},", "methods:{", "helloWorld(){", "console.log('我接收到子组件传递的事件了')", "}", "},", "components:{", "Bar", "}", "</script>", "在小程序中，需要：1.编写子组件2.", "在子组件的json文件中，将该文件声明为组件{", "\"component\":", "true", "}", "3.在需要引入的父组件的json文件中，在usingComponents填写引入组件的组件名以及路径\"usingComponents\":", "{", "\"tab-bar\":", "\"../../components/tabBar/tabBar\"", "}", "4.在父组件中，直接引入即可<tab-bar", "currentpage=\"index\"></tab-bar>", "具体代码://", "子组件", "<!--components/tabBar/tabBar.wxml-->", "<view", "class='tabbar-wrapper'>", "<view", "class='left-bar", "{{currentpage===\"index\"?\"active\":\"\"}}'", "bindtap='jumpToIndex'>", "<text", "class='iconfont", "icon-shouye'></text>", "<view>首页</view>", "</view>", "<view", "class='right-bar", "{{currentpage===\"setting\"?\"active\":\"\"}}'", "bindtap='jumpToSetting'>", "<text", "class='iconfont", "icon-shezhi'></text>", "<view>设置</view>", "</view>", "</view>", "2.父子组件间通信在vue中父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据的传递，示例://", "父组件", "foo.vue", "<template>", "<div", "class=\"container\">", "<bar", ":title=\"title\"></bar>", "</div>", "</template>", "<script>", "import", "Bar", "from", "'./bar.vue'", "export", "default{", "data:{", "title:\"我是标题\"", "},", "components:{", "Bar", "}", "</script>", "//", "子组件bar.vue", "<template>", "<div", "class=\"search-box\">", "<div", ":title=\"title\"", "></div>", "</div>", "</template>", "<script>", "export", "default{", "props:{", "title:{", "type:String,", "default:''", "}", "}", "}", "</script>", "子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。在小程序中父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：<tab-bar", "currentpage=\"index\"></tab-bar>", "此处，", "“index”就是要向子组件传递的值在子组件properties中，接收传递的值properties:", "{", "//", "弹窗标题", "currentpage:", "{", "//", "属性名", "type:", "String,", "//", "类型（必填），目前接受的类型包括：String,", "Number,", "Boolean,", "Object,", "Array,", "null（表示任意类型）", "value:", "'index'", "//", "属性初始值（可选），如果未指定则会根据类型选择一个", "}", "}", "子组件向父组件通信和vue也很类似，代码如下://子组件中", "methods:", "{", "//", "传递给父组件", "cancelBut:", "function", "(e)", "{", "var", "that", "=", "this;", "var", "myEventDetail", "=", "{", "pickerShow:", "false,", "type:", "'cancel'", "}", "//", "detail对象，提供给事件监听函数", "this.triggerEvent('myevent',", "myEventDetail)", "//myevent自定义名称事件，父组件中使用", "},", "}", "//父组件中", "<bar", "bind:myevent=\"toggleToast\"></bar>", "//", "获取子组件信息", "toggleToast(e){", "console.log(e.detail)", "}", "如果父组件想要调用子组件的方法vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：//子组件", "<bar", "ref=\"bar\"></bar>", "//父组件", "this.$ref.bar.子组件的方法", "小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：//子组件", "<bar", "id=\"bar\"></bar>", "//", "父组件", "this.selectComponent('#id').syaHello()", "小程序和vue在这点上太相似了，有木有。。。九、废话还有好多地方没写，之后再慢慢加上、精简。感觉自己写的有点冗余，大佬勿喷！！！如果觉得有帮助，希望帮忙点个赞和收藏"]}
{"author": "Rolan", "title": "从0开发豆果美食小程序——搜索组件 ", "content": ["作者：白芷", "原文：https://segmentfault.com/a/1190000015831326?utm_source=tuicool&utm_medium=referral效果图组件结构为组件设置一个容器，在容器中放置搜索图标、输入框、清除文字按钮和搜索按钮。<view", "class='container'>", "<view", "class='input-wrapper'>", "<image", "class='search-icon'", "src='/img/search.png'></image>", "<input", "placeholder='{{placeholder}}'", "value='{{inputValue}}'", "bindinput='handleInput'", "bindconfirm='handleSearch'", "bindfocus='inputFocused'>", "</input>", "<view", "class='close-icon-wrapper'", "wx:if=\"{{showCloseIcon}}\"", "bindtap='clearValue'>", "<image", "class='close-icon'", "src='/img/close.png'", "></image>", "</view>", "<text", "bindtap='onTap'>搜索</text>", "</view>", "</view>组件样式container：高度", "100", "rpx，背景色", "#eee，flex", "布局。input-wrapper：高度", "80", "rpx，背景色", "#fff，flex", "布局，border-radius:", "20rpx。search-icon：宽高", "32", "rpx。input：字体和光标颜色", "#000，字体大小", "32", "rpx。close-icon-wrapper：宽高", "80", "rpx，绝对定位。text：搜索按钮宽", "110", "rpx，高", "65", "rpx，绝对定位，左边框", "2rpx", "solid", "#eee。.container", "{", "background:", "#eee;", "height:", "100rpx;", "width:", "100%;", "display:", "flex;", "justify-content:", "center;", "align-items:", "center;", "}", ".input-wrapper", "{", "display:", "flex;", "align-items:", "center;", "height:", "80rpx;", "width:", "80%;", "background:", "#fff;", "border-radius:", "20rpx;", "}", ".input-wrapper", ".search-icon", "{", "margin-left:", "20rpx;", "width:", "32rpx;", "height:", "32rpx;", "}", ".input-wrapper", "input", "{", "margin-left:", "10rpx;", "color:", "#000;", "font-size:", "32rpx;", "caret-color:", "#000;", "width:", "60%;", "}", ".input-wrapper", ".close-icon-wrapper{", "position:", "absolute;", "left:", "480rpx;", "width:", "80rpx;", "height:", "80rpx;", "background:#fff;", "display:", "flex;", "justify-content:", "center;", "align-items:", "center;", "}", ".input-wrapper", ".close-icon", "{", "width:", "42rpx;", "height:", "42rpx;", "}", ".input-wrapper", "text", "{", "position:", "absolute;", "right:", "80rpx;", "width:", "110rpx;", "height:", "65rpx;", "padding:", "0;", "background:", "#fff;", "display:", "flex;", "justify-content:", "center;", "align-items:", "center;", "font-size:", "32rpx;", "border-left:", "2rpx", "solid", "#eee;", "}组件功能1.", "属性区分组件的构造器中要注意区分", "properties", "和", "data，properties", "中写组件的对外属性，data", "写组件的对内属性。在本搜索组件中", "placeholder", "和", "value", "从页面传来，所以它们写在", "properties", "中，控制清除按钮是否出现的", "showCloseIcon", "要写在", "data", "中。properties:", "{", "placeholder:", "{", "type:", "String,", "value:", "'搜索'", "//", "如果页面不传placeholder，显示“搜索”", "},", "inputValue:", "{", "type:", "String", "}", "},", "data:", "{", "showCloseIcon:", "false,", "},2.方法设置事件流程（1）光标不聚焦，没有任何输入——显示搜索图标、placeholder和搜索按钮。（2）光标聚焦，没有任何输入——光标闪烁，显示搜索图标、placeholder和搜索按钮。（3）光标聚焦，有输入——光标闪烁，显示搜索图标、输入文字、清除按钮和搜索按钮。（4）光标不聚焦，有输入——显示搜索图标、输入文字、清除按钮和搜索按钮。（5）按回车搜索——清除按钮隐藏。（6）点击搜索按钮——清除按钮隐藏。由此可见，需要", "input", "组件的聚焦和键盘输入事件。<input", "placeholder='{{placeholder}}'", "value='{{inputValue}}'", "bindinput='handleInput'", "bindconfirm='handleSearch'", "bindfocus='inputFocused'>", "</input>inputFocused：如果聚焦时，输入框中有内容，显示", "closeIcon；handleInput：如果输入时没有内容，不显示", "closeIcon，有内容，显示", "closeIcon", "并把值存入", "value。handleSearch：点击回车后，不显示", "closeIcon。triggerEvent：自定义组件触发事件时，需要使用", "triggerEvent", "方法，指定事件名、detail对象和事件选项。", "文档详情inputFocused(e)", "{", "if", "(e.detail.value", "!==", "'')", "{", "this.setData({", "showCloseIcon:", "true,", "});", "}", "},", "handleInput(e)", "{", "if", "(e.detail.value", "==", "'')", "{", "this.setData({", "showCloseIcon:", "false,", "});", "}", "else", "{", "this.setData({", "showCloseIcon:", "true,", "});", "this.triggerEvent('handleInput',", "{", "value:", "e.detail.value", "});", "}", "},", "handleSearch()", "{", "//", "点击键盘上的回车，调用此方法", "this.setData({", "showCloseIcon:", "false,", "});", "console.log('handleSearch',", "this.data.inputValue);", "},<view", "class='close-icon-wrapper'", "wx:if=\"{{showCloseIcon}}\"", "bindtap='clearValue'>", "<image", "class='close-icon'", "src='/img/close.png'", "></image>", "</view>", "<text", "bindtap='onTap'>搜索</text>分别为", "closeIcon", "和", "搜索按钮添加点击事件。clearValue()", "{", "this.triggerEvent('handleInput',", "{", "value:", "''", "});", "this.setData({", "showCloseIcon:", "false,", "});", "},", "onTap()", "{", "this.setData({", "showCloseIcon:", "false,", "});", "console.log('onTap',", "this.data.inputValue);", "},组件", "json{", "\"component\":true", "}页面", "json工程的名字是", "cookbook，这里组件前缀统一为", "ck。{", "\"usingComponents\":{", "\"ck-input\":\"/components/search/index\"", "}", "}页面", "wxml<view", "class='container'>", "<ck-input", "placeholder='搜你想吃的'", "inputValue=\"{{inputValue}}\"", "bind:handleInput=\"handleInput\">", "</ck-input>", "</view>页面", "jshandleInput(e)", "{", "this.setData({", "inputValue:", "e.detail.value,", "});", "},结束语至此，搜索组件已完成初步开发。"]}
{"author": "Rolan", "title": "【重构】微信小程序倒计时组件 ", "content": ["回想在4个月前刚刚进入公司实习时，我封装了一个应用于小程序的倒计时组件。链接在这里：", "微信小程序之倒计时组件以现在的视角再去看之前的实现可以说是一坨看不下去的烂代码。所以也借此机会，将之前的组件重构一番。重构旧代码在原来的组件中有一个initDuration属性和3个方法，3个方法分别是countDown，format和runCountDown。initDuration属性首先我们需要三个page属性来帮助完成接下来的代码，它们的名字和内容如下：timer:", "null,", "//", "存储setInterval的ID", "flag:", "false,", "//", "倒计时是否结束的标志", "num:", "0", "//", "过去的秒数", "复制代码在initDuration属性的新的回调方法中，我们封装了clearTimer方法，init初始化方法，并且执行倒计时。initDuration:", "{", "type:", "Number,", "value:", "0,", "observer:", "function", "(newVal)", "{", "if", "(this.timer)", "{", "this.clearTimer()", "}", "this.init()", "//", "重置num和flag", "this.runCountDown(newVal)", "}", "},", "复制代码一定要注意，当传入的属性的值为默认值，例如这里是0时，是不会触发observer回调的。/**", "*", "初始化函数", "*/", "init:", "function", "()", "{", "this.flag", "=", "false", "this.num", "=", "0", "}", "/**", "*", "清空计时器", "*/", "clearTimer:", "function", "()", "{", "clearInterval(this.timer)", "this.timer", "=", "null", "}", "复制代码countDown方法countDown方法是接受一个参数为倒计时的秒数，返回一个倒计时的字符串。在这个方法中没有太大改动，只是改动了一些代码格式。如下：/**", "*", "计算倒计时", "*", "@param", "{Number}", "duration", "-", "秒数时间差", "*", "@returns", "{string}", "倒计时的字符串", "*/", "countDown:", "function", "(duration)", "{", "if", "(duration", "<=", "0)", "{", "this.setFlag(true)", "//", "将flag属性设为true", "return", "'00:00:00'", "//", "返回默认时间设置", "}", "let", "seconds", "=", "this._format(duration", "%", "60)", "let", "minutes", "=", "Math.floor(duration", "/", "60)", "minutes", "=", "minutes", ">=", "60", "?", "this._format(minutes", "%", "60)", ":", "this._format(minutes)", "let", "hours", "=", "this._format(Math.floor(duration", "/", "3600))", "return", "`${hours}:${minutes}:${seconds}`", "},", "复制代码format方法format方法的作用很简单，就是处理小于10的数字展示问题。/**", "*", "格式化小于10的数字", "*", "@param", "{Number}", "time", "-", "小于10的数字", "*", "@returns", "{string}", "格式化后的字符串", "*/", "format:", "function", "(time)", "{", "return", "time", ">=", "10", "?", "time", ":", "`0${time}`", "},", "复制代码runCountDown方法runCountDown方法中的改动比较大，在原来的代码中逻辑比较混乱，穿插了许多无关的代码，其实应该将它们封装起来达到解耦的目的。runCountDown:", "function", "(initDuration)", "{", "//", "第一次给倒计时赋值", "this.setData({", "countDownStr", "})", "this.setCountDownTime(this.countDown(initDuration))", "//", "每一秒更新一次倒计时", "this.timer", "=", "setInterval(()", "=>", "{", "if", "(this.flag", "==", "true)", "{", "//", "倒计时结束", "clearInterval(this.timer)", "return", "undefined", "}", "this.addNum()", "//", "this.num", "+=", "1", "this.setCountDownTime(this._countDown(initDuration", "-", "this.num))", "},", "1000)", "},", "复制代码增加新功能我们原来的倒计时组件是缺乏一些功能的，例如传入的时间只能是秒数，倒计时结束后只显示00:00:00，如果传入的值是0的话会不进行初始化（这算是Bug了）。所以我们需要加入以下的新功能：支持自定义倒计时结束后现实的字符串。修复传入值为0的Bug。传入的时间可以是秒数，也可以是UTC时间的字符串。自定义结束字符串在倒计时组件中，展示倒计时字符串的是this.data.countDownTime属性。所以在结束时将countDownTime属性的值设为传入的字符串即可。", "首先，封装一个赋值方法setEndContent:", "function", "(countDownTime)", "{", "if", "(countDownTime)", "{", "this.setData({", "countDownTime", "})", "}", "}", "复制代码接下来为组件新增加一个属性为", "endContent", "。endContent:", "{", "type:", "String,", "value:", "'00:00:00'", "}", "复制代码接下来，在倒计时结束的位置，调用我们的赋值方法，也就是runCountDown方法的计时器回调函数中。this.timer", "=", "setInterval(()", "=>", "{", "if", "(this.flag", "==", "true)", "{", "clearInterval(this.timer)", "this.setEndContent(this.properties.endContent)", "//", "设置结束字符串", "return", "undefined", "}", "this.addNum()", "this.setCountDownTime(this._countDown(initDuration", "-", "this.num))", "},", "1000)", "复制代码这样自定义字符串就成功了，在使用组件时传入默认值即可。修复传入值为0的Bug这个问题的出现是因为当传入属性为默认值时，不会调用observer回调函数，所以这时我们需要使用组件的", "attached", "生命周期函数。attached:", "function", "()", "{", "if", "(this.properties.initDuration", "<=", "0)", "{", "//", "如果传入值为零时不会调用observer回调，则直接从这里展示倒计时结束", "this.setEndContent(this.properties.endContent)", "}", "}", "复制代码可以传入UTC时间字符串为了简洁起见，我们就不为组件增加新的属性了，依然使用initDuration属性，所以要将其type从Number改为null（小程序的这点不够强，不能选择多类型。）。在修改type后我们需要封装一个将UTC时间字符串解析成倒计时秒数的方法。parseDate:", "function", "(date)", "{", "if", "(typeof", "date", "==", "'string')", "{", "//", "将传进来的时间减去现在的时间，得到的结果便和直接传进数字值相同", "return", "Math.floor((+new", "Date(date)", "/", "1000))", "-", "Math.floor((+new", "Date", "/", "1000))", "}", "return", "date", "}", "复制代码在observer回调中调用时如下:initDuration:", "{", "type:", "null,", "observer:", "function", "(newVal)", "{", "if", "(this.timer)", "{", "this._clearTimer()", "}", "this._init()", "this._runCountDown(this.parseDate(newVal))", "//", "在这里调用parseData方法", "}", "}", "复制代码总结在这次重构过程中，我看到了之前代码耦合太严重，仅仅满足了凑合用的情况。如果想要再此基础上增加功能的成本很高，所以将内部逻辑拆分。既方便阅读和理解，也方便日后拓展功能。所以重构后我们便增加了两个新功能，希望这边文章可以帮助大家。倒计时组件代码：", "github.com/MeloGuo/wxm…可将'count-down'文件夹直接copy到项目目录下使用。欢迎喜欢、关注、star、fork，当然也欢迎pr、issue."]}
{"author": "Rolan", "title": "第一个mpvue小程序开发完了，来总结下吧 ", "content": ["历经了接近两个月的摸索滚爬，抓头吃瓜，各种优化（单押X3），我主导开发的第一个小程序终于要上线了（SKR", "SKR！）！当然首先要感谢老板没有杀了我——因为在6月初我刚拿到小程序PRD的时候老板问我多久可以做好，我看了看之后说“两周”吧，咳咳，然后。。。一直到现在，我还能活着很Amazing有没有？？？当然这其中也有一些为了追求“精品小程序”而一改再改所用的时间。好了，废话还是不多说了，下面就开始总结下吧～框架的选择", "原生的小程序我本人并没有学习过，更别提拿来开发一款商用的小程序了，刚好还在前公司时，当时的前端团队在提到小程序的解决方案时有分享了mpvue，到了新公司之后技术老大也有提到mpvue，而我本人过去一年多也一直在写vue，对vue写法比较熟悉，而且新公司团队对小程序期待已久，希望尽快上架，所以选择mpvue来开发也是最快最合理的了！项目的搭建", "看了mpvue的官方文档，项目的搭建自然也选择了官方推荐的", "vue-cli", "，", "在看了五分钟上手教程后，使用命令vue", "init", "mpvue/mpvue-quickstart", "my-project", "生成了基本的项目，在后来的开发中，项目的配置基本没做改动，只是添加了less-loader。目录结构基本上是vue-cli生成的目录结构，加了部分文件夹，主要是与后台进行数据交互所使用的框架flyio的配置文件夹（api文件夹），以及整个项目数据管理所使用的vuex（store文件夹）,整体目录结构如下：project", "└───build", "└───config", "└───dist", "└───node_modules", "└───src", "└───api", "|", "ajax.js", "//", "flyio请求与响应拦截器的配置文件", "|", "config.js", "//", "请求的配置文件", "|", "index.js", "//", "生成请求api实例文件", "|", "Server.js", "//", "项目的数据请求统一管理文件", "└───components", "└───pages", "└───store", "└───modules", "//", "vuex模块文件夹", "|", "index.js", "//", "vuex处理文件", "|", "App.vue", "|", "config.js", "|", "main.js", "└───static", "└───images", "└───lib", "└───weui", "│", "README.md", "│", "package.json", "│", "package-lock.json", "复制代码踩到的坑", "相信很多使用过mpvue的同学都或多或少猜到了一些坑，我也是踩到了不少的坑浪费了不少的宝贵时间，虽然网上关于mpvue的踩坑的文章一搜一箩筐，但我还是要写一下。。。下面就是我在本次小程序开发过程中遇到的坑（们）以及针对它们的解决方案：###", "tabBar图标问题", "复制代码", "在", "配置小程序原生的底部tabBar", "时，遇到了第一个问题：在将设计师给我的图标icon路径设置正确的情况下，", "开发者工具上的tabBar的图标总是会很大，而且几乎占满了整个高度", "，相当难看，搜了很多博客都没有找到解决办法，期间还尝试了自己实现tabBar，但是在看到那令人呕呕呕的效果之后，我还是放弃了，又回到原生的tabBar，然后静下心来想了想，最后在对比github上的一些mpvue的项目之后，发现原来是图标icon的问题，最后成功解决：", "就是icon尺寸保持不变，然后四周留出合适的透明（？）空白", "...很简单有木有？就这浪费我很多脑细胞，原谅我的愚钝（智障脸）。。。当然了，原生的tabBar其实还有一个问题就是，", "tabBar的标题文字在真机上会离底部特别特别近", "，这个我没找到解决办法，除了自己实现tabBar。。。###", "详情页数据保留之前旧数据的问题", "复制代码", "这个问题我想很多同学都遇到过了，而且我看到mpvue", "github上的issues里面有很多人都遇到了这个问题并且都在持续关注，足以说明这是个痛点问题，谁让它会影响小程序的用户体验呢。。。到目前为止看到的比较统一的解决办法就是：在（详情）页面onLoad的时候，将要在本页面展示的数据初始化并且进行新的赋值，举:chestnut:如下：<template>", "<html-text", ":text=\"htmltext\"></html-text>", "</template>", "<script>", "import", "htmlText", "from", "xxxxx", "export", "default", "{", "components:", "{", "htmlText", "},", "data", "()", "{", "return", "{", "htmltext:", "''", "}", "},", "onLoad", "()", "{", "this.htmltext", "=", "''", "this.$http.get('xxxxxxxx').then((res)", "=>", "{", "this.htmltext", "=", "res.htmltext", "})", "}", "}", "</script>", "复制代码", "其他数组或者对象类型的处理可能会麻烦一些，但是方法类似，在数据请求返回之前的这段时间内不想留空白尬对用户的话就自己做一些loading，总是要强过用户先面对旧数据再一闪跳到新数据的体验。。。###", "created钩子函数在项目初始化时就全部执行的问题", "复制代码", "这个我想应该是mpvue的一个bug吧？该钩子函数在页面内还是不要随便用的好。。。###", "目前mpvue对于复杂富文本的支持目前性能较差的问题", "复制代码", "这个微信原生的路由跳转navigateTo(),redirectTo(),navigateBack(),switchTab()，reLaunch()等,", "不能甩锅给mpvue，对于展示“相当复杂”的富文本（内容较长，且由多张图片甚至多张动图）的需求，一般不会有很多用户会遇到，但是很不巧的是，我遇到了。。。谁让我们致力于做一个有逼格的品牌呢？有需求了就要解决，光能展示远远不够，还得展示的优雅，目前的", "mpvue-wxParse", "其实已经能解决大部分问题了，也有一些github上的项目基于该项目开发得到了数百star，但是我用该项目做出来的效果老板和技术老大都相当不满意，图片没法优雅的加载，而且由于htmltext太长在图片全部解析显示出来之前有着相当长的白屏尴尬时间，所以最后还是放弃该方案。", "然后在github上找到了另一个在", "mpvue-wxParse", "的基础上改进的针对复杂富文本的项目mpvue-htmlParse", "，试了下稍微好了点，但离老板的要求还是差很远，最后不得已在此项目基础上fork出一份代码针对老板的需求亲自来改，最终得以过关，项目地址", "mpvue-htmlParse", ",该项目里主要针对", "图片的加载", "做了改进，在第一张图片加载完成后，通知主页可以关闭preLoading效果，然后给每张图片添加了菊花的加载效果，在图片完全加载完成之前会显示菊花图，然后再根据设备屏幕宽度和图片信息对图片进行适当放大或者缩小，这样整体下来的效果基本可以达到“破产版”微信公众号推文的效果，该项目适用范围有限，有需要的同学可以自己在此基础上改进。###", "微信原生的路由跳转navigateTo(),redirectTo(),navigateBack(),switchTab()，reLaunch()等，在真机上的表现较为怪异", "复制代码", "对于参数的传递，我也遇到过类似于旧数据的问题，最后不得已借助于vuex才得以解决。另外小程序的页面栈个数实在有限，所以在开发时一定要注意页面栈的管理。###", "onShow()的使用要注意", "复制代码", "要记得该钩子函数里的js代码不只是刚进入页面时会执行，在息屏后再次点亮后也将会执行。对于mpvue的坑突然能想起来的不多了，目前就先写这么多，后面想起来了再来更新吧。Flyio的使用", "在小程序的开发中，并没有使用小程序原生的wx.request()来进行数据交互，而是选择了mpvue文档里推荐使用的Flyio，Flyio的介绍就不多做介绍，打架可以自己看文档，这里我主要说一下的", "请求和响应拦截器的构造", "：", "文档里其实有很详细的介绍以及代码，但是我根据代码写下来之后在遇到登录失效的问题时并没有按照预想的解决：先锁住请求然后重新请求拿到新的cookie之后再重新进行之前的请求，再和其他人讨论之后使用promise解决了这一问题，具体可见代码：src/api/ajax.js:/**", "*", "http请求拦截器", "*/", "const", "Fly", "=", "require('flyio/dist/npm/wx')", "const", "config", "=", "require('./config')", "const", "ajaxUrl", "=", "process.env.NODE_ENV", "===", "'development'", "?", "config.Host.development", ":", "process.env.NODE_ENV", "===", "'production'", "?", "config.Host.production", ":", "config.Host.test", "let", "fly", "=", "new", "Fly()", "let", "loginFly", "=", "new", "Fly()", "//", "定义公共headers", "const", "headers", "=", "{", "...", "}", "Object.assign(fly.config,", "{", "headers:", "headers,", "baseURL:", "'xxxxxx',", "timeout:", "10000,", "withCredentials:", "true", "})", "loginFly.config", "=", "fly.config", "//", "session失效后本地重新登录", "const", "login", "=", "()", "=>", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "wx.login({", "success:", "res", "=>", "{", "let", "loginParams", "=", "{", "...", "}", "loginFly.post('/api/locallogin/url',", "loginParams).then(d", "=>", "{", "if", "(d.headers", "&&", "typeof", "d.headers['set-cookie']", "!==", "'undefined')", "{", "//", "更新session", "wx.setStorageSync('sessionid',", "d.headers['set-cookie'])", "}", "resolve()", "}).catch(error", "=>", "{", "log(error)", "reject(res.data)", "})", "},", "fail:", "res", "=>", "{", "console.error(res.errMsg)", "},", "complete:", "res", "=>", "{}", "})", "})", "}", "//", "请求拦截器", "fly.interceptors.request.use(request", "=>", "{", "if", "(wx.getStorageSync('sessionid'))", "{", "request.headers.cookie", "=", "wx.getStorageSync('sessionid')", "}", "return", "request", "})", "//", "响应拦截器", "fly.interceptors.response.use(", "response", "=>", "{", "//", "session已经失效，需要重新登录小程序", "if", "(response.data.errCode", "===", "100009)", "{", "//", "log('session失效，根据之前存储在本地的用户信息重新请求session...')", "//", "锁定响应拦截器", "fly.lock()", "return", "login().then(()", "=>", "{", "fly.unlock()", "//", "log(`重新请求：path:${response.request.url}，baseURL:${response.request.baseURL}`)", "return", "fly.request(response.request)", "}).catch(err", "=>", "{", "log(err)", "})", "}", "else", "{", "return", "response.data.data", "}", "},", "err", "=>", "{", "log('error-interceptor',", "err)", "if", "(err.status)", "{", "wx.showToast({", "title:", "'出现未知错误',", "icon:", "'none',", "duration:", "3000", "})", "}", "}", ")", "export", "default", "fly", "复制代码vuex的使用", "因为是生活购物类小程序，涉及到", "购物车", "+", "地址选择", "等较为复杂的逻辑，很多地方都需要数据共用，在本期项目中vuex起了很大的作用，因为模块较多，如果将所有数据写在一个文件里无疑会为后期维护带来巨大困难，所以将各模块的数据单独划分写在各自的文件里，这样整体流程就清晰了很多，下面是划分模块的主文件的代码src/store/index.js:import", "Vue", "from", "'vue'", "import", "Vuex", "from", "'vuex'", "import", "modules1", "from", "'./modules/modules1'", "import", "modules2", "from", "'./modules/modules2'", "import", "modules3", "from", "'./modules/modules3'", "...", "Vue.use(Vuex)", "export", "default", "new", "Vuex.Store({", "//", "做模块化处理,每个功能一个store.js文件,然后统一在这边引入", "modules:", "{", "modules1,", "modules2,", "modules3,", "...", "}", "})", "复制代码src/store/modules/modules1.js:import", "api", "from", "'@/api'", "//", "actions里请求用到", "const", "state", "=", "{", "aaaa,", "...", "}", "const", "getters", "=", "{", "aaaa", "(state)", "{", "return", "state.aaaa", "},", "bbbb", "(state,", "getters,", "rootState)", "{", "return", "getters.aaaa", "},", "...", "}", "//", "actions里可进行异步操作", "const", "actions", "=", "{", "async", "anExample", "({state,", "getters,", "dispatch,", "commit},", "{params})", "{", "let", "res", "=", "await", "api.requestFunction({params})", "...", "return", "res", "},", "...", "}", "const", "mutations", "=", "{", "setStateX", "(state,", "Y)", "{", "state.X", "=", "Y", "},", "...", "}", "export", "default", "{", "namespaced:", "true,", "//", "很重要", "state,", "getters,", "actions,", "mutations", "}", "复制代码在.vue文件中调用src/pages/xxx.vue<script>", "import", "{", "mapState,", "mapGetters", "}", "from", "'vuex'", "export", "default", "{", "computed:", "{", "//", "调用getters", "...mapGetters('modules',", "[", "'aaaa',", "'bbbb'", "])", "},", "methods:", "{", "//", "调用action", "funcA", "()", "{", "this.$store.dispatch('modules1/anExample',", "{params}).then(res", "=>", "{", "...", "})", "},", "//", "调用mutation", "funcB", "()", "{", "this.$store.commit('modules1/setStateX',", "Y)", "}", "}", "}", "</script>", "复制代码总结", "本次总结目前先写这么多吧，主要介绍了", "项目结构", "，", "遇到的坑", "（项目中遇到的问题很多，但是写的时候突然觉得那些都不是问题了？）", "，Flyio的使用", "（重点为拦截器的配置），以及", "vuex的简单介绍", "。其实项目开发完成之后想了想也没那么多东西，只是期间走了不少的弯路，做了很多“无用功”，其实说是无用功，但也从中收获了相当多，毕竟自己从无到有从0到1构建一个项目，其中的烦恼很多，但是真的能让人成长很多，也让我觉得相当充实。由于小程序是公司商用的不是我个人的项目，所以项目代码就没法开源了，如果有问题的话可以联系我，为防广告之嫌这里也不说明小程序的名字了，想来体验下的可以私信我，也欢迎大家来指正！", "老板来找我过第二期的需求了，Incoming！"]}
{"author": "Rolan", "title": "小程序redux性能优化，提升三倍渲染速度 ", "content": ["作者：蟹老板爱写代码", "链接：https://juejin.im/post/5b67b07ef265da0fa21aa51a", "前言最近用户反馈我们的小程序很卡，打开商品列表需要四五秒时间，带着这个疑问，我决定对小程序做个全面的性能优化，要做性能优化，必须先理清以下三个关键点。1、产生性能问题的关键点", "2、度量性能指标", "3、寻找解决方案在阅读案例分析前，建议能先了解小程序的工作原理和性能关键点。工作原理", "（官方说明）小程序的视图层目前使用", "WebView", "作为渲染载体，而逻辑层是由独立的", "JavascriptCore", "作为运行环境。在架构上，WebView", "和", "JavascriptCore", "都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的", "evaluateJavascript", "所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份", "JS", "脚本，再通过执行", "JS", "脚本的形式传递到两边独立环境。", "而", "evaluateJavascript", "的执行会受很多方面的影响，数据到达视图层并不是实时的。性能关键点（官方说明）频繁的去", "setData", "在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android", "下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为", "JS", "线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；", "渲染有出现延时，由于", "WebView", "的", "JS", "线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；每次", "setData", "都传递大量新数据", "由setData的底层实现可知，我们的数据传输实际是一次", "evaluateJavascript", "脚本过程，当数据量过大时会增加脚本的编译执行时间，占用", "WebView", "JS", "线程，后台态页面进行", "setData", "当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。度量性能指标我们在优化性能时，指标是非常重要的，没有指标，你没法知道优化的点是否有效。不能单凭感觉去优化，要根据指标反馈，明确优化的成果。同时，优化就像个无底洞，要注意投入产出比。", "用户反馈的卡顿，要么就是js执行消耗资源过多导致处理器没响应，要么是UI渲染消耗资源过多，导致UI没法响应用户操作。", "通过查看代码，我们并没有消耗大量计算资源的业务逻辑，但是出现了UI反复操作和抢占资源的现象。如何度量可以利用setData的第二个参数，传入callback函数，统计渲染时长。代码如下let", "startTime", "=", "Date.now()this.setData(data,", "()", "=>", "{", "let", "endTime", "=", "Data.now()", "console.log(endTime", "-", "startTime,", "'渲染时长')})案例分析", "1、检查点：是否频繁去setData", "检查结果：存在", "产生原因：redux中监听的是整个store，只要store变化，就会执行setData操作，这就意味着页面无关的数据改变，也会触发该页面执行setData操作，但是这个操作是无意义的。", "问题代码：//", "libs/redux-wechat/connect.js//", "对整个store进行subscribe。变化就执行handleChangethis.unsubscribe", "=", "this.store.subscribe(handleChange.bind(this,", "options));function", "handleChange(options)", "{", "...省略代码", "const", "state", "=", "this.store.getState()", "const", "mappedState", "=", "mapState(state,", "options);", "this.setData(mappedState)}解决方案：只监听当前页面用到的store中的部分数据，只有该部分数据变化，才setData。（store没提供单个数据的监听，如果自己修改redux实现，难度较大，同时修改太底层，容易出不可预料的异常。）", "判断页面数据与需要更新数据是否相同，如果相同，不做操作。（这个方案成本比较低，就用它吧）代码实现：//", "libs/redux-wechat/connect.js//", "如果更新的数据和页面数据相同，不做操作。function", "handleChange(options)", "{", "...省略代码", "const", "state", "=", "this.store.getState()", "const", "mappedState", "=", "mapState(state,", "options);", "//", "如果更新的数据和页面数据相同，不做操作。", "if", "(mappedState", "===", "this.prevState)", "return", "//", "新加入代码", "this.setData(mappedState)", "//", "保存上一次数据", "this.prevState", "=", "mappedState", "//", "新加入代码}另外一个优化：如果store数据毫秒级变化怎么办，例如更新购物车的同时，还更新了购物数量，能不能把两次变化合并起来？因为store的数据是共享的，最后一次的更新就是最新的数据，可以采用节流器对请求进行合并。", "clearTimeout(this.setDataTMO)", "this.setDataTMO", "=", "setTimeout(()", "=>", "{", "this.setData(mappedState)", "},", "50);", "//", "时间可以看情况调整2、检查点：每次", "setData", "都传递大量新数据", "检查结果：存在", "产生原因：页面存在引用没用到的store数据。", "后端返回数据直接进入store，后端接口返回冗余字段。问题代码：/pages/user/index.jsconnect(state", "=>", "({", "member:", "state.member,", "mycoupon:", "state.mycoupon,", "guessLikeList:", "state.recommend.guessLikeList,", "locationInfo:", "state.common", "&&", "state.common.locationInfo,", "//可删除", "selectedseller:", "state.home.selectedseller,//可删除", "carts:", "state.carts.carts,//可删除", "...state.common", "}))解决方案：删除页面无用的connect", "（老业务在使用，修改存在风险，通过后续迭代优化）", "请求后端接口后，拿到数据进行优化处理再把数据传入store（成本较高）3、检查点：后台态页面进行", "setData", "检查结果：存在", "产生原因：redux", "connect设计与小程序有差异", "问题代码：//", "libs/redux-wechat/connect.js", "function", "onLoad(options)", "{", "...省略部分代码", "if(shouldSubscribe){", "this.unsubscribe", "=", "this.store.subscribe(handleChange.bind(this,", "options));", "handleChange.call(this,", "options)", "}", "}", "function", "onUnload()", "{", "...省略部分代码", "//", "页面onUnload时，才解除监听", "typeof", "this.unsubscribe", "===", "'function'", "&&", "this.unsubscribe()", "}小程序生命周期中，onUnload会在页面销毁时执行，例如A->B->C->D", "的跳转，A页面一直在监听store的变化，如果D页面修改数据，会造成A,B,C页面也执行setData操作，抢占了D的资源，因此造成卡顿。", "解决方案：后台状态的页面在setData时直接return（目前采用该方法）", "当页面隐藏时，移除监听。代码实现：//", "因为在后台的页面setData会抢占前台资源，所以在后台的页面不要执行setData操作if", "(this.route", "!==", "_getActivePage().route)", "return但是由于在后台的页面数据没法更新，如果D页面修改A引用的数据，就会出现A引用旧数据问题，所以在onShow的时候做一次同步。", "//", "后台的页面切换到前台的时候，做一次数据同步", "function", "onShow(options)", "{", "if(shouldSubscribe){", "handleChange.call(this,", "options)", "}", "if", "(typeof", "_onShow", "===", "'function')", "{", "_onShow.call(this,", "options)", "}", "}指标测试", "做了这么多，到底有没用，拿出来溜一溜就清楚了。", "测试平台：iphone7、三星s7", "、小程序开发工具", "测试流程：首页", "->", "配送到家", "->", "加入购物车", "->", "结算", "->查看订单", "测试指标：调用setData次数，渲染总耗时，平均单次渲染耗时未优化指标：优化后指标：差异对比：总结：优化后setData次数平均下降150次。", "渲染耗时越是卡顿的机器，收益越大，三星s7平均每次渲染耗时降低826ms。"]}
{"author": "Rolan", "title": "微信小程序-bug- 调用wx.login()无响应的原因和解决方案 ", "content": ["想必，最近有些小程序开发者，在调用wx.login()的时候，在部分IOS上无响应的情况；", "补充一点：在测试模式，调试模式，都是OK的，一上正式环境就GG了，百思不得其解啊！响应结果如下：", "分析结果，我们知道，login接口一直处于pending状态，如果加了timeout时间后，在complate回调中可触发；", "那为什么login方法一直是pending呢？？？？看了微信的社区，也提了问题，但是微信官方回应，他们真机测试过，没这个情况发生；what", "fuck！！！见鬼了么", "这就尴尬了，一边一个说辞，然后就继续解决呗！客户等着呢，锅甩给微信，客户也不答应啊！捋了一遍代码，发现页面中用了新组件<open-data", "type=\"userAvatarUrl\"></open-data>", "<open-data", "type=\"userNickName\"></open-data>这个组件是用来显示微信的“头像”和“昵称”的，本着“试一试，万一可以呢”的原则，果断删除了该组件，再次运行，好了，神奇了嗨！在调用wx.login()方法前，我先使用open-data标签渲染了“头像”和“昵称”，但是为啥先使用组件后就GG了？可能是微信渲染自带线程的吧，我的使用方法，违背了微信的渲染机制，导致了线程阻塞（我猜的哈）；回头想想，也是哈，尚未登陆就渲染了头像和昵称，节奏不是这样的；就像警察查身份证，还没刷机器，就知道你叫啥了，住哪里，不科学了对吧。所以，要显示头像和昵称的open-type组件，必须在调用wx.login()的API后，再行渲染；", "知道了原因，解决起来就很简单了，定义一个变量isLogin，用来记录wx.login()是否已调用", "let", "isLogin", "=", "false", "wx.login({", "success:", "function(res)", "{", "if", "(res.code)", "{", "//发起网络请求", "isLogin", "=", "true;", "}", "}", "});然后将isLogin绑定在页面的data对象中，我就不写了哈，然后在页面中，用wx:if判断就可以了<open-data", "wx:if='{{isLogin}}'", "type=\"userAvatarUrl\"></open-data>", "<open-data", "wx:if='{{isLogin}}'", "type=\"userNickName\"></open-data>我既然写了这么牛逼的bug，不容易啊，虽然微信也脱不了干系，但是动动脚趾头想想，我们的使用方法确实很不科学的；哈哈"]}
{"author": "Rolan", "title": "初试小刀自我简历小程序 ", "content": [">>>点击获取更多文章<<<最近在做小程序，和域名更换，和新域名备案事情，甚是较忙，少写了文章，今天尝试写一篇小白总结小程序的常见问题，刚接触小程序不到2周，在业余时间尝试小刀小程序，多有不足，请指出。附上个人简历小程序图，大家可以微信扫描体验哟。小程序开发资源汇总https://github.com/justjavac/...小程序开发框架在github里面找了找，Wepy", "和mpvue比较火，毕竟Wepy是腾讯官方的开源，故我选择了Wepy。同时也选择了weui库，貌似zanui也不错，大家可以尝试下。幻灯片组件看到别人的一些小程序幻灯片图片转转转，很酷，以为是一些其他框架带来的，其实", "官方自带了视图容器swiper，详情点击官方", "https://developers.weixin.qq....。下方的tabBar刚开始做的时候，以为这些都是必须写成组件，封装成UI输出，其实原生小程序已经自带了，不需要额外做，在app.json可以设置，在wepy框架是", "app.wpy里面设置。矢量图标哪里找在这", "http://www.iconfont.cn/", "可以找到需要的icon。界面样式如何适应不同手机毕竟是在微信内部小程序环境，如何适应不同手机是个问题，用rpx吧，这样在不同的手机可以实现自适应。所以如果你使用的模块有pxh或者rem,换算方式为：1px=2rpx，1rem=35rpx。内嵌html页面当初在做的时候也想过类似问题，其实百度了下，得知了答案，只有公司类型账号才能内置", "网页<web-view", "src=\"https://www.xxxxxxxxx.com/ind...;", "/>，个人账号类型不可以哟！在html5跳转到小程序的一个页面<!--", "html代码中引入JS", "SDK", "-->", "<script", "type=\"text/javascript\"", "src=\"https://res.wx.qq.com/open/js/jweixin-1.3.0.js\"></script>", "<script>", "wx.miniProgram.navigateTo({url:", "'/path/to/page'})", "</script>实现锚点跳转下面是我用wepy实现的代码(自己看重点)，其实就是用了官方视图容器scroll-view：<template>", "<scroll-view", "scroll-y=\"true\"", "scroll-into-view=\"{{toView}}\"", "scroll-with-animation=\"true\"", "class=\"out_scroll_view\">", "<view", "id=\"list0\">", "</view>", "<view", "id=\"list1\">", "</view>", "<view", "id=\"list2\">", "</view>", "<view", "id=\"list3\">", "</view>", "<view", "id=\"list4\">", "</view>", "<footer></footer>", "</scroll-view>", "<view", "class='right_nav'>", "<view", "class='nav_item'", "wx:for=\"{{rightNav}}\"", "@tap=\"jumpTo(list{{index}})\">", "<text", "class='item_name'>{{item}}</text>", "</view>", "</view>", "</template>", "<script>", "import", "wepy", "from", "'wepy';", "import", "Footer", "from", "'./common/footer';", "export", "default", "class", "Panel", "extends", "wepy.page", "{", "data", "=", "{", "rightNav:['厂家网','腾讯','满天星','嵊灿','诺沃帝'],", "toView:''", "};", "components", "=", "{", "footer:", "Footer", "};", "methods", "=", "{", "};", "jumpTo(e){", "this.toView", "=", "e.currentTarget.dataset.wpyjumptoA;", "};", "async", "onLoad", "()", "{", "wx.showShareMenu({", "withShareTicket:", "true", "});", "};", "}", "</script>", "设置COOKIEhttps://blog.csdn.net/DylanCa...转发功能我记得官方有接口，可以设置展示转发按钮，或者你自身页面的UI，都可以触发转发功能，懒得找出来了，有心的自行到官方一看接口很容易找打送。", "more", "detail", "look", "this", "https://blog.csdn.net/rolan19...设置启动页面看①https://blog.csdn.net/kerryqp...。有趣功能接口小程序之间互跳转，拨打电话，震动电话，添加联系人，调整屏幕亮度，退出小程序，复制功能，转发功能等原生功能，都是官方有接口的，都挺有意思，大家可以进行体会。预览图片看https://blog.csdn.net/gao_xu_...，这功能是官方封装好，挺实用。审核上线提交官方文章还有有必要读下的", "微信小程序平台运营规范,微信小程序平台常见拒绝情形遗留问题和总结在swiper里面的图片，图片大小样式，不要给固定值，给width:100%，和height:100%，要不会出现在不同手机设备不兼容，我自身测试过；还有个问题可以分享，在工作经历tab里面，", "顶部有个图片已经相对定位放在头部，然后我加了css3动画文字，整个文字块尝试过绝对定位和相对定位进行偏移到图片（图片里面的电脑屏幕上）上，自身在我安卓华为手机是可以看到动画效果的，但是在IOS手机，就是不出现，只好无奈，重新P下图片，把文字P上去；", "在基本信息tab里面，有个“退出小程序”按钮功能，在IOS上，反应不是很灵敏，感觉功能不行，不知道其他开发者会不会遇到这样的问题，安卓上是可以的。"]}
{"author": "Rolan", "title": "mpvue 初体验之改写车标速查小程序 ", "content": ["前文", "说到我开发了一个简单的小程序叫做", "车标速查（代码以及二维码详见", "这里），本文简单讲讲如何将这个小程序转为", "mpvue", "开发（最终", "成果", "）mpvue", "官网的", "文档", "真的是非常简单，不，应该说是简洁，因为依托", "Vue，所以很多语法不需要赘述，直接去看", "Vue", "的文档就好了。mpvue", "这个名字真的是不忍吐槽，起名也太不上心了吧", "...", "反正我个人觉得不好听mpvue", "的入门非常简单，可以看这个", "quickstart。生成的模版目录结构和", "Vue", "开发很像，但是有区别，为了使之构建出符合小程序项目结构的代码格式：", "json/wxml/wxss/js", "文件。src", "是开发目录，dist", "是最后", "build", "的目录，也就是小程序的代码简单看一下", "src", "的代码结构：复制代码├──", "App.vue", "├──", "data", "│", "└──", "data.js", "├──", "main.js", "├──", "pages", "│", "├──", "about", "│", "│", "├──", "index.vue", "│", "│", "└──", "main.js", "│", "├──", "detail", "│", "│", "├──", "index.vue", "│", "│", "└──", "main.js", "│", "└──", "index", "│", "├──", "index.vue", "│", "└──", "main.js", "└──", "utils", "└──", "index.jsApp.vue", "最后会被编译成", "app.js/app.wxss，一些全局相关的样式和钩子函数会被放在这里（比如说", "onLaunch，但是在", "mpvue", "里我们可以用", "created", "代替）。main.js", "会被编译成", "app.json，一些全局相关的配置放在这里（比如页面入口，tabbars", "等）pages", "目录即为每个页面，以", "index", "目录为例，index.vue", "会被编译成", "main.js/main.wxml/main.wxss，而", "main.js", "可以放置针对单个页面的配置，最后会被编译成", "main.json（如果没有填入配置项，则不会生成该文件）然后来简单过下开发过程中踩的一些坑：pages", "目录下新增入口，需要重新", "npm", "start", "启动，因为新建了", "webpack", "的", "entry关于", "navigator。index", "页面点击图标需要去详情页，这就有了导航需求。小程序有原生的", "navigator", "组件，现在用", "mpvue", "开发，那么能不能用", "Vue-Router", "呢？答案是并不可以，参考", "这个", "faq。所以最后还是用了小程序原生的", "navigator", "组件detail", "页面的", "onLoad", "钩子会有一个", "options", "参数，如果在这个页面用", "created，是获取不到的，可以看下", "mpvue", "的", "生命周期。因为", "mpvue", "不建议使用小程序的生命周期钩子，所以比较好的方式是在", "mounted", "的时候用", "this.$root.$mp.query", "去获取", "options.vue", "文件需要加上", "style／script", "标签后才能被正确编译，这点不难理解，script", "里的内容被编译成", "js", "文件，而", "style", "里的内容被编译成", "wxss", "文件，一个小程序的页面需要它们支撑filters", "还是不能用关于富文本。看了下", "v-html", "指令是可以用的，但是是被编译成", "rich-text", "组件，并不符合我的要求，最后用的是", "mpvue-wxParse，还是不错的，跟", "wxParse", "功能基本一样关于", "scroll-view。因为有个侧边导航点击跳转的功能，还是用了", "scroll-view", "去实现，并没有更好的办法{{}}", "中小程序原生不支持的语法，mpvue", "同样无法支持，比如一些复杂的计算，比如函数等所有页面里面的", "created", "生命周期函数都会在小程序加载的时候，", "一次性执行，而不是每进入一个页面执行一次（可以用", "mounted", "或者", "onLoad", "或者", "onReady", "代替）总的来说，我从入门", "mpvue", "到用其改写这个小程序，也就不过一天时间，由此可见", "mpvue", "上手真的非常快，但是它给我的总体感觉是有点鸡肋，一方面可能是我这个项目有点简单（不需要用到", "Vuex", "以及组件化），另一方面可能还不是很了解", "mpvue官网概括的它的主要能力：彻底的组件化开发能力：提高代码复用性完整的", "Vue.js", "开发体验方便的", "Vuex", "数据管理方案：方便构建复杂应用快捷的", "webpack", "构建机制：自定义构建策略、开发阶段", "hotReload支持使用", "npm", "外部依赖使用", "Vue.js", "命令行工具", "vue-cli", "快速初始化项目H5", "代码转换编译成小程序目标代码的能力我觉得目前主要的亮点在于", "Vuex", "的可引入以及组件化开发，但是越来越觉得随着原生小程序开发的改善，这些功能都会被补充进去。所以，最大的卖点可能还是在于", "多端统一我觉得有点鸡肋的另一个重要原因是，使用", "mpvue", "开发并不能完全忽略小程序的", "API", "或者组件，比如这个小程序，还是要用", "navigator", "组件以及", "scroll-view", "组件去实现一些功能（当然随着", "mpvue", "生态的发展，完全有可能出现", "navigator／scroll-view", "的", "mpvue", "组件，但是这样造轮子是否值得？），而且可能还有其他一些", "API。而类比", "jQuery", "和", "js，jQuery", "完全不用去考虑原生的", "dom", "操作方式，从而更加", "“傻瓜式”。mpvue", "的开发模式注定不会是这样的结局（因为并不是从小程序底层去开发）另外一点，用", "mpvue", "开发，增加了一层", "vue->小程序", "编译环节，所以", "reload", "的速度应该会比原生开发慢一点鲁小夫", "在", "如何看待美团开源的", "mpvue", "?", "这个问题下的答案非常值得思考：不过我们也该思考一下，为什么大家对微信小程序自带的机制有这么多意见，为什么大家对", "vue", "这么认同，为什么多端兼容这个事情这么重要，为什么微信小程序没有拥抱开源，为什么微信小程序的技术栈没能做到标准化通用化。为了兼容微信小程序，前端工程师做了这么多工作，弄了那么多框架，到底得到的是什么。以前看到过一句话，大概意思是，微信小程序有太多满分的开源框架可以借鉴，最后却造了个负分的轮子。all", "in", "all，我的看法是，如果你刚好熟悉", "Vue", "或者需要多端统一开发，那么", "mpvue", "或许是个选择，如果你只是从头开始开发一个小程序，原生开发也未尝不可。说到底，一系列小程序框架的出现无非是原生开发体验太差，但是我相信，以微信的能力，假以时日能够把小程序原生开发的体验做好。可能是史上最详细的", "underscore", "源码剖析：https://github.com/hanzichi/underscore-analysis程序员都应该学点算法：https://github.com/hanzichi/leetcode了解博主韩子迟：http://www.cnblogs.com/zichi/p/about.htmlGitHub：https://github.com/hanzichi", "Follow", "楼主给楼主更多写作的动力~"]}
{"author": "Rolan", "title": "微信小程序与AspNetCore SignalR聊天实例 ", "content": ["本文不对小程序与signalr做任何介绍,默认读者已经掌握aspnetcore", "Signalr文档小程序文档写在之前SignalR没有提供小程序使用的客户端js,所以本人参考signlar.js写了小程序版signalr-client.js", "代码开源，地址", "https://github.com/liangshiw/SignalRMiniProgram-Client先上效果图开始编码首先需要创建一个aspnetcore的mvc项目，创建完成后我们需要安装signalr的包", "Install-Package", "Microsoft.AspNetCore.SignalR现在就可以创建hub集线器了,首先定义一个类来描述已在线的用户,它需要头像和姓名public", "class", "OnlineClient", "{", "public", "string", "NickName", "{", "get;", "set;", "}", "public", "string", "Avatar", "{", "get;", "set;", "}", "}", "接下来我们在连接创建时，把当前用户做为在线用户添加到字典中,向该用户发送加入成功的系统消息。并且同时向其他的用户发送系统消息public", "override", "async", "Task", "OnConnectedAsync()", "{", "var", "http", "=", "Context.GetHttpContext();", "var", "client", "=", "new", "OnlineClient()", "{", "NickName", "=", "http.Request.Query[\"nickName\"],", "Avatar", "=", "http.Request.Query[\"avatar\"]", "};", "lock", "(SyncObj)", "{", "OnlineClients[Context.ConnectionId]", "=", "client;", "}", "await", "base.OnConnectedAsync();", "await", "Groups.AddToGroupAsync(Context.ConnectionId,", "ChatName);", "await", "Clients.GroupExcept(ChatName,", "new[]", "{", "Context.ConnectionId", "}).SendAsync(\"system\",", "$\"用户{client.NickName}加入了群聊\");", "await", "Clients.Client(Context.ConnectionId).SendAsync(\"system\",", "$\"成功加入{ChatName}\");", "}同样在用户断开连接时做离线处理public", "override", "async", "Task", "OnDisconnectedAsync(Exception", "exception)", "{", "await", "base.OnDisconnectedAsync(exception);", "bool", "isRemoved;", "OnlineClient", "client;", "lock", "(SyncObj)", "{", "isRemoved", "=", "OnlineClients.TryRemove(Context.ConnectionId,", "out", "client);", "}", "await", "Groups.RemoveFromGroupAsync(Context.ConnectionId,", "ChatName);", "if", "(isRemoved)", "{", "await", "Clients.GroupExcept(ChatName,", "new[]", "{", "Context.ConnectionId", "}).SendAsync(\"system\",", "$\"用户{client.NickName}退出了群聊\");", "}", "}", "下面就只有一个简单的发送消息方法了,首先查看当前用户是否在线并做相应处理,如果在线就把当前用户的消息和头像姓名一起发送给组中的其他客户端", "public", "async", "Task", "SendMessage(string", "msg)", "{", "var", "client", "=", "OnlineClients.Where(x", "=>", "x.Key", "==", "Context.ConnectionId).Select(x=>x.Value).FirstOrDefault();", "if", "(client", "==", "null)", "{", "await", "Clients.Client(Context.ConnectionId).SendAsync(\"system\",", "\"您已不在聊天室,请重新加入\");", "}", "else", "{", "await", "Clients.GroupExcept(ChatName,", "new[]", "{", "Context.ConnectionId", "}).SendAsync(\"receive\",", "new", "{", "msg,", "nickName", "=", "client.NickName,", "avatar", "=", "client.Avatar", "});", "}", "}在小程序中，我们需要在页面加载事件中创建与signalr的连接，并且注册system系统消息与receive用户消息两个方法以接收服务端发来的消息onLoad:", "function", "(options)", "{", "this.hubConnect", "=", "new", "Hub.HubConnection();", "this.hubConnect.start(\"https://chat.jingshonline.net/chat\",", "{", "nickName:", "app.globalData.userInfo.nickName,", "avatar:", "app.globalData.userInfo.avatarUrl", "});", "this.hubConnect.onOpen", "=", "res", "=>", "{", "console.log(\"成功开启连接\")", "}", "this.hubConnect.on(\"system\",", "res", "=>", "{", "wx.showModal({", "title:", "'系统消息',", "content:", "res,", "})", "})", "this.hubConnect.on(\"receive\",", "res", "=>", "{", "centendata.push({", "content:", "res.msg,", "time:", "new", "Date().toLocaleString(),", "head_owner:", "res.avatar,", "is_show_right:", "0", "});", "this.setData({", "centendata:", "centendata", "})", "})", "}同样在页面销毁时应断开与signalr服务器的连接onUnload:", "function", "()", "{", "this.hubConnect.close({", "reason:", "\"退出\"", "})", "}发送方法也非常简单,只需要调用sendMessage方法并把用户输入的消息传入就大功告成了，其它就是页面上的处理了this.hubConnect.send(\"sendMessage\",message);完整的代码请去github", "https://github.com/liangshiw/SignalRMiniProgram-Client/tree/master/sample需要注意的是在打开小程序代码时，请修改project.config.json文件中的appid,如果项目不错的话还请大家加个星,顺便再follow一下本人"]}
{"author": "Rolan", "title": "mpvue小程序《校友足迹》成长记（一） ", "content": ["灵感小程序开发进行的热火朝天，自己申请小程序账号也有一段时间了，但是一直没有有所作为，苦于没有一个好点子，不知道该做些什么，基本想到的都有人做了；怎么办？！一次校友聚会后给了我新的想法，因为大家谈到了一个问题，就是怎么把一个城市的校友聚合在一起，回来后我就想到了小程序，现在基本每个人都会有微信，那么就用大家最常用的方式来找到校友，微信小程序即用即走，不用下载，而且受众面很广，很适合来聚合校友；既然想法有了，就开始实际行动吧原型设计灵感来了就开始着手设计基本的原型，最初的功能获取用户位置后，用户选择自己的院校后，可以看到自己学校校友分布的情况，然后可以分享自己校友分布图；最初的原型图很粗糙，未曾美化加工，不过已经上线的版本已经过简单美化，这里使用了原型工具--墨刀的（此处非广告，纯属自己喜欢，哈哈！因为每次做原型图都需要尽快达到自己想要的效果，所以感觉墨刀用起来很顺手），这里的原型图和线上版本会有所差别，后面会提到原因；技术选型前端：", "小程序提供了自己的视图层描述语言，但是喜欢折腾的我却不愿意使用，虽说学习起来也很快，但是由于学了后就只能用在小程序开发上，这就让我很不爽（别吐槽:joy:）；既然不用原生的，那么mpvue就进入了我的眼帘，刚好有段时间没有做vue的项目了，这次刚好可以练练手，不仅可以复习一下vue的知识，而且还可以用Vue来做小程序，简直一举两得了（尽管mpvue有很多坑，但是也阻挡不了我使用的心）；服务端：", "前端开发选型完毕了，接下来就到服务端的选择了，java做服务明显过重，作为可以用js写服务端的node当然是我首要的选择目标了；接下来为了让自己再重新温习一下mysql的curd，当然选择mysql作为数据库存储数据了；插件：", "另外需要用到图表展示，由于工作中经常使用echarts，所以首先想到的是使用它，然而刚开始并不确是否有合适的版本，但是当看到了《在", "mpvue", "使用", "echarts", "小程序组件》这篇文章下的评论区时，让我很是激动（这个作者会不会想打我，明明推荐的是", "echarts-for-weixin", "，可是我却跑到了评论区找到了", "mpvue-echarts", ":joy:），所以这里我采用", "ECharts", "的", "Mpvue", "小程序版本", "，感谢此插件的贡献者F-loatok！技术选型完毕项目构建既然原型和技术已经选择完毕，那就开始项目准备工作；前端目录结构由于mpvue已经帮我们搭建了基本的目录结构，所以无需太多的修改，需要哪些页面只要按照规则进行添加即可；服务端目录结构后端服务拆分了全局配置，router，control和sql相关的配置，由于上线前需要https协议，所以这里加了一个https的配置，上线后会在nginx中进行配置；这里不做过多解释；这里可以看到我使用了", "pm2", "，", "pm2", "是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。这里附上pm2的使用教程", "blog.csdn.net/sunscheung/…数据准备1、由于这个小程序需要中国各个省份和地区，所以需要建立省份与地区的关系，并且需要易于保存，这里省份地区可以很容易在网上找到，而且小程序也提供现成的组件来进行城市地区选择；2、由于是校友，那么就需要整理聚合所有院校的信息了，刚开始只找到了部分院校的数据，而且数据并不是那么全，所以很难保证数据的完整性；后来通过", "中华人民共和国教育部的网站", "，终于找到了最新的院校信息；（截至2017年5月31日，全国高等学校共计2914所，其中：普通高等学校2631所（含独立学院265所），成人高等学校283所。）后来经过其他渠道，找到了香港，台湾，澳门院校34所，所以共计2941所；数据是找到了，但是数据清洗工作却是最为繁琐的，通过筛选和清洗后整理了如下形式，然后依据此形式导入数据库中；既然已经分享这篇文章，那么我就奔着资源共享的原则，如果有需要这些整理好的院校数据的，可以在下方留言，我会把数据发到你的邮箱；功能点1、用户打开小程序后，获取用户的经纬度信息，并根据经纬度信息返回用户所在城市；2、用户确定所在城市后，搜索院校，搜索院系支持模糊搜索功能；3、院校选择完毕后，跳转此院校校友分布情况，并显示top5城市；4、分享自己校友分布情况；采坑点1、由于线上小程序不允许调用授权域名以外的接口，所以需要在服务端实现调用腾讯位置服务api接口，来实现返回用户位置信息；2、由于目前wx.getUserInfo()", "接口有调整，使用该接口将不再出现授权弹窗，请使用", "<button", "open-type=\"getUserInfo\"></button>", "引导用户主动进行授权操作，所以现在获取用户基本信息并没有那么容易了，因此需要用户在下一步操作时引到用户进行授权；（这里只是获取用户的昵称和头像信息，没有任何隐私信息）3、由于", "mpvue-echarts", "还存在一些小的问题，所以当一个页面有两个实例的时候，我的map表就无法点击查看当前城市的人数了；弃用功能1、由于在小范围测试阶段，我发现用户很少会在第一屏页面等待定位完成，而是直接下一步操作，这就导致无法存储用户的位置信息；所以后来我就直接弃用第一屏，直接在服务端处理用户的定位操作并保存，用户只需填写自己的院校即可进入查看分布情况页面；这样也简化了用户的操作步骤，同时也解决了无法保存用户位置的尴尬局面上线版本1、由于没有大面积用户，所以生成的图表并没有那么好看（希望掘金的朋友能够捧捧场，哈哈！后面我会把源代码进行分享的）；我只做了部分假数据进行参考，请勿见怪！后续下一篇文章我将会分享源代码供大家参考，同时也希望大家多提提建议；体验也可在小程序搜索栏搜索---‘校友足迹’，你的使用将会给我带来无比的荣誉，期待你们的到来，谢谢"]}
{"author": "Rolan", "title": "微信小程序朋友圈分享图片生成方案实现 ", "content": ["在小程序界里，生成图片分享到朋友圈这个功能，是如此得光芒耀眼，以至于各个小程序都趋之若鹜地前来跪倒在她的石榴裙下。不幸的是，微信爸爸并没有提供给我们很好很便捷的相关工具；恰恰相反，屏幕截屏的功能被残忍丢进历史的垃圾桶，只留下一个Canvas组件以及围绕在其周围的深渊巨坑们。所以我们准备了一套名为Painter的工具，", "为开发者提供一种简单实用的“绘制”图片的解决思路，让开发者可以自由地生成自己想要的图片文件。github传送门：", "github.com/Kujiale-Mob…如果直接使用canvas进行绘图，那绝对是很酸爽的一次体验，除了失控的代码，还有无数的天坑。先来列举一下canvas", "中踩过的坑以及我们的解决（或绕过）的方法。canvas的坑painter从实现上来讲，是用了小程序的canvas作为载体来实现以上功能的。而canvas有很多著名的坑。有的坑，我们小心翼翼地绕了过去；有的坑，我们还是痛快淋漓地一脚踩了下去……在微信版本6.6.6的某些ios机型上，canvas的clip()方法不能被restore。导致在这些机型上无法进行切圆角的操作。迫于无奈在开发中我们不得已抛弃了这些机型，用了一个if语句将这些机器的切圆角功能阉割了。。。小程序的canvas提供了measuretText()方法，暂时只支持测量文本宽度，无法知道文字的具体高度。因此一些元素对齐的需求无法做到很漂亮。在绘制图片的时候，有几率会发生很神奇的表现，即canvas绘图的时候位置出现整体偏差，造成最后生成的图片有残缺。这种情况大多数时候发生在onLoad中调用painter的情况下。我们处理的方法是对图片的宽和高比例进行检测，一旦出现异常，就重新绘制一遍。canvas不能绘制网络图片。canvas.drawImage(url)方法，给url传入一个网络链接，在模拟器上表现完美，然而在真机上无法绘制。我们在Painter中引入了一套自己的网络图片下载后绘制的机制，并在其中加入了LRU存储管理机制。canvas是原生组件，始终位于视图的最上层，z-index设置对其无效。这个就不多说了。。很多人应该都踩过。canvas要进行绘制，则canvas组件必须真实地被写在页面上，而且其wx:if不能为false。不过，允许把canvas组件放置在屏幕之外，如设置position:fixed;left:750rpx;。这一方法是可以解决5，6两点问题的黑科技Painter的功能如图所示通过右边的类似于css又有点像json但其实上它是个js的寥寥几行代码，我们绘制出了左边的这样的图形，包含了背景图片、文字、图片、二维码这四种常用的元素。Painter阅读完代码，绘制成图片以后，会将图片的链接返回给我们。此时，我们可以将图片上传、保存到本地或者显示在屏幕上。它可以很方便地定制所需要的图片，还可以自由动态地给图片更换风格。此外，小程序canvas.drawImage()方法在真机上不能绘制网络图片。而Painter", "可以解决这个问题，如果有绘制网络图片的需求也可以考虑使用Painter。Painter其它优势painter可以下载网络图片到本地，并对下载到本地的网络内容进行LRU管理。目前小程序允许的最大本地储存为10m，我们默认painter可使用的本地存储为6m，超出时会对本地存储进行清理。如果需要自定义，可以在/painter/lib/downloader.js中修改MAX_SPACE_IN_B属性。目前子", "view", "的", "css", "属性支持", "object", "或", "array。允许将几个view公用的css属性提取出来。由于palette", "是以", "js", "承载的", "json，所以你可以在每一个属性中很方便的加上自己的逻辑。也可以把某些属性单独提取出来，让多个", "palette", "共用，做到模块化。使用demo下载demo项目使用submodule的方式进行管理，因此在clone时需要运行git", "clone", "https://github.com/Kujiale-Mobile/Painter.git", "--recursiveclone完成后可以看到目录。其中，/pages/example中存放的是使用示例，/components/painter就是我们所引入的功能组件。此外还有一个palette目录，里面存放是我们所需要绘图代码。实际工作时，painter会调取card.js里的信息，在图片上绘制出相应的图形，就像一支画笔在调色板上调制蘸取了颜料，然后在画布上创作一样。将Painter引入到自己的项目你可以直接将demo里的painter复制粘贴到自己的项目下，当然也可以更为优雅地运行一下这个代码：git", "submodule", "add", "https://github.com/Kujiale-Mobile/PainterCore.git", "painter它会将Painter工具放置在你当前的目录下。我们推荐的做法是把它放在你的components下。引入组件像其它的组件一样，在需要引入Painter的页面.json文件中添加：\"usingComponents\":{", "\"painter\":\"/components/painter/painter\"", "}组件调用在页面的xml文件中调用painter组件，并传入pallete规则的数据，以及绘制结束以后的回调。<painter", "palette=\"{{data}}\"", "bind:imgOK=\"onImgOK\"", "bind:imgErr=\"onImgErr\"/>palette即是我们的调色板数据，以json形式根据一定规范创建，详细信息请移步下文。绘制回调bind:imgOK=\"onImgOK\"", "bind:imgErr=\"onImgErr\"数据传入后，painter就会开始绘制，无论绘制成功或是失败，都能在相应的回调方法里获取相关的信息，如：Pallette说到底，Painter是一支画笔工具，具体要让这支画笔画什么东西，还得由我们，天资聪颖的程序猿们，来告诉它。告诉它应该画什么，在哪里画，画的时候用什么姿势……等等。这需要用一些别的手段，因为科学的实验证明过，试图用普通话这门语言跟它进行沟通，是不会有任何效果的。调色板属性每一块调色板都它自己的整体属性，它一般规定了整个绘图范围的大小、样式、背景等它处于整个json文件的最外层，需要指定以下几个属性：示例代码：{", "background:", "'https://qhyxpicoss.kujiale.com/2018/06/12/LMPUSDAKAEBKKOASAAAAAAY8_981x600.png',", "width:", "'654rpx',", "height:", "'400rpx',", "borderRadius:", "'20rpx',", "views:", "[]", "}view属性画完了调色板的整体属性以后，就可以向views中增加一些元素了。元素支持四种类型，用type字段进行区分分类。不同种类的view又要求提供有不同的数据，如image元素需要提供它的url，text元素需要提供text文字内容：除了各view的私有属性之外，view还有一些公共属性可以设置：rotate控制元素的旋转，如下图，将一行文字顺时针旋转了6度。{", "type:", "'text',", "text:", "'酷家乐", "移动前端',", "css:", "{", "left:", "'20rpx',", "top:", "'50rpx',", "fontSize:", "'40rpx'", "},", "},效果：borderRadius代码(圆形)：{", "type:", "'image',", "url:", "this.cardInfo.avatar,", "css:", "{", "top:", "'48rpx',", "left:", "'448rpx',", "width:", "'192rpx',", "height:", "'192rpx',", "borderRadius:'96rpx',", "},", "},方角-->8rpx圆角-->圆形align这个属性值比较有意思，它被用来设置元素在水平方向的、相对于位置设置的对齐方式。什么意思呢？比如说你设置了某元素的left为100rpx，并设置align属性为left，那么该元素的左端就与100rpx对齐；若设置align为center，则该元素的中轴线与100rpx对齐。在下面的例子中，三行文字的left都是230rpx，align分别为left,", "center,", "right。红线是横坐标为230rpx的轴线。即，当设置了align属性的时候，left值表达的是元素属性中align的位置。代码：{", "type:", "'text',", "text:", "'酷家乐", "移动前端',", "css:", "{", "left:", "'330rpx',", "top:", "'100rpx',", "fontSize:", "'40rpx',", "},", "},", "{", "type:", "'text',", "text:", "'酷家乐", "移动前端',", "css:", "{", "left:", "'330rpx',", "top:", "'200rpx',", "fontSize:", "'40rpx',", "align:", "'center'", "},", "},", "{", "type:", "'text',", "text:", "'酷家乐", "移动前端',", "css:", "{", "left:", "'330rpx',", "top:", "'300rpx',", "fontSize:", "'40rpx',", "align:", "'right'", "},", "},有了这个属性，就可以设置元素的对齐形式，完成下面的布局要求了：注意：align属性请和left属性配合使用，设置right值将造成错误。align与rotate当align属性与rotate属性同时存在时，元素的旋转表现是以元素的中心点为中心的。尺寸单位目前", "Painter", "中支持两种尺寸单位，px", "和", "rpx，代表的意思和小程序中一致。目前还没有很好地支持百分比的使用。保存图片演示获得图片的url后，可以设置一个点击按钮，点击保存到本地onImgOK(e)", "{", "this.imagePath", "=", "e.detail.path;", "},", "saveImage()", "{", "wx.saveImageToPhotosAlbum({", "filePath:", "this.imagePath,", "})", "},按钮绑定saveImage方法，点击进行保存：生成朋友圈分享图最后，利用Painter工具可以生成不同样式的朋友圈分享图(下图为微信小程序", "酷咖名片", "线上版部分截图)"]}
{"author": "Rolan", "title": "小程序入门总结篇 ", "content": ["须知App()", "必须在", "app.js", "中注册，且不能注册多个。编译后的代码包大小需小于", "1MB", "，否则代码包将上传失败。每个页面需要手动在", "app.json", "中进行注册，否则不能访问。app.json", "中", "pages", "数组的第一项代表小程序的初始页面，小程序中新增/减少页面，都需要对", "pages", "数组进行修改。直接修改", "this.data", "无效，无法改变页面的状态，还会造成数据不一致。单次设置的数据不能超过", "1024kB", "，请尽量避免一次设置过多的数据。不要尝试修改页面栈，会导致路由以及页面状态错误。tabBar", "只能配置最少2个、最多5个，", "tab", "按数组的顺序排序。小程序页面只能同时打开", "5", "个，如果交互流程较长难以支持。同时只能存在", "5", "个", "url", "请求。无法跳转小程序以外的", "url", "。没有", "cookie", "。没有开放加载", "web", "页面没有a标签链接，不可嵌套", "iframe没有", "window", "变量，但微信提供了wx全局方法集事件绑定和条件渲染类似", "Angular", "，全部写在", "WXML", "中1.1", "主体由", "app.js", "、", "app.json", "、", "app.wxss", "三个文件组成，放在根目录app.js", "根目录的", "app.js", "很有用,因为在它内部注册的变量或方法，都是可以被所有页面获取到。可以监听并处理小程序的生命周期、声明全局变量。其余的", ".js", "文", "件可以通过", "var", "app", "=", "getApp()", "获取其实例，调用其中定义的方法和变量，但不可以调用生命周期的方法app.json", "是小程序的全局配置pages", "配置小程序的组成页面，第一个代表小程序的初始页面", "window", "设置小程序的状态栏、标题栏、导航条、窗口背景颜色", "tabBar", "配置小程序tab栏的样式和对应的页面", "app.wxss", "是小程序的公共样式表，可以在其他", ".wxss", "文件中直接使用app.json\"pages\":", "[", "//设置页面的路径", "\"pages/index/index\",", "//不需要写index.wxml,index.js,index,wxss,框架会自动寻找并整合", "\"pages/logs/logs\"", "],", "\"window\":", "{", "//设置默认窗口的表现形式", "\"navigationBarBackgroundColor\":", "\"#ffffff\",", "//顶部导航栏背景色", "\"navigationBarTextStyle\":", "\"black\",", "//顶部导航文字的颜色", "black/white", "\"navigationBarTitleText\":", "\"微信接口功能演示\",", "//顶部导航的显示文字", "\"backgroundColor\":", "\"#eeeeee\",", "//窗口的背景色", "\"backgroundTextStyle\":", "\"light\",", "//下拉背景字体、loading", "图的样式，仅支持", "dark/light", "\"enablePullDownRefresh\":", "\"false\"，", "//是否支持下拉刷新", "，不支持的话就直接不写！", "\"disableScroll\":", "true,", "//", "设置true不能上下滚动，true/false，注意！只能在", "page.json", "中有效，无法在", "app.json", "中设置该项。", "},", "\"tabBar\":", "{", "//底部tab或者顶部tab的表现，是个数组，最少配置2个，最多5个", "\"list\":", "[{", "//设置tab的属性，最少2个，最多5个", "\"pagePath\":", "\"pages/index/index\",", "//点击底部", "tab", "跳转的路径", "\"text\":", "\"首页\",", "//tab", "按钮上的文字", "\"iconPath\":", "\"../img/a.png\",", "//tab图片的路径", "\"selectedIconPath\":", "\"../img/a.png\"", "//tab", "在当前页，也就是选中状态的路径", "},", "{", "\"pagePath\":", "\"pages/logs/logs\",", "\"text\":", "\"日志\"", "}],", "\"color\":", "\"red\",", "//tab", "的字体颜色", "\"selectedColor\":", "\"#673ab7\",", "//当前页", "tab", "的颜色，也就是选中页的", "\"backgroundColor\":", "\"#2196f3\",", "//tab", "的背景色", "\"borderStyle\":", "\"white\",", "//边框的颜色", "black/white", "\"position\":", "\"bottom\"", "//tab处于窗口的位置", "top/bottom", "},", "\"networkTimeout\":", "{", "//默认都是", "60000", "秒一分钟", "\"request\":", "10000,", "//请求网络超时时间", "10000", "秒", "\"downloadFile\":", "10000，", "//链接服务器超时时间", "10000", "秒", "\"uploadFile\":", "\"10000\",", "//上传图片", "10000", "秒", "\"downloadFile\":", "\"10000\"", "//下载图片超时时间", "10000", "秒", "},", "\"debug\":", "true", "//项目上线后，建议关闭此项，或者不写此项", "1.2", "pagespages", "文件夹里是小程序的各个页面，每个界面一般都由", ".wxml", "、", ".wxss", "、", ".js", "、", ".json四个文件组成，四个文件必须是相同的名字和路径.js", "是页面的脚本代码，通过", "Page()", "函数注册页面。可以指定页面的初始数据、生命周期、事件处理等.wxml", "是页面的布局文件，只能使用微信定义的组件.wxss", "是样式表，需要注意尺寸单位：", "rpx", "可以根据屏幕的宽带进行自适应样式导入：", "@import", "导入外联样式表，如：", "@import", "\"test.wxss\"", ";定义在", "app.wxss", "中的全局样式，作用于每个页面。定义在", "page", "的", ".wxss", "文件只作用于对应的页面，会覆盖", "app.wxss", "中相同的选择器.json", "是页面的配置文件，只能设置", "app.json", "中的", "window", "配置内容，会覆盖", "app.json", "中", "window", "的相同配置项，即使不配置任何东西也需要写", "{}", ",否则会报错1.3", "utilsutils", "里面包含一些公共的代码抽取的", "js", "文件，作为模块方便使用。模块通过", "module.exports", "对外暴露接口其他地方使用是", "var", "utils", "=", "require('../../utils/util.js')", "进行引用二、视图层", "WXML2.1", "数据绑定传统的视图和数据绑定那么微信小程序是通过什么方法来管理视图和对象绑定的呢,状态模式-单向数据流数据流向是单向的，即视图变化不会影响对象状态UI", ".wxml", "中的动态数据都来自", "Page", "中的", "data", "。数据绑定使用数据绑定使用双大括号将变量包起来，可以作用于内容、组件属性(需要在双引号之内)、控制属性(需要在双引号之内)、关键字(需要在双引号之内)Page({", "data:", "{", "message:", "\"Hello\",", "id:0,", "status:", "true", "}", "})", "<view>", "{{message}}", "view>", "<view", "id=\"item-{{id}}\">", "view>", "<view", "wx:if=\"{{status}}\">", "view>", "<view", "hidden=\"{{status}}\">", "checkbox>", "还可以进行简单的运算在大括号里<view", "hidden=\"{{status", "?", "true", ":", "false}}\">", "Hidden", "view>", "<view>", "{{a", "+", "b}}", "+", "c", "view>", "<view", "wx:if=\"{{num", ">", "6}}\">", "view>", "<view>{{\"hello\"", "+", "word}}view>", "2.2", "条件渲染用", "wx:if=””", "来判断是否渲染代码块<view", "wx:if=\"{{status}}\">", "isShow", "view>", "还可以添加", "else", "块<view", "wx:if=\"{{num", ">", "5}}\">", "A", "view>", "<view", "wx:elif=\"{{num", ">", "2}}\">", "B", "view>", "<view", "wx:else>", "C", "view>", "2.3", "列表渲染在组件上使用", "wx:for", "属性绑定一个数组，就可以渲染组件了默认情况下数组的当前下标变量名为", "index", ",当前项的变量名为", "item<view", "wx:for=\"{{array}}\">", "{{index}}:", "{{item.message}}", "view>", "Page({", "data:", "{", "array:", "[\"AA\",\"BB\",\"CC\"]", "}", "})", "使用", "wx:for-item", "可以指定数组当前元素的变量名，使用", "wx:for-index", "可以指定数组当前下标的变量名<view", "wx:for=\"{{array}}\"", "wx:for-index=\"num\"", "wx:for-item=\"itemName\">", "{{num}}:", "{{itemName}}", "view>", "2.4", "模板templatename", "定义组件模版的名称，引用模版的时候使用", "is", "属性指定模版的名字，", "is", "可以进行简单的三目运算，需要传入模版需要的", "data", "数据。因为模版拥有自己的作用域，所以只能使用", "data", "传入数据，而不接受双花括号的写法<template", "name=\"msgItem\">", "<view>", "<text>", "{{index}}:", "{{msg}}", "text>", "<text>", "Time:", "{{time}}", "text>", "view>", "template>", "<template", "is=\"msgItem\"", "data=\"{{...item}}\"/>", "2.5", "公共模块的引用WXML", "提供", "import", "和", "include", "两种文件引用方式。import", "有作用域的概念，不能多重引用", "<import", "src=\"a.wxml\"/>", "<template", "name=\"A\">", "<text>", "A", "template", "text>", "template>", "include", "就可以多重引用", "<include", "src=\"header.wxml\"/>", "<view>", "body", "view>", "<view>", "header", "view>", "<include", "src=\"footer.wxml\"/>", "2.6", "事件名称以", "bind", "开头的事件不阻止冒泡，名称以", "catch", "开头的事件冒泡是阻止的。如", "bindTap和", "catchTab在", "WXM", "L", "中，可以使用", "dataset", "定义", "data", "中的数据，会通过事件传递。它的事件以", "data-开头，多个单词以", "-", "链接，如", "data-a-b三、生命周期3.1", "App()应用生命周期onLaunch", "onShow", "onHide", "onShow", "onError", "前台、后台定义：", "当用户点击左上角关闭，或者按了设备", "Home", "键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台//app.js", "App({", "onLaunch:", "function()", "{", "//小程序初始化(全局只触发一次)", "},", "onShow:", "function()", "{", "//小程序显示", "},", "onHide:", "function()", "{", "//小程序隐藏", "},", "onError:", "function(msg)", "{", "//小程序错误", "},", "})", "//其他", "开发者可以添加任意的函数或数据到", "Object", "参数中，用", "this", "可以访问", "3.2", "Page页面生命周期每个页面也有自己的生命周期小程序注册完成后，加载页面，触发", "onLoad", "方法。页面载入后触发", "onShow", "方法，显示页面。首次显示页面，会触发", "onReady", "方法，渲染页面元素和样式，一个页面只会调用一次。当小程序后台运行或跳转到其他页面时，触发", "onHide", "方法。当小程序有后台进入到前台运行或重新进入页面时，触发", "onShow", "方法。当使用重定向方法", "wx.redirectTo(OBJECT)", "或关闭当前页返回上一页", "wx.navigateBack()", "，触发", "onUnload//index.js", "Page({", "onLoad:", "function(options)", "{", "//页面加载-----(一个页面只会调用一次)", "},", "onReady:", "function()", "{", "//页面渲染-----(一个页面只会调用一次)", "},", "onShow:", "function()", "{", "//页面显示-----(每次打开页面都会调用一次)", "},", "onHide:", "function()", "{", "//页面隐藏-----(当navigateTo或底部tab切换时调用)", "},", "onUnload:", "function()", "{", "//页面卸载-----(当redirectTo或navigateBack的时候调用)", "},", "})", "//其他", "开发者可以添加任意的函数或数据到", "object", "参数中，在页面的函数中用", "this", "可以访问", "3.3", "应用生命周期影响页面生命周期小程序初始化完成后，页面首次加载触发", "onLoad", "，只会触发一次。当小程序进入到后台，先执行页面", "onHide", "方法再执行应用", "onHide", "方法。当小程序从后台进入到前台，先执行应用", "onShow", "方法再执行页面", "onShow", "方法四、小程序限制4.1", "程序限制脚本内不能使用", "window", "等对象zepto/jquery", "会使用到", "window", "对象和", "document", "对象，所以无法使用。样式表不支持级联选择器本地资源无法通过", "css", "获取", "background-image", "可以使用网络图片，或者", "base64", "，或者使用标签不支持", "A", "标签，无法打开普通网页4.2", "数量限制底部或顶部可以添加", "tab", "按钮区域", "tabBar", "是一个数组，只能配置最少2个、最多5个", "tab", "，", "tab", "按数组的顺序排序。一个应用同时只能打开5个页面小程序的", "wx.request", "请求最开始最大并发数是5个，后来，估计随着用小程序的越来越多，总之，就是增加到了10个4.3", "大小限制tabBar", "上面的按钮", "iconPath", "图片路径，", "icon", "大小限制为", "40kbtabBar", "上面的按钮", "selectedIconPath", "选中时的图片路径，", "icon", "大小限制为", "40kbsetData", "页面传递数据单次设置的数据不能超过", "1024kBsetStorage", "本地缓存最大为", "10MB小程序源码打包后的大小限制为", "1M五、路由微信路由接口有三个，分别是", "wx.redirectTo", "、", "wx.navigateTo", "和", "wx.switchTab", "wx.navigateTo", "全局最多调用5次如果某页面设置为", "tab", "页，则只支持", "wx.switchTab", "，不支持其他两种路由方式访问5.1", "哪些情况会触发页面跳转小程序启动，初始化第一个页面打开新页面，调用", "API", "wx.navigateTo", "或使用", "组件页面重定向，调用", "API", "wx.redirectTo", "或使用", "组件页面返回，调用", "API", "wx.navigateBack", "或用户按左上角返回按钮tarbar", "切换5.2", "如何跳转页面使用", "wx.navigateTo", "接口跳转,原页面保留wx.navigateTo({", "//目的页面地址", "url:", "'pages/logs/index',", "success:", "function(res){},", "...", "})", "使用", "wx.redirectTo", "接口跳转，关闭原页面,不能返回wx.redirectTo({", "//目的页面地址", "url:", "'pages/logs/index',", "success:", "function(res){},", "...", "})", "5.3", "使用组件\"pages/logs/index\"", "hover-class=\"navigator-hover\">跳转", "当该组件添加", "redirect", "属性时，等同于", "wx.redirectTo", "接口；默认", "redirect", "属性为", "false，等同于", "wx.navigateTo", "接口用户点击左上角返回按钮，或调用", "wx.navigateBack", "接口返回上一页wx.navigateBack({", "delta:", "1", "})", "delta", "为1时表示返回上一页，为2时表示上上一页，以此类推；如果dalta大于已打开的页面总数，则返回到首页。返回后，元界面会销毁5.4", "页面跳转传值url?key=value&key1=value1", "传递的参数没有被", "URIEncode", ",传递中文没有乱码5.5", "如何正确使用页面跳转官方规定小程序最多只能有五个页面同时存在，意思是在不关闭页面的情况，最多新开五个页面，页面深度为5对于可逆操作，使用", "wx.navigateTo", ",比如从首页跳转到二级页面，从二级页面返回是不需要重新渲染首页对于不可逆操作，使用", "wx.redirectTo", ",比如用户登录成功后，关闭登录页面，不能返回到登录界面。对于一些介绍性等不常用页面", "wx.redirectTo", "或", "wx.navigatrBack不要在首页使用", "wx.redirectTo", "，这样会导致应用无法返回首页5.6", "页面栈getCurrentPages()", "使用wx.navigateTo每新开一个页面，页面栈大小加1,直到页面栈大小为5为止使用wx.navigateTo重复打开界面假如使用wx.navigateTo从四级页面跳转到二级页面，此时会在页面栈顶添加一个与二级页面初始状态一样的界面，但两个页面状态是独立的。页面栈大小会加1，如果页面栈大小为5，则wx.navigateTo无效使用wx.redirectTo重定向假如使用wx.redirectTo从四级页面重定向到二级页面，此时会将关闭四级页面，并使用二级页面替换四级页面，但两个页面状态是独立的。此时的页面栈大小不变，请注意和使用wx.navigateTo的区别使用wx.navigateBack返回总结wx.navigateTo", "wx.redirectTo", "wx.navigateBack", "六、数据通信6.1", "页面之间的通信app.globalData", "wx.setStorageSync", "url", "//", "A页面-传递数据", "//", "需要注意的是，wx.switchTab", "中的", "url", "不能传参数。", "wx.navigateTo({", "url:'../pageD/pageD?name=raymond&gender=male'", "})", "//", "B页面-接收数据//", "//通过onLoad的option...", "Page({", "onLoad:", "function(option){", "console.log(option.name", "+'is'+", "option.gender)//", "raymond", "is", "male", "this.setData({option:", "option", "})", "}})", "6.2", "参数传递6.2.1", "小程序传递参数的方式1、通过在", "App.js", "中设置全局变量通常把不会更改的数据放在", "app.js", "的", "Data", "中，在各个页面中都可以通过", "APP", "实例获取", "Data", "数据var", "app", "=", "getApp();", "var", "data", "=", "app.data;", "2、通过拼接", "URL", "直接传递wx.navigateTo({})", "中", "URL", "携带参数wx.navigateTo({", "url:", "'test?id=1'", "});", "在wxml中使用", "navigator", "跳转url传递参数代码如下，将要传递到另一个页面的字符串testId的值赋值到url中class=\"test-item\"", "url=\"../../pages/test/test?testId={{testData.testId}}\">navigator>", "在", "js", "页面中", "onLoad", "方法中接收Page({", "onLoad:", "function(options)", "{", "var", "testId", "=", "options.testId", "console.log(testId)", "}", "})", "navigator", "跳转", "url", "传递数组如果一个页面要将一个数组，如相册列表传递到另一个页面class=\"test-item\"", "url=\"../../pages/test/test?albumList={{testData.albumList}}\">navigator>", "传递到js后从", "options", "中得到的是个字符串，每个图片的url通过’,’分隔，所以此时还需要对其进行处理，重新组装为数组Page({", "data:", "{", "//", "相册列表数据", "albumList:", "[],", "},", "onLoad:", "function", "(options)", "{", "var", "that", "=", "this;", "that.setData({", "albumList:", "options.albumList.split(\",\")", "});", "}", "})", "3、在wxml中绑定事件后，通过", "data-hi=\"参数\"", "的方式传递这种方式一般是在wxml中绑定事件，同时设置需要传递的数据，如果需要传递多个，可以写多个", "data-[参数]", "的方式进行传递<view", "bindtap=\"clickMe\"", "data-testId={{testId}}\">", "...", "view>", "在js页面中自定义方法clickMe中接收Page({", "clickMe:", "function(event)", "{", "var", "testId", "=", "event.currentTarget.dataset.testid;", "wx.navigateTo({", "url:", "'../../pages/test/test'", "})", "}", "})", "wxml中配置data-albumlist传递数组<view", "bindtap=\"clickMe\"", "data-albumlist={{testData.albumList}}\">", "view>", "在js页面中自定义方法clickMe中接收", "Page({", "clickMe:", "function(event)", "{", "var", "albumList", "=", "event.currentTarget.dataset.albumlist.split(\",\");", "wx.navigateTo({", "url:", "'../../pages/test/test'", "})", "}", "})", "4、通过数据缓存存储再获取wx.setStorageSync(KEY,DATA)", "存储数据try", "{", "wx.setStorageSync('key',", "'value')", "}", "catch", "(e)", "{", "}", "wx.getStorageSync(KEY)", "获取数据try", "{", "var", "value", "=", "wx.getStorageSync('key')", "if", "(value)", "{", "//", "Do", "something", "with", "return", "value", "}", "}", "catch", "(e)", "{", "//", "Do", "something", "when", "catch", "error", "}", "或", "wx.getStorage({", "key:", "'key',", "success:", "function(res)", "{", "console.log(res.data)", "}", "})", "七、疑问汇总为什么脚本内不能使用window等对象页面的脚本逻辑是在", "JsCore", "中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用", "window", "，也无法在脚本中操作组件为什么", "zepto/jquery", "无法使用zepto/jquery", "会使用到", "window", "对象和", "document", "对象，所以无法使用wx.navigateTo无法打开页面一个应用同时只能打开5个页面，当已经打开了5个页面之后，", "wx.navigateTo", "不能正常打开新页面。请避免多层级的交互方式，或者使用", "wx.redirectTo样式表不支持级联选择器WXSS", "支持以", ".", "开始的类选择器本地资源无法通过", "css", "获取background-image", "：可以使用网络图片，或者", "base64", "，或者使用", "标签如何修改窗口的背景色使用", "page", "标签选择器，可以修改顶层节点的样式page", "{", "display:", "block;", "min-height:", "100%;", "background-color:", "red;", "}", "为什么上传不成功为了提升体验流畅度，编译后的代码包大小需小于", "1MB", "，大于", "1MB", "的代码包将上传失败HTTPS", "请求不成功tls", "仅支持", "1.2", "及以上版本微信小程序支持fetch或者promise吗?promise", "工具目前不支持，", "fetch", "客户端不支持", "工具下个版本保持统一wx.request的POST方法的参数传输服务器接收不到的bugwx.request", "post", "的", "content-type", "默认为", "‘application/json", "'如果服务器没有用到", "json", "解释的话，可以把", "content-type", "设置回", "urlencodedwx.request({", "....", "method:", "\"POST\",", "header:", "{", "\"content-type\":", "\"application/x-www-form-urlencoded\"", "},", "...", "})", "wx.uploadFile在手机上返回http码403安卓的微信升级到6.5.2及其以上版本小程序SVG支持吗?image", "的src放远程svg可以，", "background-image", "里也可以ipad不能使用小程序？暂时不支持ipad打开小程序请问小程序页内支持长按保存图片或分享图片吗？目前没有这个功能微信小程序不支持cookie使用", "Reids", "存储", "session有些手机不支持Object.assign方法，如果使用了该方法会出现莫名其妙的报错（并不会提示Object.assign", "is", "not", "function，而是导致调用了Object.assign方法的方法不能被调用）！直接写一个合并对象的方法function", "assignObject(o,", "n)", "{", "for", "(var", "p", "in", "n)", "{", "if", "(n.hasOwnProperty(p)", "&&", "(!o.hasOwnProperty(p)))", "o[p]", "=", "n[p];", "}", "}"]}
{"author": "Rolan", "title": "「小程序JAVA实战」微信小程序简介（一） ", "content": ["一直想学习小程序，苦于比较忙，加班比较多没时间，其实这都是理由，很多时候习惯了搬砖，习惯了固定的圈子很难，也不想涉足其他的领域，但是也不能老错过一波又一波新鲜的东西吧。09年就接触微信，2013年才开始公众号开发，入行就接触C，2014年才开始IOS开发，红利期都错过了，这次必须尽快涉足了。建立这个专辑就是督促自己每天的坚持和进步。你有你的php，我有我的小java，不是很大但是够用。学习任何东西先了解历史：2016年1月11日，微信之父张小龙时隔多年的公开亮相，解读了微信的四大价值观。张小龙指出，越来越多产品通过公众号来做，因为这里开发、获取用户和传播成本更低。拆分出来的服务号并没有提供更好的服务，所以微信内部正在研究新的形态，叫「微信小程序」。2016年9月21日，微信小程序正式开启内测。在微信生态下，触手可及、用完即走的微信小程序引起广泛关注。腾讯云正式上线微信小程序解决方案，提供小程序在云端服务器的技术方案。2017年1月9日0点，万众瞩目的微信第一批小程序正式低调上线，用户可以体验到各种各样小程序提供的服务。2017年12月28日，微信更新的", "6.6.1", "版本开放了小游戏，微信启动页面还重点推荐了小游戏「跳一跳」，你可以通过「小程序」找到已经玩过的小游戏。2018年1月18日，微信提供了电子化的侵权投诉渠道，用户或者企业可以在微信公众平台以及微信客户端入口进行投诉。2018年1月25日，微信团队在“微信公众平台”发布公告称，“从移动应用分享至微信的小程序页面，用户访问时支持打开来源应用。同时，为提升用户使用体验，开发者可以设置小程序菜单的颜色风格，并根据业务需求，对小程序菜单外的标题栏区域进行自定义2018年3月，微信正式宣布小程序广告组件启动内测，内容还包括第三方可以快速创建并认证小程序、新增小程序插件管理接口和更新基础能力，开发者可以通过小程序来赚取广告收入。", "[5]", "除了公众号文中、朋友圈广告以及公众号底部的广告位都支持小程序落地页投放广告，小程序广告位也可以直达小程序。2018年7月13日，小程序任务栏功能升级，新增“我的小程序”板块；而小程序原有的“星标”功能升级，可以将喜欢的小程序直接添加到“我的小程序”。了解它的内在微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同事具有出色的使用体验。手机端app的另外一种新的展现形式。无需下载过多占用手机内存的app，小程序直接打开。小程序诞生1年多，处于成长阶段，各种机制、规则不够完善，给一些人带来极大的便利。现在扎根在小程序一线的玩家（不是小打小闹那种，他们月利润达数百万级别），他们普遍认同：小程序未来3-5年的市场体量将会比公众号体量要大；不过有公众号做为参考，公众号也是前几个月由测试版转为正式版，基本定型，有了公众号的运营经验做为参考，小程序成长更快，2018年将会得到大发展，小程序玩家能“乱世”出英雄的概率下降，所以要趁早。必须具备的技能htmljavascriptcss适用小程序的场景基于腾讯的庞大的社交群体，可以往app引流。个人和创业公司优先使用小程序，开发成本低。当做简单的工作使用，方便查询。通过游戏赚钱的，挑一挑。PS：对于微信而言：架设了一个足够轻的插件桥梁系统，可以服务于巨大的社交容器，让各种关系链和服务的通道更加舒畅，提升了用户体验，也让用户更多留在了微信生态中。对于开发者而言：微信开放了自身能力和部分关系链，只要开发者找准了微信生态中细分用户场景，就能做更好地服务，无疑是巨大的福音。对于用户而言：用户体验得到了大幅提升，在不同使用场景有不同的小程序解决方案，应用将无处不在，又无需下载，真正“触手可及、用完即走”。加油，小程序！>>原创文章，欢迎转载。转载请注明：转载自IT人故事会，谢谢！>>原文链接地址：「小程序JAVA实战」微信小程序简介（一）"]}
{"author": "Rolan", "title": "「小程序JAVA实战」微信小程序的简要注册流程（二） ", "content": ["了解了小程序的历史和它未来的前景，我们开始注册小程序注册小程序可以参考官网介绍：https://developers.weixin.qq.com/miniprogram/introduction/index.html?t=201874打开网址：在微信公众平台官网首页（mp.weixin.qq.com）点击右上角的“立即注册”按钮选择“小程序”，点击“查看类型区别”可查看不同类型帐号的区别和优势。请填写未注册过公众平台、开放平台、企业号、未绑定个人号的邮箱。登录邮箱，查收激活邮件，点击激活链接。请选择主体类型选择，完善主体信息和管理员信息。登录小程序，完善小程序信息添加开发人员APPID", "后期开发的时候需要使用PS：按照这个步骤基本的注册流程也就完成了，必须要注册啊这可是基石，有了它才有了下面的一系列工作。>>原创文章，欢迎转载。转载请注明：转载自IT人故事会，谢谢！>>原文链接地址：「小程序JAVA实战」微信小程序的简要注册流程（二）"]}
{"author": "Rolan", "title": "微信小程序--旋转木马/缩放轮播图效果 ", "content": ["话不多说先上图.gif文章涉及技术点微信小程序原生Swiper控件", "Wxss", "Transform、Transition", "轮播条滚动回调控制", "微信小程序条件渲染、列表渲染", "全部实现代码加起来也就三四十行，大部分还用来写wxml", "UI代码，所以功能实现起来非常简单。", "首先将问题简单化，能用原生组件实现出我们想要的效果，绝不自己开发Component。原因：我懒+我自己写的也不敢说性能堪比原生组件先来分析一波gif中我们需要实现效果和哪些效果可以直接修改原生Swiper的属性就能实现的我们需要自己实现的功能自动滚动+手动拖拽", "（原生组件帮我们完成", "Property：autoplay）", "面板指示点", "（原生组件帮我们完成", "Property：indicator-dots）", "左右可以露出非Active状态图的边缘（即Quiet状态，", "后文class会以这两个名字定义）", "（原生组件帮我们完成", "Property：previous-margin、next-margin）", "图片滚动到中心位置放大，滚动出去缩小", "（我们手写实现，利用技术点中提到的滚动回调+条件渲染。其中滚动回调用", "Property：bindchange）", "这样看下来就很清晰了，需要我们实现的只有一个动画放大缩小。再进一步就能分成两种实现方式:wxss实现", "js实现很显然wxss实现代码很少也能达到同样的效果，so~//.wxml", "<swiper", "class='swiperClass'", "autoplay", "indicator-color=\"#a39f99\"", "indicator-active-color=\"#f49641\"", "indicator-dots", "interval=\"2000\"", "duration=\"1000\"", "previous-margin=\"30px\"", "next-margin=\"30px\"", "circular", "bindchange=\"bindchange\"", "style='height:", "{{swiperHeight}}px'>", "<block", "wx:for=\"{{imgUrls}}\"", "wx:key=\"{{index}}\">", "<swiper-item>", "<image", "src=\"{{item}}\"", "class=\"slide-image", "{{swiperIndex", "==", "index", "?", "'active'", ":", "'quiet'}}\"", "mode='aspectFill'>", "</image>", "</swiper-item>", "</block>", "</swiper>//.wxss.swiperClass", "{", "margin:", "0;", "margin-top:", "10px;}.slide-image", "{", "width:", "100%;", "height:", "90%;", "border-radius:", "10px;", "position:", "relative;}image.active", "{", "transform:", "none;", "transition:", "all", "0.2s", "ease-in", "0s;}", "image.quiet", "{", "transform:", "scale(0.8333333);", "transition:", "all", "0.2s", "ease-in", "0s;}//.jsdata:", "{", "imgUrls:", "[", "'xxx',", "'xxx',", "'xxx',", "'xxx'", "],", "swiperIndex:", "0", "//这里不写第一次启动展示的时候会有问题", "},bindchange(e)", "{", "this.setData({", "swiperIndex:", "e.detail.current", "})", "},上面Swiper控件里面还有设置宽高的属性就随便填几个数测试就好了，不影响主要功能。注意身体，小心秃顶"]}
{"author": "Rolan", "title": "简易商城小程序全栈开发(mpvue+koa+mongodb) ", "content": ["接触小程序有一段时间后并且多多少少做了一些项目之后，又开始了vue的旅程，受其核心思想的影响，对数据/状态管理、组件化、跨平台等都有较高的追求，mpvue", "是一个使用", "Vue.js开发小程序的前端框架，由此开始了mpvue踩坑之旅，想在提高代码可读性的同时，也增加一点vue.js的开发体验。技术栈前端：", "微信小程序、mpvue后端：koa数据库：mongodb", "数据库可视化工具：Robo3T商城小程序开跑一个基本的商城小程序，包含了前端的首页、分类、购物车、我的(订单)四个tab页，后端的数据定义、分类、和存取。各有其色，我在下面就相应介绍一些主要功能、对比原生小程序和vue.js所踩到的坑还有后端数据库的功能应用。", "想了解或者有何问题都可以去", "作品源码", "中了解哦。成果分享一、前台页面及功能展示首页：加入购物车：购物车全选结算：地址管理：1.", "谈组件封装举个栗子说，首页由三部分组成:头部轮播推荐+中间横向滑动推荐+纵向滚动商品list。这三部分，几乎是所有商城类app必需的功能了。头部的轮播推荐、中间的横向滑动式推荐的封装，我们都知道，诸如此类的功能组件，在各app上基本都少不了，最初学vue最先有所体会的，便是组件代码复用性高的特点，在进行一些组件复用迁移至别的组件或页面时，可能都不需要改动代码或者改动少量代码就可以直接使用，可以说是相当方便了，对于mpvue组件内仍然支持原生小程序的swiper与scroll，两者兼容后，对于熟知小程序和vue的开发者，这项功能可以很高效率地完成。最后主页面文件就是由一个个组件组成，可读性很强了，对于初学者来说，模块封装的思想是首先就得具备的了。<template>", "<div", "class=\"container\"", "@click=\"clickHandle('test", "click',", "$event)\">", "<div", "class=\"swiperList\">", "<swiper", ":text=\"motto\"", ":swiperList=\"swiperlist\"></swiper>", "</div>", "<div", "class=\"navTab\">", "<div", "class=\"recTab\">", "<text>", "——", "为你推荐", "——</text>", "</div>", "</div>", "<scroll></scroll>", "<div", "class=\"hot\">", "<span>", "——", "热门商品", "——</span>", "</div>", "<hot", ":v-text=\"motto\"></hot>", "<div", "class=\"fixed-img\">", "<img", ":src=\"fixImg\"", "alt=\"\"", "class=\"fix-img\">", "</div>", "</div>", "</template>", "复制代码不过关于组件封装与组合的问题，由于最近有研究vue性能优化和用户体验的一些知识点，考虑了一个比较严肃的问题：先看一下常见的vue写法：在html里放一个app组件，app组件里又引用了其他的子组件，形成一棵以app为根节点的组件树：<body>", "<app></app>", "</body>", "复制代码而这种做法就引发了性能问题，要初始化一个父组件，必然需要先初始化它的子组件，而子组件又有它自己的子组件。那么要初始化根标签，就需要从底层开始冒泡，将页面所有组件都初始化完。所以我们的页面会在所有组件都初始化完才开始显示。这个结果显然不是我们要的，用户每次点开页面，还要面对一阵子的空白和响应，因为页面启动后不止要响应初始化页面的组件，还有包含在app里的其他组件，这样严重拖慢了页面打开的速度。更好的结果是页面可以从上到下按顺序流式渲染，这样可能总体时间增长了，但首屏时间缩减，在用户看来，页面打开速度就更快了。网上一些办法大同小异，各有优缺点，所以...本人也在疯狂试验中，静待好消息。**2.Class、Style的绑定", "**在不同父组件中引用同一子组件时，但是各自需要接收绑定的动态样式去呈现不同的样式，在绑定css", "style样式这一关上，踩了个大坑：mpvue居然不支持用object的形式传style，起先处于样式一直上不去的抓狂当中,网上对于mpvue这方面的细节也少之又少，后来查找了许多地方，发现class和style的绑定都是不支持classObj和styleObj形式，就尝试用了字符串，果然...改代码改到怀疑人生，结果你告诉我人生起步就是错误，怎能不心痛？...解决：<template>", "<div", "class=\"swiper-list\">", "<d-swiper", ":swiperList=\"swiperlist\"", ":styleObject=\"styleobject\"></d-swiper>", "</div>", "</template>", "<script>", "data()", "{", "return", "{", "styleobject:'width:100%;height:750rpx;position:absolute;top:0;z-index:3'", "}", "}", "</script>", "复制代码3.", "“v-for嵌套”陷阱在做vue项目的时候难免会用到循环，需要用到index索引值，但是v-for在嵌套时index没办法重复用，内循环与外循环不能共用一个index。<swiper-item", "v-for=\"(items,index)", "in", "swiperList\"", ":key=\"index\">", "<div", "v-for=\"item", "in", "items\"", "class=\"swiper-info\"", ":key=\"item.id\"", "@click=\"choose\"", ">", "<image", ":src=\"item.url\"", "class=\"swiper-image\"", ":style=\"styleObject\"/>", "</div>", "</swiper-item>", "复制代码以上代码就会报错：而给内循环再加上另一个索引，便没有报错：<swiper-item", "v-for=\"(items,index)", "in", "swiperList\"", ":key=\"index\">", "<div", "v-for=\"(item,i)", "in", "items\"", "class=\"swiper-info\"", ":key=\"i\"", "@click=\"choose\"", ">", "<image", ":src=\"item.url\"", "class=\"swiper-image\"", ":style=\"styleObject\"/>", "</div>", "</swiper-item>", "复制代码4.this指向问题与箭头函数的应用这是vue文档里的原话：All", "lifecycle", "hooks", "are", "called", "with", "their", "'this'", "context", "pointing", "to", "the", "Vue", "instance", "invoking", "it.意思是：在Vue所有的生命周期钩子方法（如created，mounted，", "updated以及destroyed）里使用this，this指向调用它的Vue实例，即（new", "Vue）。", "mpvue里同理。", "我们都知道，生命周期函数中的this都是指向Vue实例的，因此我们就可以访问数据，对属性和方法进行运算。props：{", "goods:Array", "},", "mounted:", "function(options){", "let", "category", "=", "[", "{id:", "0,", "name:", "'全部'},", "{id:", "1,", "name:", "'JAVA'},", "{id:", "2,", "name:", "'C++'},", "{id:", "3,", "name:", "'PHP'},", "{id:", "4,", "name:", "'VUE'},", "{id:", "5,", "name:", "'CSS'},", "{id:", "6,", "name:", "'HTML'},", "{id:", "7,", "name:", "'JavaScript'}", "]", "this.categories", "=", "category", "this.getGoodsList(0)", "},", "methods:", "{", "getGoodsList(categoryId){", "console.log(categoryId);", "if(categoryId", "==", "0){", "categoryId", "=", "''", "}", "wx.request({", "url:", "'http://localhost:3030/shop/goods/list',", "data:", "{", "categoryId:", "categoryId", "},", "method:", "'POST',", "success:", "res", "=>", "{", "console.log(res);", "this.goods", "=", "res.data.data;", "}", "})", "},", "}", "复制代码普通函数this指向这个函数运行的上下文环境，也就是调用它的上下文，所以在这里，对于生命周期函数用普通函数还是箭头函数其实并没有影响，因为它的定义环境与运行环境是同一个，所以同样能取到vue实例中数据、属性和方法。", "箭头函数中，this指向的是定义它的最外层代码块，()=>{}", "等价于", "function(){}.bind(this);所以this当然指向的是vue实例。起初并没有考虑到this指向的问题，在wx.request({})中success用了普通函数，结果一直报错“goods", "is", "not", "defined”，用了箭头函数才解决，起初普通函数的this指向", "getGoodsList()的上下文环境，所以一直没办法取到值。5.onLoad与onShow在进行首页点击商品跳转到详情页时，onLoad()无法获取更新数据。首先虽然onLoad:", "function", "(options)", "这个是可以接受到值的，但是这个只是加载一次，不是我想要的效果，我需要在本页面(不关闭的情况下)到另外一个页面在跳转进来，接收到对应商品的数据。所以需要将代码放在onshow内部，", "在每次页面加载的时候都会进行当前状态的查询，查询对应数据的子对象，更新渲染到详情页上。onShow:", "function(options){", "//", "console.log(this.styleobject)", "//", "console.log(options)", "wx.getStorage({", "key:", "'shopCarInfo',", "success:", "(res)", "=>{", "//", "success", "console.log(`initshopCarInfo:${res.data}`)", "this.shopCarInfo", "=", "res.data;", "this.shopNum", "=", "res.data.shopNum", "}", "})", "wx.request({", "url:", "'http://localhost:3030/shop/goods/detail',//请求detail数据表的数据", "method:", "'POST',", "data:", "{", "id:", "options.id", "},", "success:", "res", "=>{", "//", "console.log(res);", "const", "dataInfo", "=", "res.data.data.basicInfo;", "this.saveShopCar", "=", "dataInfo;", "this.goodsDetail.name", "=", "dataInfo.name;", "this.goodsDetail.minPrice", "=", "dataInfo.minPrice;", "this.goodsDetail.goodsDescribe", "=", "dataInfo.characteristic;", "let", "goodsLabel", "=", "this.goodsLabel", "goodsLabel", "=", "res.data.data;", "//", "console.log(goodsLabel);", "this.selectSizePrice", "=", "dataInfo.minPrice;", "this.goodsLabel.pic", "=", "dataInfo.pic;", "this.goodsLabel.name", "=", "dataInfo.name;", "this.buyNumMax", "=", "dataInfo.stores;", "this.buyNumMin", "=", "(dataInfo.stores", ">", "0)", "?", "1", ":", "0;", "}", "})", "}", "复制代码了解小程序onLoad与onShow生命周期函数：onLoad：生命周期函数–监听小程序初始化，当小程序初始化完成时，会触发", "onLoadh（全局只触发一次）。onShow：生命周期函数–监听小程序显示，当小程序启动，或从后台进入前台显示，会触发", "onShow。二、后台数据库及数据存取1.架设", "HTTP", "服务在全局配置文件中：", "1).引入koa并实例化const", "Koa", "=", "require('koa')；", "const", "app", "=", "new", "Koa()", "复制代码2).app.listen(端口号)：创建并返回", "HTTP", "服务器，将给定的参数传递给Server#listen()。const", "Koa", "=", "require('koa');//引入koa框架", "const", "app", "=", "new", "Koa();", "app.listen(3000);", "这里的app.listen()方法只是以下方法的语法糖:", "const", "http", "=", "require('http');", "const", "Koa", "=", "require('koa');", "const", "app", "=", "new", "Koa();", "http.createServer(app.callback()).listen(3000);", "复制代码这样基本的配置完毕，我们就可以用“http://localhost3030+请求地址参数”获取到数据库的值了。2.Koa-router路由中间件koa-router", "是常用的", "koa", "的路由库。如果依靠ctx.request.url去手动处理路由，将会写很多处理代码，这时候就需要对应的路由的中间件对路由进行控制，这里介绍一个比较好用的路由中间件koa-router。以路由切换催动界面切换，”数据化”界面。3.建立对象模型在构建函数库之前，先来聊聊对象的建模。Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具。该npm包封装了操作mongodb的方法。Mongoose有两个特点：1、通过关系型数据库的思想来设计非关系型数2、基于mongodb驱动，简化操作const", "mongoose", "=", "require('mongoose')", "const", "db", "=", "mongoose.createConnection('mongodb://localhost/shop')", "//建立与shop数据库的连接(shop是我本地数据库名)", "复制代码本地数据库shop中建了分别“地址管理”、“商品详情”、“订单详情”、“商品列表”、“用户列表”五个数据表：Schema界面定义数据模型：Schema用于定义数据库的结构。类似创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection，但是Schema不具备操作数据库的能力。数据表跟对象的映射,同时具有检查效果,检查每组数据是否满足模型中定义的条件", "同时，每个对象映射成一个数据报表，就可用该对象进行保存操作，等同操作数据表，而非mysql命令行般繁琐的操作以“商品列表”数据表为例：//", "模型通过Schema界面定义。", "var", "Schema", "=", "mongoose.Schema;", "const", "listSchema", "=", "new", "Schema({", "barCode:", "String,", "categoryId:", "Number,", "characteristic:", "String,", "commission:", "Number,", "commissionType:", "Number,", "dateAdd:", "String,", "dateStart:", "String,", "id:", "Schema.Types.ObjectId,", "logisticsId:", "Number,", "minPrice:", "Number,", "minScore:", "Number,", "name:", "String,", "numberFav:", "Number,", "numberGoodReputation:", "Number,", "numberOrders:", "Number,", "originalPrice:", "Number,", "paixu:", "Number,", "pic:", "String,", "pingtuan:", "Boolean,", "pingtuanPrice:", "Number,", "propertyIds:", "String,", "recommendStatus:", "Number,", "recommendStatusStr:", "String,", "shopId:", "Number,", "status:", "Number,", "statusStr:", "String,", "stores:", "Number,", "userId:", "Number,", "videoId:", "String,", "views:", "Number,", "weight:", "Number,", "})", "复制代码定义了数据表中需要的数据项的类型，数据表传入数据后会一一对应：4.koa-router“路由库”const", "Router", "=", "require('koa-router')()//引入koa-router", "const", "router", "=", "new", "Router();//", "创建", "router", "实例对象", "//注册路由", "router.post('/shop/goods/list',", "async", "(ctx,", "next)", "=>", "{", "const", "params", "=", "ctx.request.body", "//以‘listSchema’的模型去取到Goods的数据", "const", "Goods", "=", "db.db.model('Goods',", "db.listSchema)", "//第一个‘db’是require来的自定义的，第二个‘db’是取到连接到mongodb的数据库，model代指实体数据(根据schema获取该字段下的数据，然后传给Goods))", "ctx.body", "=", "await", "new", "Promise((resolve,", "reject)", "=>", "{//ctx.body是ctx.response.body的缩写,代指响应数据", "//异步，等到获取到数据之后再将body发出去", "if", "(params.categoryId)", "{", "Goods.find({categoryId:", "params.categoryId},(err,", "docs)", "=>", "{", "if", "(err)", "{", "reject(err)", "}", "resolve({", "code:", "0,", "errMsg:", "'success',", "data:", "docs", "})", "})", "}", "else", "{", "Goods.find((err,", "docs)", "=>", "{", "if", "(err)", "{", "reject(err)", "}", "resolve({", "code:", "0,", "errMsg:", "'success',", "data:", "docs", "})", "})", "}", "})", "})", "复制代码所有的数据库操作都是异步的操作，所以需要封装promise来实现，由此通过POST", "“http://localhost3030/shop/goods/list”便可访问本地shop数据库了。", "这里顺便提一下“ctx”的使用，ctx(context)上下文，我们都知道有node.js", "中有request(请求)对象和respones(响应)对象。Koa把这两个对象封装在ctx对象中。", "参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response", "(前端通过ajax请求http获取数据)", "我们可以通过ctx请求or获取数据库中的数据。Ctx.body", "属性就是发送给用户的内容body是http协议中的响应体，header是指响应头ctx.body", "=", "ctx.res.body", "=", "ctx.response.body5.数据缓存之模型层设置1).为什么要做数据缓存？在这里不得不提一句数据缓存的重要性，虽然我是从本地数据库获取的数据，但是由于需要的数据量较多，再者前面说的性能优化还未完成，每次还是有一定的请求时间，没必要每次打开都去请求一遍后端，渲染页面较慢，所以需要将需要经常用到的数据做本地缓存，这样能大大提高页面渲染速度。2).设置模型层setGoodsList:", "function", "(saveHidden,", "total,", "allSelect,", "noSelect,", "list)", "{", "this.saveHidden", "=", "saveHidden,", "this.totalPrice", "=", "total,", "this.allSelect", "=", "allSelect,", "this.noSelect", "=", "noSelect,", "this.goodsList", "=", "list", "var", "shopCarInfo", "=", "{};", "var", "tempNumber", "=", "0;", "var", "list", "=", "[];", "shopCarInfo.shoplist", "=", "list;", "for", "(var", "i", "=", "0;", "i", "<", "list.length;", "i++)", "{", "tempNumber", "=", "tempNumber", "+", "list[i].number", "}", "shopCarInfo.shopNum", "=", "tempNumber;", "wx.setStorage({", "key:", "\"shopCarInfo\",", "data:", "shopCarInfo", "})", "},", "复制代码将需要做本地存储数据的方法封装成一个方法模型，当需要做本地存储时，直接做引用，如今vue、react中多用到的架构思想，都对模型层封装有一定的要求。bindAllSelect()", "{", "var", "list", "=", "this.goodsList;", "var", "currentAllSelect", "=", "this.allSelect", "if", "(currentAllSelect)", "{", "list.forEach((item)", "=>", "{", "item.active", "=", "false", "})", "}", "else", "{", "list.forEach((item)", "=>", "{", "item.active", "=", "true", "})", "}", "this.setGoodsList(this.getSaveHide(),", "this.totalPrice(),", "!currentAllSelect,", "this.noSelect(),", "list);", "},", "复制代码结语：写这个项目抓狂了很多次，因为很多vue能用的但在mpvue里实现不了，导致走了很多弯路，踩了很多坑，但是程序猿成长不就是在一个个坑里掉下去又爬起来的过程中吗？作文不易，伙伴们能打赏点就打赏点吧...", "顺便附上我的项目地址：", "“mpvue-demo”", "，不过还有很多需要完善的地方，漫漫长路一起走啊！作者：mosa原文：https://juejin.im/post/5b548ce8e51d45191d79f8a6?utm_source=tuicool&utm_medium=referral"]}
{"author": "Rolan", "title": "解决微信小游戏排行榜 Android 模糊问题 ", "content": ["最近用", "Cocos", "Creator", "(cc)", "开发微信小游戏。由于", "微信小游戏存在", "主域和子域的隔离；主域，你的主要游戏场景，和一些交互按钮等内容；子域，主要用于获取用户数据和排行榜的显示；微信这样分开也是为了更好地保护用户数据，防止数据泄露。因此一定要合理的设计自己的主域和子域；凡是设计从微信里获取数据的比如用户头像，游戏成绩等；一定需要在子域的canvas", "完成绘制；实际在完成排行榜的功能时候遇到了一点兼容性的问题，Android", "的部分机型(自己这边全部复现)和", "iOS", "设备上存在画布模糊的问题:ios", "的截图如下:搜索了一下，发现没有多少人提出这样的问题，但是看别的游戏也存在同样的问题；不过，灵机一动！！！如果前端接触", "canvas", "的话，才开始都会遇到一个问题，就是再", "PC", "上看着挺好的，但是在移移动端就模糊了，因为这里存在一个", "设备上物理像素和设备独立像素(device-independent", "pixels", "(dips))的比例", "因此你的", "canvas", "设置的像素要比实际多出一些比如会有:canvas.width", "=", "window.innerWidth", "*", "window.devicePixelRatio", "于是照着这个思路，输出了", "主域的", "canvas", "宽度", "和", "子域的", "canvas", "宽度，发现", "子域的", "sharedCanvas", "并不是你预期的宽度，因此这个时候你需要手动的将它设置成你在", "cocos", "creator", "设置的画布大小比如", "750", "*", "1662", "等；if", "(typeof", "sharedCanvas", "!==", "'undefined')", "{", "sharedCanvas.width", "=", "750", "sharedCanvas.height", "=", "1662", "}", "大概完成后就不会有模糊的感觉了~"]}
{"author": "Rolan", "title": "微信小程序：漫画小程序项目总结 ", "content": ["项目考察点：1、wx:for", "循环的使用。", "2、this.setData", "内获取动态数组数据的方式。", "3、难点：在有旁白内容时，点击旁白隐藏内容，点击图片不处理事件（通过自定义", "data-tag", "区分，用e.currentTarget.dataset", "选取子节点）。", "4、e.currentTarget.dataset、e.target.dataset", "用法，console.log(e)", "调试技巧。", "5、难点：数组数据下标为动态数据时的取值方法。项目要求：1、构建", "WXML", "模板。", "2、使用", "wx:for", "循环输出四个图片，每个图片包含一个", "view", "组件。每个", "view", "中又包含一个", "image", "组件展示图片和一个", "text", "组件展示漫画旁白。", "3、循环结构通过", "template", "形成独立模板文件。", "4、为", "view", "组件绑定事件（其它组件不做事件绑定），默认不展示旁白，当点击图片时可以查看旁白；而在有旁白内容时，点击旁白隐藏内容，点击图片不处理事件。", "5、旁白内容在", "WXML", "里展示，需要使用", "WXS", "处理，把所有半角逗号", ",", "改为全角逗号", "，，WXS", "以独立的文件存在。wx:for", "循环的使用index.js：Page({", "data:", "{", "images:", "[{", "src:", "'/images/dov-1.png',", "text:", "'',", "aside:", "false,", "unique:", "'0'", "},", "{", "src:", "'/images/dov-2.png',", "text:", "'过年浪一浪,爆竹好,棒棒',", "aside:", "false,", "unique:", "'1'", "},", "{", "src:", "'/images/dov-3.png',", "text:", "'突然一个想不开,原地爆炸好心塞',", "aside:", "false,", "unique:", "'2'", "},", "{", "src:", "'/images/dov-4.png',", "text:", "'吓死白熊宝宝,变成熊猫大佬',", "aside:", "false,", "unique:", "'3'", "}]", "},//......})index.wxml：", "<import", "src=\"template.wxml\"/>", "<view", "class=\"container\">", "<template", "is=\"imgItem\"", "data=\"{{images}}\"", "/>", "</view>由于循环结构通过", "template", "形成独立模板文件，因此", "wxml", "文件只需引入模板。{{images}}", "为", "js", "文件data中的", "images。imgItem", "对应模板文件中的", "name", "属性。模板template：<block", "wx:for=\"{{images}}\"", "wx:for-item=\"item\"", "wx:for-index=\"index\"", "wx:key=\"unique\"></block>wx:for-item", "指定当前项变量名，wx:for-index", "指定数组下标变量。如果不指定", "wx:for-item", "和", "wx:for-index，数组当前项的变量名默认为", "item，默认数组的当前项的下标变量名默认为", "index。（文档戳这：小程序列表渲染）因此项目中", "images[index]", "可以用", "item", "代替。template.wmxl：<wxs", "src=\"index.wxs\"", "module=\"tools\"", "/><template", "name=\"imgItem\">", "<view", "wx:for=\"{{images}}\"", "wx:key=\"unique\"", "bind:tap=\"toggleText\"", "data-value=\"{{item.aside}}\"", "data-unique=\"{{item.unique}}\">", "<image", "src=\"{{item.src}}\"", "data-tag=\"image\"", "/>", "<text", "class=\"{{item.aside?'textShow':'textHide'}}\"", "data-tag=\"text\">{{tools.commaReplace(item.text)}}</text>", "</view></template>项目要求通过", "wxs", "处理半角变全角逗号问题，引入", "wxs", "用法是，其中", "tools", "是", "wxs", "的名称，通过", "module", "定义。在{{tools.commaReplace(item.text)}}中，.commaReplace", "由", "wxs", "定义，()", "中传入", "js", "数据。半角变全角逗号wxs：在小程序中，", "由于运行环境的差异，在", "iOS", "设备上小程序内的", "wxs", "会比", "javascript", "代码快", "2", "~", "20", "倍。index.wxs：function", "commaReplace(some_msg){", "while", "(some_msg.indexOf(\",\")", "!=", "-1)", "{//寻找每一个英文逗号，并替换", "some_msg", "=", "some_msg.replace(\",\",", "\"，\");", "}", "return", "some_msg;}module.exports", "=", "{", "commaReplace:", "commaReplace", "};使用", "while", "循环遍历字符串中每个字符的是否与半角逗号", ",", "匹配，如匹配使用", "replace(\",\",", "\"，\")", "方法替换，module.exports", "输出模板数据供", "wxml", "调用。旁白的显示与隐藏index.js：", "toggleText:", "function", "(e){", "console.log(e);", "var", "tag", "=", "e.target.dataset.tag;", "var", "index", "=", "e.currentTarget.dataset.unique;", "var", "value", "=", "(!e.currentTarget.dataset.value);", "var", "aside", "=", "'images['", "+", "index", "+", "'].aside';//设置images数组动态变量aside", "console.log(value);", "if", "(tag", "===", "'image'){", "if", "(!this.data.images[index].aside){", "value", "=", "true;", "this.setData({", "[aside]:", "value", "})", "}", "}", "else", "if", "(tag", "===", "'text'){", "value", "=", "false;", "this.setData({", "[aside]:", "value", "})", "}", "}在小程序里，想要更新页面的数据，必须使用", "this.setData", "对数据进行更新。在知道数组下标或属性字段名称的情况下，可以这样写：", "this.setData({", "'images[0].aside':", "this.data.images[@].aside})数组数据下标为动态数据时的取值方法：项目中我采用的方式是给", "aside", "赋值，然后在", "this.setData", "中输出", "[aside]", "的方式。", "var", "aside", "=", "'images['", "+", "index", "+", "'].aside';//设置images数组动态变量aside还有另一种更高级的写法，使用", "JSON.", "stringify", "把要设置的数据进行序列化，或者使用字符串拼接的方法拼出", "json", "，然后再重新JSON.parse", "传给", "setData：", "let", "json", "='{\"images['", "+", "index", "+'].aside\":'+", "this", ".data", ".images[index]", ".aside.toString()", "+'}';this.setData(JSON.parse(json));console.log(e)", "调试技巧：立正小歪牙e.target", "触发事件的组件的一些属性值集合，e.currentTarget", "则是当前组件的一些属性值集合。在不知道什么情况使用", "e.currentTarget.dataset", "还是", "e.target.dataset", "时，可以通过控制台打印", "console.log(e)", "，然后分别查看", ".target", "和", ".currentTarget", "来找到想要的属性值。触发", "toggleText", "时的", "console.log(e)", "打印信息."]}
{"author": "Rolan", "title": "小程序的拖拽、缩放和旋转手势 ", "content": ["在开发中，有时会遇到像App中的手势那样的效果，下面就仿照App实现了一下。", "wxml部分：<view", "class=\"touch-container\">", "<view", "class=\"msg\">{{msg}}</view>", "<image", "class=\"img\"", "src=\"{{src}}\"", "style=\"width:", "{{width}}rpx;", "height:", "{{height}}rpx;", "left:", "{{left}}rpx;", "top:", "{{top}}rpx;", "transform:", "translate(-50%,", "-50%)", "scale({{", "scale", "}})", "rotate({{", "rotate", "}}deg);\"", "bindload=\"bindload\"", "catchtouchstart=\"touchstart\"", "catchtouchmove=\"touchmove\"", "catchtouchend=\"touchend\"", "></image></view>wxss部分：page", "{", "width:", "100%;", "height:", "100%;", "background:", "#ffffff;}.touch-container", "{", "width:", "100%;", "height:", "100%;", "padding-top:", "0.1px;}.msg", "{", "width:", "100%;", "height:", "60rpx;", "line-height:", "60rpx;", "text-align:", "center;", "font-size:", "30rpx;", "color:", "#666666;}.img", "{", "position:", "absolute;", "width:", "690rpx;", "height:", "300rpx;", "transform-origin:", "center", "center;}js部分：var", "canOnePointMove", "=", "falsevar", "onePoint", "=", "{", "x:", "0,", "y:", "0}var", "twoPoint", "=", "{", "x1:", "0,", "y1:", "0,", "x2:", "0,", "y2:", "0}Page({", "data:", "{", "msg:", "'',", "src:", "'http://img01.taopic.com/150508/318763-15050PU9398.jpg',", "width:", "0,", "height:", "0,", "left:", "375,", "top:", "600,", "scale:", "1,", "rotate:", "0", "},", "//", "关闭上拉加载", "onReachBottom:", "function()", "{", "return", "},", "bindload:", "function(e)", "{", "var", "that", "=", "this", "var", "width", "=", "e.detail.width", "var", "height", "=", "e.detail.height", "if", "(width", ">", "750)", "{", "height", "=", "750", "*", "height", "/", "width", "width", "=", "750", "}", "if", "(height", ">", "1200)", "{", "width", "=", "1200", "*", "width", "/", "height", "height", "=", "1200", "}", "that.setData({", "width:", "width,", "height:", "height", "})", "},", "touchstart:", "function(e)", "{", "var", "that", "=", "this", "if", "(e.touches.length", "<", "2)", "{", "canOnePointMove", "=", "true", "onePoint.x", "=", "e.touches[0].pageX", "*", "2", "onePoint.y", "=", "e.touches[0].pageY", "*", "2", "}else", "{", "twoPoint.x1", "=", "e.touches[0].pageX", "*", "2", "twoPoint.y1", "=", "e.touches[0].pageY", "*", "2", "twoPoint.x2", "=", "e.touches[1].pageX", "*", "2", "twoPoint.y2", "=", "e.touches[1].pageY", "*", "2", "}", "},", "touchmove:", "function(e){", "var", "that", "=", "this", "if", "(e.touches.length", "<", "2", "&&", "canOnePointMove)", "{", "var", "onePointDiffX", "=", "e.touches[0].pageX", "*", "2", "-", "onePoint.x", "var", "onePointDiffY", "=", "e.touches[0].pageY", "*", "2", "-", "onePoint.y", "that.setData({", "msg:", "'单点移动',", "left:", "that.data.left", "+", "onePointDiffX,", "top:", "that.data.top", "+", "onePointDiffY", "})", "onePoint.x", "=", "e.touches[0].pageX", "*", "2", "onePoint.y", "=", "e.touches[0].pageY", "*", "2", "}else", "if", "(e.touches.length", ">", "1)", "{", "var", "preTwoPoint", "=", "JSON.parse(JSON.stringify(twoPoint))", "twoPoint.x1", "=", "e.touches[0].pageX", "*", "2", "twoPoint.y1", "=", "e.touches[0].pageY", "*", "2", "twoPoint.x2", "=", "e.touches[1].pageX", "*", "2", "twoPoint.y2", "=", "e.touches[1].pageY", "*", "2", "//", "计算角度，旋转(优先)", "var", "perAngle", "=", "Math.atan((preTwoPoint.y1", "-", "preTwoPoint.y2)/(preTwoPoint.x1", "-", "preTwoPoint.x2))*180/Math.PI", "var", "curAngle", "=", "Math.atan((twoPoint.y1", "-", "twoPoint.y2)/(twoPoint.x1", "-", "twoPoint.x2))*180/Math.PI", "if", "(Math.abs(perAngle", "-", "curAngle)", ">", "1)", "{", "that.setData({", "msg:", "'旋转',", "rotate:", "that.data.rotate", "+", "(curAngle", "-", "perAngle)", "})", "}else", "{", "//", "计算距离，缩放", "var", "preDistance", "=", "Math.sqrt(Math.pow((preTwoPoint.x1", "-", "preTwoPoint.x2),", "2)", "+", "Math.pow((preTwoPoint.y1", "-", "preTwoPoint.y2),", "2))", "var", "curDistance", "=", "Math.sqrt(Math.pow((twoPoint.x1", "-", "twoPoint.x2),", "2)", "+", "Math.pow((twoPoint.y1", "-", "twoPoint.y2),", "2))", "that.setData({", "msg:", "'缩放',", "scale:", "that.data.scale", "+", "(curDistance", "-", "preDistance)", "*", "0.005", "})", "}", "}", "},", "touchend:", "function(e)", "{", "var", "that", "=", "this", "canOnePointMove", "=", "false", "}})json部分：\"navigationBarTitleText\":", "\"识别手势\",", "\"navigationBarTextStyle\":\"black\",", "\"navigationBarBackgroundColor\":", "\"#FFF\",", "\"disableScroll\":", "true"]}
{"author": "Rolan", "title": "解决微信小程序真机 showToast 不显示 ", "content": ["花了一周多，终于把公司小程序做出来了。真机上测试发现调用", "showToast", "不显示，或者闪一下就没了。经过查找，发现是与", "wx.showLoading", "冲突了，两者调用的是同个框。先放上我的错误代码：", "//", "请求事件", "requestEvent:", "function()", "{", "wx.showLoading({", "title:", "'正在加载中',", "})", "wx.request({", "url:", "'',", "success:", "function(res)", "{", "wx.showToast({", "title:", "'成功',", "duration:", "2000", "})", "},", "fail:", "function()", "{", "wx.showToast({", "title:", "'失败',", "duration:", "2000", "})", "},", "complete:", "function()", "{", "wx.hideLoading()", "}", "})", "}我是想请求接口后，将加载框隐藏掉，再显示", "toast", "提示。但是真机上发现", "showToast", "不显示。正如上面所说，两者调用的是同个框。现在，我们分析整个流程：1、首先显示", "loading", "框；", "2、然后调用", "success", "/", "fail，弹框的内容由", "loading", "变成了", "toast；", "3、最后调用", "onComplete", "时，hideLoading", "将弹框隐藏掉了；很明显，我们最终把", "toast", "框隐藏掉了。知道原因后，改起来就容易了。先调用", "wx.hideLoading()，再调用", "wx.showToast()", "即可。建议：若是在网络请求前需要调用", "wx.showLoading，建议在该", "success", "和", "fail", "回调函数内第一行就调用", "wx.hideLoading。即使暂时不需要", "showToast", "操作。因为以后需要在回调函数内添加", "toast", "时，", "就不用再管什么顺序问题了；", "当", "toast", "和", "loading", "同时使用，多注意两者的调用顺序；如下是正确代码：", "//", "请求事件", "requestEvent:", "function()", "{", "wx.showLoading({", "title:", "'正在加载中',", "})", "wx.request({", "url:", "'',", "success:", "function(res)", "{", "wx.hideLoading()", "wx.showToast({", "title:", "'成功',", "duration:", "2000", "})", "},", "fail:", "function()", "{", "wx.hideLoading()", "wx.showToast({", "title:", "'失败',", "duration:", "2000", "})", "}", "})", "}"]}
{"author": "Rolan", "title": "Asp.Net Core SignalR 与微信小程序交互笔记 ", "content": ["什么是Asp.Net", "Core", "SignalRAsp.Net", "Core", "SignalR", "是微软开发的一套基于Asp.Net", "Core的与Web进行实时交互的类库，它使我们的应用能够实时的把数据推送给Web客户端。功能自动管理连接允许同时广播到所有客户端也可以广播到指定的组或者特定的客户端在Github上开源，传送门SignalR", "提供了多种连接方式，在现代化应用中，WebSocket是最佳的传输协议，在客户端无法实现WebSocket协议的时候，SignalR就会采取其他方式，比如Server-Sent或者长轮询（在ws未出现之前，我们讨论的推拉模式）中心", "HubsSignalR是采用中心客户端和服务器进行通讯。中心是一种高级的管道，允许客户端和服务器之间相互调用方法。中心通过强类型参数传递给方法，进行模型绑定Hubs.ClientsClients属性包含了所有的客户端连接信息，它包含了3个属性：All", "所有客户端Caller", "进行此次请求的客户端Others", "排除此次请求客户端的其他客户端包含了多个方法：=", "AllExcept", "在指定的连接除外的所有连接的客户端上调用方法Client", "在特定连接的客户端上调用方法Clients", "在特定连接的客户端上调用方法Group", "调用指定的组中的一种对所有连接方法GroupExcept", "调用中指定的组，除非指定连接到的所有连接的方法Groups", "调用一种对多个组的连接方法OthersInGroup", "调用一种对一组的连接，不包括客户端调用", "hub", "方法方法User", "调用一种对与特定用户关联的所有连接方法Users", "调用一种对与指定的用户相关联的所有连接方法每个属性和方法返回的对象都包含一个SendAsync方法，可以对客户端进行调用。HubContext可以在应用其他地方通过使用IHubContext，达到调用Hub的目的。两种协议文本协议：JSON二进制协议：MessagePackMessagePack类似于JSON，但传输比JSON更快，数据大小比JSON更小服务器事项创建的Hub必须继承Microsoft.AspNetCore.SignalR.Hub,Hub类已经包含了管理连接、组和发送接收消息的属性及事件在Hub中使用的方法应该尽量使用异步的方式，因为SignalR在发送和接收消息的时候使用的是异步方法。在Startup.ConfigureServices中通过services.AddSignalR对SignalR进行注册在Startup.Configure中通过app.UseSignalR方法对Hub路由进行配置代码解析微软官方示范中的ChatHub：using", "Microsoft.AspNetCore.SignalR;", "using", "System.Threading.Tasks;", "namespace", "SignalRChat.Hubs", "{", "public", "class", "ChatHub", ":", "Hub", "{", "//服务端方法", "public", "async", "Task", "SendMessage(string", "user,", "string", "message)", "{", "//ReceiveMessage", "为客户端方法，让所有客户端调用这个方法", "await", "Clients.All.SendAsync(\"ReceiveMessage\",", "user,", "message);", "}", "}", "}上述代码为当收到客户端发来的SendMessage请求后（发送聊天信息），我们把消息发送到所有客户端，让他们调用自身的ReceiveMessage方法。用户标识通常情况下，在用户进行连接后，Connection会保存用户的用户标识，以便对特定用户进行发送消息。可以实现IUserIdProvider来自定义获取用户的方法，例如：public", "class", "CustomUserIdProvider", ":", "IUserIdProvider", "{", "public", "virtual", "string", "GetUserId(HubConnectionContext", "connection)", "{", "return", "connection.User?.FindFirst(ClaimTypes.Email)?.Value;", "}", "}在Startup.ConfigureServices中注册：", "services.AddSingleton<IUserIdProvider,", "CustomUserIdProvider>();Group", "分组分组类似于聊天室中的每个房间，通过分组，我们可以给特定小组发送消息。用户标识和组名称都是区分大小写的。微信小程序与SignalR交互小程序因为无法直接使用websocket，所以无法使用signalR.js，你可以试着把signalR.js中的webcosket使用部分换成wx.xxSocketxxx。在参考了算神的代码后，归了一个小类库，方便大家使用，源码较长，我放到了github上，点击【传送门】进入。如何使用调用类库在要使用的页面上：///引入这个类库", "var", "signalR", "=", "require('../../lib/signalr/signalr.js')", "///实例化一个对象", "let", "_client", "=", "new", "signalR.signalR();创建", "一个映射方法这是为了让小程序收到SignalR的消息之后进行回调callMethods(methods,", "args)", "{", "console.log(methods,", "args);", "let", "self", "=", "this;", "switch", "(methods)", "{", "case", "'sayHello':", "self.sayHello(args[0]);", "break;", "}", "},例子里有一个sayHello方法，我们用字符串作为key。进行连接_client.connection(url,", "methodMapping);url", ":", "signalR服务器methodMapping", ":", "方法和字符串之间的Mapping调用SignalR方法", "_client.call(methodName,", "args,", "success,", "fail)methodName:远程方法名args：参数，这里注意一定要数组格式success：调用成功后的回调fail：失败后的回调写在最后最近真的忙，忙成一道闪电，正好遇到这个问题随之记录下。类库可能并不完善，你可以在github上提issue，我会跟进的，有好的修改方式，你也可以PR我。"]}
{"author": "Rolan", "title": "小程序如何获取群聊的openGid以及名称 ", "content": ["背景：由于公司可能需要在微信群里面使用打卡功能，因此做了个技术调研。方案：微信在更新分享接口后，原有的在onShareAppMessage中直接拿shareTicket已不复存在。根据最新文档显示，需要在App.onLaunch()跟App.onShow()中获取。Demo核心代码：index.jsPage({", "/**", "*", "页面的初始数据", "*/", "data:", "{", "openGid:", "''", "},", "/**", "*", "生命周期函数--监听页面加载", "*/", "onLoad:", "function", "(options)", "{", "let", "that", "=", "this", "wx.showShareMenu({", "withShareTicket:", "true", "})", "app.getShareTiket(function", "(globalData)", "{", "console.log('clickReload---globalData-->'", "+", "JSON.stringify(globalData))", "that.setData({", "openGid:", "globalData.openGid", "})", "})", "},", "clickReload:", "function", "()", "{", "let", "that", "=", "this", "app.getShareTiket(function", "(globalData)", "{", "console.log('clickReload---globalData-->'", "+", "JSON.stringify(globalData))", "that.setData({", "openGid:", "globalData.openGid", "})", "})", "}})index.wxml<!--index.wxml--><view", "wx:if=\"{{openGid}}\"", "class='groupName'>", "群名称：<open-data", "type=\"groupName\"", "open-gid=\"{{openGid}}\"></open-data></view><view", "wx:else>", "<button", "bindtap='clickReload'>点击加载群名称</button></view><view>{{openGid", "?", "openGid", ":", "'无'}}</view>app.js//app.jsApp({", "globalData:", "{", "shareTicket:", "'',", "openGid:", "''", "},", "onLaunch:", "function", "(options)", "{", "},", "onShow:", "function", "(options)", "{", "let", "that", "=", "this", "if", "(options", "&&", "options.scene", "==", "1044)", "{", "that.globalData.shareTicket", "=", "options.shareTicket", "}", "console.log('onShow---options=--->'", "+", "JSON.stringify(options))", "},", "getShareTiket:", "function", "(cb)", "{", "let", "that", "=", "this", "//", "展示本地存储能力", "if", "(that.globalData.shareTicket)", "{", "wx.getShareInfo({", "shareTicket:", "that.globalData.shareTicket,", "success:", "function", "(res)", "{", "console.log('getShareTiket---shareTicket-->'", "+", "JSON.stringify(res))", "let", "js_encryptedData", "=", "res.encryptedData", "let", "js_iv", "=", "res.iv", "wx.login({", "success:", "function", "(res)", "{", "let", "js_code", "=", "res.code", "console.log('code-->'", "+", "js_code)", "wx.request({", "url:", "'xxxxxxxx',", "method:", "'POST',", "data:", "{", "code:", "js_code,", "appId:", "'xxxxx',", "encryptedData:", "js_encryptedData,", "iv:", "js_iv", "},", "success:", "function", "(res)", "{", "that.globalData.openGid", "=", "res.data.openGId", "console.log('getShareTiket---openGid'", "+", "that.globalData.openGid)", "typeof", "cb", "==", "\"function\"", "&&", "cb(that.globalData)", "},", "fail:", "function", "(err)", "{", "console.log('getShareTiket---err'", "+", "JSON.stringify(err))", "}", "})", "}", "})", "}", "})", "}", "else", "{", "console.log('不存在shareTicket')", "}", "}})注意事项1：必须调用这个接口wx.showShareMenu({withShareTicket:", "true})，否则在App.onLaunch()跟App.onShow()时，你拿不到shareTicket.2:微信开发者工具可以模拟1044的场景，但是不会显示群名称，因为你不在群里。所以测试的时候，自己拉个微信群，然后分享到测试群，就能拿到群名称。"]}
{"author": "Rolan", "title": "微信小程序iOS端如何暂停animated动画 ", "content": ["在知道有", "animation-play-state", "这个animation的参数时，我内心是激动的。在得知iOS端并不支持时，一股凉意袭来animation-play-state先来介绍一下今天的主角", "animation-play-stateanimation-play-stateCSS属性定义一个动画是否运行或者暂停。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。恢复一个已暂停的动画，将从它开始暂停的时候，而不是从动画序列的起点开始在动画。在MDN文档中了解到，这是一个实验中的功能，但是其作用还是强大的。既可以控制/获取元素的动画状态（paused，running）所以，这个animation的参数用来控制动画的播放状态再合适不过了。画外音：你还没考虑兼容性呢！对！就是这个兼容性问题。在chrome上这个参数是可以支持的，但是iOS设备上就不支持了...叹息。在iOS上的处理当然不能因为兼容性问题就不用这个参数了，当然不能让每个iOS用户去下载一个chrome浏览器，当然...那我们怎么解决呢？？？用JS通过", "Window.getComputedStyle()", "方法，我们可以获取元素实时的", "style", "的", "CSSStyleDeclaration", "对象，这个对象表示CSS属性键值对的集合。也就是说我们使用这个方法可以获取一个正在进行动画的元素当前的", "style", "值。PS:关于", "Window.getComputedStyle()", "方法的值可以在MDN上了解到，这里不展开叙述。给出一个语法的例子（摘自MDN）let", "style", "=", "window.getComputedStyle(element,", "[pseudoElt]);", "复制代码那么具体要怎么做呢？实现See", "the", "Penanimation-play-state", "by", "luogao", "(@luogao)", "onCodePen.代码已经在上面的codepen预览中展示啦，如果现实不来请点这里:point_right:Roy", "Luo's", "codepen大致解释一下就是：在元素的外层的包裹元素上添加获取到的执行动画的元素的", "style", "计算属性，从而让执行动画的元素暂停下来。那么在微信小程序中又是如何呢？其实，最先遇到这个问题是在做小程序的时候。一个播放器的界面，中间一张专辑图片。在圆形的黑胶唱片边框中旋转。当播放停止，图片也同时停止旋转。", "停在当前旋转的位置当时看似简单的一个需求，使用了", "animation-play-state", "并且与预期一样达到了效果，", "在模拟器中", "。没错，洋洋得意的以为完成了需求，结果真机（iOS）上一测试，原形毕露。当时看到小程序的官方社区中提到说iOS不支持这个", "animation-play-state", "‍♂️", "‍♂️", "‍♂️", "‍幸得残阳映枫红在sf的一个问题中的回答让我找到了方向。感谢之～"]}
{"author": "Rolan", "title": "小程序的持续集成方案 ", "content": ["半年前，有机会开始接触微信小程序开发。却因为只是接触而并没投入开发小程序的过程中，因此对很多小程序的细节并未有充分的理解，仅仅停留在了解类似的理论层面，比如mpvue修改了", "Vue.js", "的", "runtime", "和", "compiler", "实现了编译及运行在原生小程序能力，比如原生小程序不支持npm包的使用及管理等，当然那时候的技术细节难点都是由非常给力的好同事解决消化了，所以也没多去细究。最近，我开始投入到完成的小程序开发迭代里，却发现一个头痛的问题，如何准确并快速的的把小程序上传去后台，并让测试人员进行测试。问题当遇到多个开发人员并行开发不同功能模块的同一小程序，往往就会遇到测试人员需要进行测试的时候，让开发人员切换至测试分支后，进行构建编译和上传，最终把上传后生产的二维码提供出来进行测试使用。若当前开发人员在认真coding，为某个功能正在奋斗。突然被别人打断并告诉你需要为他提供一个测试环境的二维码….因为为了这个二维码，需要做的事情是：git", "stashgit", "checkout", "branchnpm", "installnpm", "run", "build点击“预览”，生成二维码，或点击上传，更新体验版提供二维码出去后，恢复刚刚的工作状态git", "checkout", "branchgit", "stash", "popnpm", "installnpm", "run", "dev不断回想刚刚的开发思路理想流程上面所说的，只是一个常见的场景，但是思考一下，这个场景的重复率是否很高，重复这类操作的价值究竟有多少？为了解决不让开发人员为了一个测试环境的二维码而痛苦，我尝试把gitlab", "ci", "和", "微信开发者工具的能力进行对接尝试。在理想的流程里，开发人员只需要针对对应的分支进行合并或提交即可，无需关心如何把项目编译及版本分发交付到测试或体验人员手上。接下来，对项目分支的管理不展开过多的说明，只设定develop分支是自动触发小程序持续集成（", "安装依赖、构建、上传至体验版本", "）的目标。微信开发者工具微信开发者工具有提供5个接口能力，并且提供cli", "和", "http方式调用：命令行启动工具命令行登录命令行提交预览命令行上传代码支持自动化测试由于这次目标只需要把对应develop分支的代码上传微信更新为体验版本，所以微信开发者工具的接口能力最主要的是第4个（命令行上传代码）。如果是功能分支也需要创建预览二维码，可以通过第3个接口能力实现cli和http的调用有什么区别cli方式通过命令行调用安装完成的工具可执行文件，完成登录、预览、上传、自动化测试等操作。调用返回码为", "0", "时代表正常，为", "-1", "时错误。", "命令行工具所在位置：", "macOS:", "<安装路径>/Contents/Resources/app.nw/bin/cli", "Windows:", "<安装路径>/cli.bathttp", "方式http", "服务在工具启动后自动开启，HTTP", "服务端口号在用户目录下记录，可通过检查用户目录、检查用户目录下是否有端口文件及尝试连接来判断工具是否安装/启动。", "端口号文件位置：", "macOS", ":", "~/Library/Application", "Support/微信web开发者工具/Default/.ide", "Windows", ":", "~/AppData/Local/微信web开发者工具/User", "Data/Default/.ide说白了，cli可以直接通过调用命令行工具，而http需要先寻找端口再进行接口调用，更适合跨机器调用。", "根据我当前情况，选择了cli方式。设置构建机器公司的Mac", "mini", "类似的机器暂时没有资源，不得不回到Windows上进行构建机的设置。但是坑还是挺多，可能一方面也是对windows的不熟悉吧。最后还是选择在Windows上装vmware，在vmware上运行Mac", "os。在Mac上面，安装微信开发者工具，如何下载安装就没必要多说了。接下来还需要安装gitlab", "runner，gitlab", "runner是用来运行你定制的任务（jobs）并把结果返回给", "GitLab。", "GitLab", "Runner", "配合GitLab", "CI（GitLab", "内置的持续集成服务）", "协调完成任务。详情可以查看后面的引用文章。在Mac上安装gitlab", "runner最简单的是用brew，当然另外下载应用包也是可以的brew", "install", "gitlab-runner", "#", "安装gitlab", "runner", "brew", "services", "start", "gitlab-runner", "#", "开机自动运行", "gitlab-runner", "start", "#", "只需要直接运行（不需要开机自动运行）", "复制代码安装完成后，可以进行runner的配置，主要需要提供gitlab", "url，项目仓库的token，runner", "tags等，详细信息请参考", "Registering", "Runners", "|", "GitLab", "中文文档gitlab-runner", "register", "复制代码编写CI文件CI文件编写，最主要是项目根目录上创建一个名为.gitlab-ci.yml，每一行的stages:", "-", "build", "#", "总体CI的过程，暂时只有一个job：build", "before_script:", "-", "shopt", "-s", "expand_aliases", "#", "开启扩展aliases功能", "issue", "https://gitlab.com/gitlab-org/gitlab-runner/issues/1083", "-", "alias", "wxcli=\"/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli\"", "#", "指定微信开发者工具cli命名为wxcli", "-", "type", "wxcli", "#", "验证wxcli命令是否存在", "-", "wxcli", "#", "启动微信开发者工具（其实好像有点多余，因为如果当前没启动微信开发者工具，在wxcli", "-u的时候也会启动）", "-", "source", "~/.bash_aliases", "#", "读取特点的alias，比如配置的nvm，issue", "https://gitlab.com/gitlab-org/gitlab-runner/issues/1958", "-", "npm", "install", "#", "安装依赖", "#", "测试环境", "test-build:", "stage:", "build", "#", "对应stages上的job名称", "script:", "-", "npm", "run", "build", "-", "curr_commit_content=`git", "log", "-1", "--pretty=format:%s`", "#", "获取最近提交的git内容", "-", "curr_version=`node", "-p", "\"require('./package.json').version\"`", "#", "获取package的版本号", "-", "curr_proj_path=`pwd`", "#", "当前项目路径", "-", "wxcli", "-u", "$curr_version@$curr_proj_path", "--upload-desc", "$curr_commit_content", "#", "提交微信开发者", "-", "#", "上传成功后，你可以尝试发送一些通知提醒大家可以去打开新版本了，比如钉钉的webhook", "only:", "-", "develop", "tags:", "-", "xxx_mp", "复制代码查看构建结果查看构建结果也是很简单，直接在gitlab仓库里的CI/CD", "——", "pipeline", "进行查看测试人员和体验人员可以从小程序开发助手上查看最新体验版（记得要在微信小程序后台把该CI用户上传的版本设定成体验版）真的不要再去做重复的工作，太影响心情了。"]}
{"author": "Rolan", "title": "小程序—九宫格心形拼图效果 ", "content": ["前几天在朋友圈看到好几次这种图片。这种图片，是用九张图片拼成的一个心形。感觉很有趣，就上网查了查怎么做，大部分的说法就是用美图秀秀的拼图功能来做，", "在微信小程序中也有专门做心形拼图的小程序，我都试了试之后，感觉还可以更加简单一些，于是我就自己做了个小程序。实现小程序的思路1、有两个", "canvas，一个小的", "canvas", "显示最后会是什么样子，一个大的", "canvas", "用来最后进行截图，生成图片，保存到相册。通过CSS的定位，把大的", "canvas", "移到屏幕外面不让用户看到就可以了。而如果用小的canvas", "保存图片的话，最后的图片有些模糊。2、canvas", "可以看成一个", "9", "*", "9", "的网格，用一个叫", "heart", "的数组来表示就是这样的。用其中的小格子，来拼出心形，根据数组的内容在", "canvas", "上进行渲染。小程序的功能这个小程序有", "选择单张图片，选择多张图片，补充图片，保存图片，重置，推荐，意见反馈，这几个功能。选择单张图片当用户点击心形区域的时候，就可以选择单张图片，调用wx.chooseImage", "就可以从本地相册选择图片，然后就把这张图，画在", "canvas上，具体画的位置就是用户点击的位置。在小的", "canvas上绑定touchend", "事件，触发事件后，事件中有一个changedTouches", "属性，这是一个保存了，当前变化的触摸点信息的数组，这个数组中的元素有", "x", "和", "y", "属性，也就是触摸点距离", "canvas", "左上角的距离。//", "触摸点在", "x", "轴的值", "var", "x", "=", "e.changedTouches[0].x;", "//", "触摸点在", "y", "轴的值", "var", "y", "=", "e.changedTouches[0].y;", "复制代码有", "x", "轴", "和", "y", "轴的距离后，算出具体应该画在哪个格子上。//grid", "表示一个格子的宽度", "//", "确定", "x", "轴是在第几个格子", "x", "=", "Math.floor(x", "/", "grid);", "//", "确定", "y", "轴是在第几个格子", "y", "=", "Math.floor(y", "/", "grid);", "复制代码知道在哪个格子画之后，就要确定画图片的哪部分了，因为所有的格子都是正方形的，但是用户选择的图片不一定是正方形，如果压缩成正方形会很难看，所以我画的时候，选择了正中间的部分来画，通过wx.getImageInfo", "来获取图片信息，以短边为正方形的宽，然后从", "（长边", "-", "短边）/2", "的地方来画。//", "获取图片的宽和高", "var", "width", "=", "res.width;", "var", "height", "=", "res.height;", "//", "如果图片不是正方形，只画中间的部分", "//", "sWidth", "表示正方形的宽", "var", "sWidth", "=", "width", ">", "height", "?", "height", ":", "width;", "//", "sx", "是源图像的矩形选择框的左上角", "X", "坐标", "var", "sx", "=", "0;", "//", "sy", "是源图像的矩形选择框的左上角", "y", "坐标", "var", "sy", "=", "0;", "if", "(width", ">", "height)", "{", "sx", "=", "(width", "-", "height)", "/", "2;", "}", "if", "(width", "<", "height)", "{", "sy", "=", "(height", "-", "width)", "/", "2;", "}", "复制代码知道画什么，在哪里画之后，调用", "canvasContext.drawImage", "来画就可以了。选择多张图片选择多张图片，同样是调用wx.chooseImage", "方法，成功选择多张图片后，返回的对象中有一个tempFilePaths", "属性，这个属性保存了，图片的本地文件路径列表。然后遍历", "heart", "数组，也就是保存心形数据的数组，如果数组中某个元素的值是1，也就是说在心形范围内，就按顺序从", "tempFilePaths", "中取一张图片画上去，画的时候同样的，如果不是正方形就只画中间的部分。补充图片在", "image", "的文件中，有保存几张图片，用来补充心形，他们的路径保存在一个数组中。//", "用来补充心形的图片", "images:", "[", "'../../images/1.jpg',", "'../../images/2.jpg',", "'../../images/3.jpg',", "'../../images/4.jpg',", "'../../images/5.jpg',", "'../../images/6.jpg',", "'../../images/7.jpg',", "'../../images/8.jpg',", "'../../images/9.jpg',", "'../../images/10.jpg',", "]", "复制代码然后就是遍历", "heart", "数组，如果数组的某个元素的值是1，就随机从这组图片中选择一张画上去。画一张图片，画多张图片，补充图片，他们都是在", "canvas", "上画图片，为了避免已经画了图片的位置被覆盖，他们所画的图片的等级是不同的。补充图片：1", "画多张图片：2", "画一张图片：3", "复制代码等级高的可以覆盖等级低的，等级低的不能覆盖等级高的，同等级的，除了画多张图片的不能覆盖，其余的两种情况，都可以覆盖。简单意思就是：", "补充图片，补充完了之后，再补充会把原来补充的覆盖掉，但是用户选择的图片不会被覆盖掉。画多张图片，可以覆盖掉补充的图片，但用户选择的图片也不会覆盖掉。画一张图片，不管这个位置有没有图片，都会再画一张。保存图片保存图片的时候，就是按顺序对大的", "canvas", "进行截取，然后保存成图片，主要靠", "wx.canvasToTempFilePath", "这个API来实现，这个", "API", "，可以把当前画布指定区域的内容导出生成指定大小的图片，并返回文件路径。这里要注意几个细节1、为了避免最后保存的图片有黑色背景，最好开始的时候就在", "canvas", "上画一个", "和", "canvas", "大小一样的矩形，矩形填充上颜色。2、为了保存的图片，在用户的相册中也能保持心形。需要按下面这个顺序来保存图片3、", "wx.canvasToTempFilePath", "中有两个选填的参数", "destWidth", "和", "destHeight，这个两个参数决定", "输出图片宽度和高度，如果不是准确的知道是多少，用默认值就可以。destWidth", "和", "destHeight", "单位是物理像素（pixel），canvas", "绘制的时候用的是逻辑像素（物理像素=逻辑像素", "*", "density），所以这里如果只是使用", "canvas", "中的", "width", "和", "height（逻辑像素）作为输出图片的长宽的话，生成的图片", "width", "和", "height", "实际上是缩放了到", "canvas", "的", "1", "/", "density", "大小了，所以就显得比较模糊了。而默认值是", "width", "*", "屏幕像素密度文档中提到的屏幕像素密度，应该不是指每英寸屏幕所拥有的像素数，而是指设备像素比（pixelRatio），也就是用多少个物理像素去显示", "1px", "的", "CSS", "像素。", "用APIwx.getSystemInfo", "可以查看设备像素比wx.getSystemInfo({", "success:", "function(res)", "{", "console.log(res.pixelRatio)", "}", "})", "复制代码这里如果我的理解有误，还请知道的小伙伴指出。说了这么多，主要就是想说用默认的值其实就已经很清晰了。4、因为要保存9张图片，所以需要一些时间，这个时候就需要一个进度条了，保存图片的时候，显示进度条，禁用保存按钮，毕竟点击一下按钮就是9张图片，所以这个时候还是禁用了好，每保存一张图片进度条的值就", "+12", "，超过100的时候，就表示", "9张图片都保存好了。而微信小程序中也刚好有", "进度条（progress）这个组件", "。重置这个功能就是遍历", "heart", "数组，用一种颜色，根据数组内容，把心形画出来。然后再在", "x", "轴", "和", "y", "轴上画两条线，行成九宫格的样子。推荐", "和", "意见反馈<button", "open-type='share'>推荐给朋友</button>", "<button", "open-type='feedback'>意见反馈", "复制代码这个两个功能就是用了，微信小程序的button", "组件，这里需要注意的就是，在清除", "button", "的默认样式时，需要把", "button", "的", "after", "伪元素的边框也去掉。button::after{", "border:", "0;", "}", "复制代码可以优化的地方有一些地方是小程序在替用户做选择，比如，如果所选择的图片不是正方形，就画中间的部分，但是中间的部分不一定是用户想要的，而如果每张图片都要用户自己来选择画哪部分，一共81张图片，显然是有些麻烦了，这里还可以继续优化下。还有在补充图片的时候，补充的图片也不一定是用户喜欢的，所以这部分再考虑是不是可以加一些标签，用户选择不同的标签，来补充符合标签的图片，类似", "QQ音乐的歌词海报这样。总结这次做的这个九宫格心形拼图的小程序，第一版已经上线了。开源地址：", "github.com/FEWY/jigsaw如果你喜欢这个小程序的话，可以", "star", "支持一下。这个小程序不管在代码，还是功能上都还有许多地方可以继续优化，如果有需要的朋友可以直接拿去改。"]}
{"author": "Rolan", "title": "撸一个小程序前置授权组件 ", "content": ["因业务上的需求，需要在某些点击区域上增加这样一层逻辑：如果该用户没有授权基本信息", "/", "手机号，在点击该区域时，先弹出微信的授权弹窗，授权成功后再进行下一步的业务操作。其中用到了", "@", "dannnney", "的weapp-event", "传送门本案例", "github源码", "欢迎star~~思路因为授权基本信息", "/", "手机号", "必须使用小程序原生的的button，然后指定", "open-type", "后通过回调才能拿到相关信息(", "wx.getUserInfo()", "已经不能弹窗啦，必须通过button弹窗)，但是需要前置授权的点击区域样式又不一定是button的样式，所以决定使用一个透明的原生button", "覆盖在点击区域之上，在视觉上实现无差别授权。通过是否授权字段来决定该按钮是否显示。因为小程序中可能有多个需要相同授权的点击区域，所以决定用观察者模式来实现，即其中一个组件授权后，更新所有相同授权的组件，隐藏授权button。样式因为需要让授权button完全覆盖在点击区域之上，所以需要让slot里面的内容撑开父级定位元素，然后授权button绝对定位在该父元素内，宽高都设为100%即可。也可以通过小程序组件的", "externalClasses", "从组件外部指定样式。代码如下：.wrapper", "{", "position:", "relative;", "width:", "100%;", "height:", "100%;", ".auth", "{", "position:", "absolute;", "width:", "100%;", "height:", "100%;", "opacity:", "0;", "top:", "0;", "left:", "0;", "z-index:", "10;", "}", "}", "复制代码<view", "class=\"wrapper", "m-class\">", "<view", "bind:tap=\"handleTap\">", "<slot></slot>", "</view>", "<block", "wx:if=\"{{!authorized}}\">", "<button", "class=\"auth\"", "open-type=\"{{openType}}\"", "bindgetphonenumber=\"getPhoneNumber\"", "bindgetuserinfo=\"getUserInfo\">", "</button>", "</block>", "</view>", "复制代码效果：未设置透明度（青色区域均为授权按钮）将透明度设为0以后逻辑propertiesopenType", "通过设置不同的参数来设置组件的授权类型dataauthorized", "通过该值控制", "授权按钮是否显示attached在组件的", "attached", "阶段，判断用户是否授权，如果授权，直接将", "authorized", "置为", "false如果用户没有授权，则初始化监听器detached移除监听器需要在组件外部绑定点击区域本身的点击事件，在已经授权的情况下会触发点击回调。<authorization-block", "bind:action=\"callBack\"", "m-class=\"xxx\">", "<view", "class=\"u-m\">", "xxxxxxx", "</view>", "</authorization-block>", "复制代码详细代码：import", "event", "from", "'../../utils/event'", "Component({", "externalClasses:", "['m-class'],", "properties:", "{", "openType:", "{", "type:", "String,", "value:", "'getUserInfo'", "}", "},", "data:", "{", "authorized:", "false", "},", "methods:", "{", "getPhoneNumber", "({detail})", "{", "const", "vm", "=", "this", "if", "(detail.errMsg", "===", "'getPhoneNumber:ok')", "{", "/*", "*", "获取到用户手机号后的业务代码", "*", "*/", "vm._triggerEvent(detail)", "}", "},", "getUserInfo", "({detail:", "{userInfo:", "{avatarUrl,", "nickName},", "errMsg}})", "{", "const", "vm", "=", "this", "if", "(errMsg", "===", "'getUserInfo:ok')", "{", "/*", "*", "获取到用户信息后的业务代码", "*", "*/", "vm._triggerEvent()", "}", "},", "_triggerEvent", "(arg)", "{", "const", "vm", "=", "this", "/*", "*", "触发监听器后，再触发点击区域本身的点击回调", "*", "*/", "event.triggerEvent([vm.data.config.eventName],", "true)", "vm.triggerEvent('action',", "arg)", "},", "handleTap", "()", "{", "const", "vm", "=", "this", "vm.triggerEvent('action')", "}", "},", "attached", "()", "{", "const", "vm", "=", "this", "let", "config", "switch", "(vm.data.openType)", "{", "case", "'getUserInfo':", "config", "=", "{", "eventName:", "'userInfo'", "}", "break", "case", "'getPhoneNumber':", "config", "=", "{", "eventName:", "'phoneNumber'", "}", "break", "}", "if", "(getApp().globalData[config.eventName])", "{", "vm.setData({", "authorized:", "true", "})", "}", "else", "{", "event.addEventListener([config.eventName],", "vm,", "(authorized)", "=>", "{", "if", "(authorized)", "{", "vm.setData({", "authorized:", "true", "})", "}", "})", "}", "vm.setData({", "config", "})", "},", "detached", "()", "{", "const", "vm", "=", "this", "event.removeEventListener([vm.data.config.eventName],", "vm)", "}", "})", "复制代码其他可以根据业务需要扩充", "open-type", "的相关逻辑，案例中只有", "userInfo", "和phoneNumber。不能在slot上直接绑定tap事件，在基础库版本为1.9.7及以下版本无法响应事件，所以在外部再包一层view转载请注明出处，觉得有用的话在", "github", "上赐颗星，谢谢~"]}
{"author": "Rolan", "title": "小程序打包插件开发体验 ", "content": ["相信开发过插件的同学，都看过Writing", "a", "Plugin", "或类似的文章，因为", "mini-program-webpack-loader", "这个工具开发时正好", "webpack", "4", "发布了，所以就阅读了这篇文章，顺便看了以下几篇文档。Writing", "a", "PluginPlugin", "PatternsPlugin", "APILoader", "API如果你看过文档，相信你一定知道：每个插件必须要有", "apply", "方法，用于", "webpack", "引擎执行你想要执行的代码。两个重要的对象", "Compiler", "和", "Compilation，你可以在上面绑定事件钩子（webpack", "执行到该步骤的时候调用），具体有哪些事件钩子可以阅读Compiler", "hooks。module", "和", "chunk", "的关系，我们可以理解为每个文件都会有一个", "module，而一个", "chunk", "则是由多个", "module", "来组成。webpack", "整个打包流程有那些事件如何写一个简单的", "loader如果感觉无从着手，可以继续看看我是如何一步步开发并完善", "mini-program-webpack-loader", "来打包小程序的。小程序有一个固定的套路，首先需要有一个", "app.json", "文件来定义所有的页面路径，然后每个页面有四个文件组成：.js，.json，.wxml，.wxss。所以我以", "app.json", "作为", "webpack", "entry，当", "webpack", "执行插件的", "apply", "的时候，通过获取", "entry", "来知道小程序都有哪些页面。大概流程像下面一张图，一个小程序打包插件差不多就这样完成了。这里使用了两个插件", "MultiEntryPlugin，SingleEntryPlugin。为什么要这样做呢？因为", "webpack", "会根据你的", "entry", "配置（这里的", "entry", "不只是", "webpack", "配置里的", "entry，import(),", "require.ensure()", "都会生成一个", "entry）来决定生成文件的个数，我们不希望把所有页面的", "js", "打包到一个文件，需要使用", "SingleEntryPlugin", "来生成一个新的", "entry", "module；而那些静态资源，我们可以使用", "MultiEntryPlugin", "插件来处理，把这些文件作为一个", "entry", "module", "的依赖，在", "loader", "中配置", "file-loader", "即可把静态文件输出。伪代码如下：const", "MultiEntryPlugin", "=", "require('webpack/lib/MultiEntryPlugin');", "const", "SingleEntryPlugin", "=", "require('webpack/lib/SingleEntryPlugin');", "class", "MiniPlugin", "{", "apply", "(compiler)", "{", "let", "options", "=", "compiler.options", "let", "context", "=", "compiler.rootContext", "let", "entry", "=", "options.entry", "let", "files", "=", "loadFiles(entry)", "let", "scripts", "=", "files.filter(file", "=>", "/\\.js$/.test(file))", "let", "assets", "=", "files.filter(file", "=>", "!/\\.js$/.test(file))", "new", "MultiEntryPlugin(context,", "assets,", "'__assets__').apply(compiler)", "scripts.forEach((file", "=>", "{", "let", "fileName", "=", "relative(context,", "file).replace(extname(file),", "'');", "new", "SingleEntryPlugin(context,", "file,", "fileName).apply(compiler);", "})", "}", "}", "复制代码当然，如果像上面那样做，你会发现最后会多出一个", "main.js，xxx.js（使用", "MultiEntryPlugin", "时填的名字），main.js", "对应的是配置的", "entry", "生成的文件，xxx.js", "则是", "MultiEntryPlugin", "生成的。这些文件不是我们需要的，所以需要去掉他。如果熟悉", "webpack", "文档，我们有很多地方可以修改最终打包出来的文件，如", "compiler", "的", "emit", "事件，compilation", "的", "optimizeChunks", "相关的事件都可以实现。其本质上就是去修改", "compilation.assets", "对象。在", "mini-program-webpack-loader", "中就使用了", "emit", "事件来处理这种不需要输出的内容。大概流程就像下面这样：小程序打包当然没这么简单，还得支持wxml、wxss、wxs和自定义组件的引用，所以这个时候就需要一个", "loader", "来完成了，loader", "需要做的事情也非常简单", "——", "解析依赖的文件，如", ".wxml", "需要解析", "import", "组件的", "src，wxs", "的", "src，.wxss", "需要解析", "@import，wxs", "的", "require，最后在", "loader", "中使用", "loadModule", "方法添加即可。自定义组件一开始在", "add", "entry", "步骤的时候直接获取了，所以不需要", "loader", "来完成。这个时候的图：这样做也没什么问题，可是开发体验是比较差的，如再添加一个自定义组件，一个页面，webpack", "是无感知的，所以需要在页面中的", ".json", "发生改变时检查是不是新增了自定义组件或者新增了页面。这个时候遇到一个问题，自定义组件的", "js", "是不能通过", "addModule", "的方式来添加的，因为自定义组件的", "js", "必须作为独立的入口文件。在", "loader", "中是做不了，所以尝试把文件传到", "plugin", "中（因为", "plugin", "先于", "loader", "执行，所以是可以建立", "loader", "和", "plugin", "通信的）。简单粗暴的方式：//", "loader.js", "class", "MiniLoader", "{}", "module.exports", "=", "function", "(content)", "{", "new", "MiniLoader(this,", "content)", "}", "module.exports.$applyPluginInstance", "=", "function", "(plugin)", "{", "MiniLoader.prototype.$plugin", "=", "plugin", "}", "//", "plugin.js", "const", "loader", "=", "require('./loader')", "class", "MiniPlugin", "{", "apply", "(compiler)", "{", "loader.$applyPluginInstance(this);", "}", "}", "复制代码但是...。文件是传到", "plugin", "了，可是再使用", "SingleEntryPlugin", "时你会发现，没效果。因为在", "compiler", "make", "之后", "webpack", "已经不能感知新的", "module", "添加了，所以是没有用的，这个时候就需要根据文档猜，怎么样才能让", "webpack", "感知到新的", "module，根据文档中的事件做关键字查询，可以发现在编译完成的时候会调用", "compilation", "needAdditionalPass", "事件钩子：this.emitAssets(compilation,", "err", "=>", "{", "if", "(err)", "return", "finalCallback(err);", "if", "(compilation.hooks.needAdditionalPass.call())", "{", "compilation.needAdditionalPass", "=", "true;", "const", "stats", "=", "new", "Stats(compilation);", "stats.startTime", "=", "startTime;", "stats.endTime", "=", "Date.now();", "this.hooks.done.callAsync(stats,", "err", "=>", "{", "if", "(err)", "return", "finalCallback(err);", "this.hooks.additionalPass.callAsync(err", "=>", "{", "if", "(err)", "return", "finalCallback(err);", "this.compile(onCompiled);", "});", "});", "return;", "}", "this.emitRecords(err", "=>", "{", "if", "(err)", "return", "finalCallback(err);", "const", "stats", "=", "new", "Stats(compilation);", "stats.startTime", "=", "startTime;", "stats.endTime", "=", "Date.now();", "this.hooks.done.callAsync(stats,", "err", "=>", "{", "if", "(err)", "return", "finalCallback(err);", "return", "finalCallback(null,", "stats);", "});", "});", "});", "复制代码如果在这个事件钩子返回一个", "true", "值，则可以使", "webpack", "调用", "compiler", "additionalPass", "事件钩子，尝试在这里添加文件，果然是可以的。这个时候的图就成了这样：当然，小程序打包还有些不同的地方，比如分包，如何用好", "splitchunk，就不在啰嗦了，当你开始以后你会发现有很多的方法来实现想要的效果。插件开发到这里差不多了，总的来说，webpack", "就是变着花样的回调，当你知道每个回调该做什么的时候，webpack", "用起来就轻松了。明显我不知道，因为在开发过程中遇到了一些问题。遇到的问题1.如何在小程序代码中支持", "resolve", "alias，node_modules？既然是工具，当然需要做更多的事情，有赞的小程序那么复杂，如果支持", "resolve", "alias，node_modules", "可以使得项目更方便维护，或许你会说这不是", "webpack", "最基本的功能吗，不是的，我们当然是希望可以在任何文件中使用", "alias，node_modules", "支持的不仅仅是", "js。当然这样做就意味着事情将变得复杂，首先就是获取文件路径，必须是异步的，因为在", "webpack", "4", "中", "resolve", "不再支持", "sync。其次就是小程序的目录名不能是", "node_modules，这时就需要一种计算相对路径的规则，还是相对打包输出的，而不是相对当前项目目录。2.多个小程序项目的合并有赞从小程序来讲，有微商城版，有零售版，以及公共版，其中大多基础功能，业务都是相同的，当然不能再每个小程序在开发一次，所以这个工具具备合并多个小程序当然是必须的。这样的合并稍微又要比从", "node_modules", "中取文件复杂一些，因为需要保证多个小程序合并后的页面是正确的，而且要保证路径不变。这两个问题的最终的解决方案既是以", "webpack", "rootContext", "的", "src", "目录为基准目录，以该目录所在路径计算打包文件的绝对路径，然后根据入口文件的", "app.json", "所在目录的路径计算出最终输出路径。exports.getDistPath", "=", "(compilerContext,", "entryContexts)", "=>", "{", "/**", "*", "webpack", "以", "config", "所在目录的", "src", "为打包入口", "*", "所以可以根据该目录追溯源文件地址", "*/", "return", "(path)", "=>", "{", "let", "fullPath", "=", "compilerContext", "let", "npmReg", "=", "/node_modules/g", "let", "pDirReg", "=", "/^[_|\\.\\.]\\//g", "if", "(isAbsolute(path))", "{", "fullPath", "=", "path", "}", "else", "{", "//", "相对路径：webpack", "最后生成的路径，打包入口外的文件都以", "'_'", "表示上级目录", "while", "(pDirReg.test(path))", "{", "path", "=", "path.substr(pDirReg.lastIndex)", "fullPath", "=", "join(fullPath,", "'../')", "}", "if", "(fullPath", "!==", "compilerContext)", "{", "fullPath", "=", "join(fullPath,", "path)", "}", "}", "//", "根据", "entry", "中定义的", "json", "文件目录获取打包后所在目录，如果不能获取就返回原路径", "let", "contextReg", "=", "new", "RegExp(entryContexts.join('|'),", "'g')", "if", "(fullPath", "!==", "compilerContext", "&&", "contextReg.exec(fullPath))", "{", "path", "=", "fullPath.substr(contextReg.lastIndex", "+", "1)", "console.assert(!npmReg.test(path),", "`文件${path}路径错误：不应该还包含", "node_modules`)", "}", "/**", "*", "如果有", "node_modules", "字符串，则去模块名称", "*", "如果", "app.json", "在", "node_modules", "中，那", "path", "不应该包含", "node_modules", "*/", "if", "(npmReg.test(path))", "{", "path", "=", "path.substr(npmReg.lastIndex", "+", "1)", "}", "return", "path", "}", "}", "复制代码3.如何把子包单独依赖的内容打包到子包内解决这个问题的方法是通过", "optimizeChunks", "事件，在每个", "chunk", "的依赖的", "module", "中添加这个", "chunk", "的入口文件，然后在", "splitChunk", "的", "test", "配置中检查", "module", "被依赖的数量。如果只有一个，并且是被子包依赖，则打包到子包内。4.webpack", "支持单文件失败这是一个未解决的问题，当尝试使用", "webpack", "来支持单文件的时候，好像没那么方便：单文件拆分为四个文件后，可以使用", "emitFile", "和", "addDependency", "来创建文件，但是创建的文件不会执行", "loader使用", "loadModule", "会因为文件系统不存在该文件会报错"]}
{"author": "Rolan", "title": "微信小程序仿APP section header 悬停效果 ", "content": ["很多APP都有这么一个效果，列表头在滚动到顶部时会悬停在顶部，比如在iOS开发中UITableview设置", "style", "属性设置为", "Plain", "，这个tableview的section", "header在滚动时会默认悬停在界面顶端。那么我们怎么在微信小程序也实现这么一个效果呢？", "首先写一个非常简单列表：wxml代码<view", "class='header'>这里是header</view><view", "class='section-header'>这是section-header</view>", "<block", "wx:for=\"{{testData}}\">", "<view", "class='section-cell'>{{item}}</view></block>wxss代码.header", "{", "height:", "300rpx;", "width:", "750rpx;", "background-color:", "bisque;", "margin-bottom:", "10rpx;}.section-header", "{", "height:", "80rpx;", "width:", "750rpx;", "background-color:", "rebeccapurple;}.section-cell", "{", "height:", "180rpx;", "width:", "750rpx;", "background-color:", "gold;", "margin-top:", "10rpx;}简单列表效果.png", "那我们要怎么样让头部悬停呢？1、我们需要在页面布局完成后获取到头部的位置：在onReady方法中，查询section-header节点并拿到该节点此时距离当前顶部的距离注意是", "此时，这个后面再讲", "/**", "*", "页面加载完成", "*/", "onReady:", "function", "()", "{", "let", "that", "=", "this", "let", "query", "=", "wx.createSelectorQuery()", "query.select(\".section-header\").boundingClientRect(function", "(res)", "{", "//", "console.log(res)", "that.setData({", "//section", "header", "距离", "‘当前顶部’", "距离", "sectionHeaderLocationTop:", "res.top", "})", "}).exec()", "},2、我们需要监听页面滚动：fixed用来控制是否悬停", "/**", "*", "页面滚动监听", "*/", "onPageScroll:", "function", "(e)", "{", "//console.log(e)", "this.setData({", "scrollTop:", "e.scrollTop", "})", "if", "(e.scrollTop", ">", "this.data.sectionHeaderLocationTop)", "{", "this.setData({", "fixed:", "true", "})", "}", "else", "{", "this.setData({", "fixed:", "false", "})", "}", "},3、修改相应的样式：将原来的header修改为如下代码，并添加一个placeholder视图，目的是当我们的section-header视图悬停时，保持占位，避免页面抖动<view", "class='{{fixed", "?", "\"section-header", "section-fixed\":", "\"section-header\"}}'>这是section-header</view><view", "hidden='{{!fixed}}'", "class=\"section-header", "section-placeholder\"></view>", "增加wxss代码.section-placeholder", "{", "background-color:", "white;}.section-fixed", "{", "position:", "fixed;", "top:", "0;}附上js", "data", "代码:", "data:", "{", "testData:[1,2,3,4,5,6,7,8,9,10],", "//section", "header", "距离", "‘当前顶部’", "距离", "sectionHeaderLocationTop:", "0,", "//页面滚动距离", "scrollTop:", "0,", "//是否悬停", "fixed:", "false", "},此时我们需要的效果就实现了：sectionHeader悬浮.gif", "这个有一个要注意的点，我们在使用swlectorQuery()的时候，获取到的top是当前调用改函数时相应节点对应当前顶部的距离，这就有一个问题，当我们的header的高度（不一定是header只要是section-header上面的视图的高度）发生变化的时候，悬停就会有问题，因为我们的高度是最开始的时候获取的。所以在我们改变高度之后，要再次调用该函数去获取距离\"当前顶部\"的距离，这也是要注意的一个点，如果我能直接再次获取并赋值，发现还是有问题，就是因为此时获取的top不是距离整个page页面顶部，而我们监听的页面滚动却是，所以我们可以修改代码如下：", "let", "that", "=", "this", "let", "query", "=", "wx.createSelectorQuery()", "query.select(\".section-header\").boundingClientRect(function", "(res)", "{", "//", "console.log(res)", "that.setData({", "//section", "header", "距离", "‘当前顶部’", "距离", "sectionHeaderLocationTop:", "res.top", "+", "that.data.scrollTop", "})", "}).exec()加上此时页面滚动的距离，则能保证我们预期的效果出现！！！！"]}
{"author": "Rolan", "title": "扫码付小程序优化实践 ", "content": ["前几日作者在掘金上看到了【微信小程序性能优化】这篇文章，当时心想这个团队做的事情和我们方向很相似，仔细一看原来是微信公开课上小程序专场中“小程序性能优化”模块的记录，而其中我们提出的建议（独立分包）也即将发布。借着这个机会，我们也决定把在扫码付小程序中的一些优化实践分享出来。作者：", "@陈小二", "@simpxu什么是扫码付小程序？美团扫码付小程序是一款面向C端消费者推出的线下收单业务。它寄托在美团小程序下，在实际场景中，用户先使用微信扫一扫扫描商家二维码，接着调起扫码付小程序，进入支付页后输入金额向商家完成商品支付。扫码付小程序功能图我们的目标？我们一直在做一件事情：提升扫码付小程序的支付转化率。这里所提的支付转化率指：整个业务流程中用户成功支付到扫码的占比。支付转化率与扫码付业务来讲，百分比越高，扫码付业务的营业额收入越高，带来的收益是成正比的。而这部分转化率流失的影响，我们认为包含两个部分：扫码到进入小程序环节（外部环节）进入小程序到支付环节（内部环节）在扫码到进入小程序环节，微信会完成小程序基本信息获取、资源准备（代码下载或更新）等准备事项，在准备事项中若准备失败或时间过长会导致用户手动离开，这部分由微信控制的环节称之为外部环节；在进入小程序到支付环节，页面会进行渲染、数据请求等，如果渲染时间长、数据请求时间长也易导致用户手动离开，而数据请求失败也会造成用户使用流程终止而离开，这部分由我们自己控制的环节称之为内部环节。如何提升外部环节转化率？对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们无法得知此处的细节。而我们在扫码付小程序中尝试和微信的同学做了一次梳理，发现扫码付小程序在外部环节的丢失率较高，查询数据发现其中大部分用户手动点击了右上角的退出。从业务出发，用户使用扫码付可以认为用户是有强需求进行支付，能够造成用户手动点击退出的行为部分原因可能来自于等待时间较长，而在这个环节对时间造成影响更多的是资源准备，即小程序代码下载或者更新的行为。影响下载和更新时间可能的因素有：网络代码包用户网络是我们无法控制的，只能尝试从代码包开始下手。而在当时未使用分包的情况下，我们的主包大小约3M，意味着新用户和无缓存小程序用户均需要在首次使用时等待下载3M左右的包大小，在这种情况下虽然用户享受了小程序离线缓存包的福利，却丢失了大部分新用户的体验。于是我们尝试从包代码大小做了一些优化：增加分包加载机制。用户在使用扫码付业务时会按需进行加载，优化小程序首次启动的下载时间。减小主包和分包大小。按照空主包的概念进行优化。在进行分包加载机制后，主包无法最小化依然影响首次下载时间。一方面，原有的3M整包中，图片大小占用了50%大小，我们将所有的内含二进制和Base64图片分发到了CDN；另一方面，部分可移出的业务分发到了其他分包。在做了这些事情后，扫码付分包从原先的整包3M缩减到了361k(主包300k+分包61)，而外部环节的转化率也提升了3%。虽然转化率提升了，但前置环节的转化率仍然有部分丢失，理论上继续缩减300k的主包能有效提升，但由于业务性质的原因无法再继续缩减，于是我们向微信小程序提出了独立分包的概念:用户在使用独立分包时无需下载主包。通过独立分包加载，程序使用期间下载更新阶段只需要加载61k的分包大小，目前这个功能还在内测阶段，扫码付小程序也在作为第一批的内测用户进行体验，优化效果在之后的实践中我们也会分享出来。如何提升内部环节转化率？在进入小程序到支付这个环节，属于我们的业务流程。在这个环节中的转化率丢失虽然是我们能掌控的，但我们并无头绪，所以我们做了一些数据监控来寻求方法：业务核心流程监控。业务核心流程指用户进入小程序后所涉及到的影响最终支付的中间流程，中间流程的丢失直接影响业务整个转化率丢失，所以它们是必须监控的。而业务核心流程监控需要可监控的具体指标，我们对进入小程序和支付进行了关键动作拆解，从扫码到用户看到页面、再到点击支付、初始化订单、支付成功。拆解完这些关键动作，再针对每一步可控环节，进行技术指标的拆解。从入口到出口的每一步制定关键指标（扫码加载转化率、点击意愿等，见下图），形成一个至上而下的漏斗，产出多个可量化指标，来做业务流程的监控。对于这部分可量化指标，通过长期的观察分析来提升转化率。异常监控。页面的任何异常都可能导致支付页面的渲染失败，从而无法正常支付。我们对页面的接口异常、微信API异常进行了监控。接口异常可在API（wx.request)的fail函数中直接捕获，从而上报监控；对于接口超时，则只能通过全局的app.json进行全局设置（默认60s，时间过长，对用户体验较差），此前我们曾尝试在小程序中设置全局的5s请求超时，但实际应用中并非所有场景需要设置统一的超时，最终我们单独封装了接口请求超时。微信API的异常通过微信的一些fail中进行监控即可。性能监控。小程序内部转化环节中关注进入小程序后的白屏时间和可交互时间。内部白屏时间从onLoad处打点，到页面onReady处结束；内部可交互时间从onLoad处打去kjnpl0o09o0点，到页面数据请求结束后的可点击支付时间截止。日常监控中，我们也发现了一些问题，例如接口调用超时、接口调用失败，这些问题会导致页面流程终止。针对这些问题，做了一些优化：接口合并。支付页面的外网链路接口请求数量较多，任意一个接口的失败都会导致问题，合并接口则可以减少问题出现概率，提升中间流程的转化率。增加重试机制。在出现接口异常的情况下，会直接导致页面阻塞，如果通过重试能成功，则可以提升转化率。整个流程中可重试的有两类：自有的接口请求异常小程序API调用异常对于这两类异常，在接口超时、调用失败时采取重试。而为了避免在极端情况下服务端流量陡增、峰值倍数增加，页面的可重试次数会在前置获取全局配置时根据“可重试次数”控制，并且每次重试需要在一段时间后用户手动触发。超过重试次数时，则流程终止。如何监控内部和外部环节？前面我们也提到，对于小程序开发者而言，扫码到小程序调起这个环节是黑盒的，我们开发者无法得知此处的细节，所以说在监控外部环节这方面我们开发者似乎可做的事情屈指可数。但是，不知道细心的同学有没有发现，微信在每次扫码后会给我们在query参数上附带一个scancode_time字段。其实这个字段表示的是用户在使用扫一扫时微信服务端记录的时间，所以基于这个字段的考量，我们做了如下尝试，针对以下两个参数值分别做了实时监控：支付页面的白屏时间（用户看到首屏的客户端时间—用户微信扫一扫服务端时间+服务端客户端差额时间）支付页面的用户可交互时间（页面Loading完毕时间—用户微信扫一扫服务端时间+服务端客户端差额时间）Tips：由于客户端的时间戳是获取本地手机系统的时间，可能存在差异。所以为了保证上报的准确性，我们在每次onLoad的时候取了一次我们服务端的时间，记录了客户端的时间与服务端的一个时间差额，并且在后续所有涉及到服务端的时间都参照这个时间差额做计算（网络100-200ms级别的传输时延暂可忽略）但由于我们扫码付小程序的特殊应用场景就是为了保障用户进行快速可靠的支付，既然在外部环节可控度不高，那是不是可以考虑在内部的业务流程方面把监控统计做的细粒度一点，做到能对每一个可能影响到支付的环节有数据可循呢？所以我们针对这个方向，区别于传统的pv、uv统计，对业务上报做了如下分类：根据上报的场景划分：实时性监控部分与统计部分根据上报的类型划分：Error类型、Event类型（普通生命周期事件）、Metric类型（自定义Event类型，维度可自定义）、自定义测速类型（延时趋势与分布）基于上述方案的探索，我们小组基本上做到了对可能影响支付环节的某些业务指标的把控。从而在下一步，可以针对每个潜在的可优化点做进一步思考与考量，作出及时的策略优化与更新。总结通过对扫码付小程序的探索，我们积累了比较宝贵的优化经验，不过对于能优化的方面，还需要我们更进一步探索，距离我们的目标还很远。当然如果你有兴趣，我们更希望你能加入我们，一起探索未来。所以这里呢也打个广告，对我们“智能支付大前端团队”有兴趣的同学可直接简历发送给陈小二同学（chenyao05@meituan.com）。"]}
{"author": "Rolan", "title": "简单谈谈setTimeout与setInterval ", "content": ["感谢踩过的坑sf社区的第一篇文章。最近在做一个拍卖的微信小程序，用到了定时器setTimout和setInterval,简单谈谈这两个api。setTimeout最常见的用法就是第二种(第三种mdn文档不推荐)，如:var", "timeoutId", "=", "setTimeout(function()", "{", "console.log('hello", "world!')", "},1000)", "定时器是先等待1000ms再执行function的语句，而不是一开始就执行然后再等待。如果执行的语句需要用到this引用，需要在回调函数function上绑定this：function()", "{...}.bind(this)，把this传给回调函数，同作为该回调函数的this，使回调函数内外this的指向保持一致。或者用es6的箭头函数()", "=>", "{}，也能起到同样的作用。bind的用法详见Function.prototype.bind()用完定时器之后，要记得清除：clearTimeout(timeoutId)", "这里的timeoutId是setTimeout返回的一个正整数编号，是定时器的唯一标识符。setInterval在我看来基本上可以当成setTimeout的升级版，就像setTimeout循环调用自身，用法也跟setTimeout一样，用完是也要记得用clearInterval清掉定时器。底层原理或许会有些不同，这里就不深究。下面是我在微信小程序倒计时组件：//", "components/countdown.js", "/**", "*", "倒计时组件", "*/", "Component({", "/**", "*", "组件的属性列表", "*/", "properties:", "{", "durationInit:", "{", "type:", "Number,", "value:", "0,", "observer:", "function(newVal)", "{", "//监控duration初始值变动(看有没有外部传入新的时间)", "this.initDuration(newVal)", "}", "}", "},", "/**", "*", "组件的初始数据", "*/", "data:", "{", "duration:", "0,", "//剩余时间,单位秒", "timeDisplay:", "''", "//展示时间", "},", "intervalId:", "null,", "//计时器Id,不需要渲染，放外面，免得影响性能", "/**", "*", "组件销毁了要清除计时", "*/", "detached()", "{", "this.stopInterval(this.intervalId)", "},", "/**", "*", "组件的方法列表", "*/", "methods:", "{", "//", "设置时间", "setTime:", "function(duration)", "{", "if", "(duration", "<=", "0)", "{", "this.setData({", "timeDisplay:", "`活动结束啦`", "})", "//this.data.timeDisplay", "=", "`活动结束啦，戳这里看看好东西~`", "return", "false", "}", "var", "s", "=", "this.formatTime(duration", "%", "60)", "var", "m", "=", "this.formatTime(Math.floor(duration", "/", "60)", "%", "60)", "var", "h", "=", "this.formatTime(Math.floor(duration", "/", "3600)", "%", "24)", "var", "d", "=", "this.formatTime(Math.floor(duration", "/", "3600", "/", "24))", "var", "time", "=", "`${d}:${h}:${m}:${s}`", "//写入", "this.setData({", "timeDisplay:", "time", "})", "return", "true", "},", "//倒计时", "countDown:", "function(duration)", "{", "//有没有倒计时的必要.第一次展示时间(这个很重要)", "var", "canCountDown", "=", "this.setTime(duration)", "if", "(canCountDown", "===", "true)", "{", "var", "intervalId", "=", "setInterval(", "function()", "{", "//清除计时器", "if", "(this.data.duration", "<=", "0)", "{", "this.stopInterval(intervalId)", "}", "this.setData({", "duration:", "this.data.duration", "-", "1", "})", "this.setTime(this.data.duration)", "}.bind(this),", "1000", ")", "this.intervalId", "=", "intervalId", "}", "},", "//初始化剩余时间", "initDuration:", "function(newVal)", "{", "if", "(this.intervalId)", "{", "//若有计时器，清除", "this.stopInterval(this.intervalId)", "}", "this.setData({", "duration:", "this.data.durationInit", "})", "this.countDown(newVal)", "},", "//清除计时器", "stopInterval:", "function(intervalId)", "{", "if", "(intervalId", "!=", "null)", "{", "clearInterval(intervalId)", "this.intervalId", "=", "null", "}", "},", "//格式化时间", "formatTime(time)", "{", "return", "time", "<", "10", "?", "`0${time}`", ":", "`${time}`", "}", "}", "})", "最后想吐槽一下W3School，随着学习的深入，发现W3School的坑真多，强烈建议不要看W3School学前端，要看MDN文档。可能很多人的前端启蒙就是W3School，我也是。名字跟W3C很像，还以为是非常专业的网站，然而后来发现跟W3C并没有什么关系。W3School在baidu搜索排名非常高，被坑了，baidu也是同谋。现在早已拥抱google，清爽！下面就拿setInterval的说明做例子，对比一下MDN和W3School，就知道后者有多坑了。通过上面3张图片，可以看出1.", "W3School含糊其辞，解释不清楚，不详细。用的时候容易出问题W3School：周期性执行...请告诉我如果先执行了回调函数，再等待1秒，再执行回调函数，这算不算得上周期性？？MDN：详细指出函数的每次调用会在该延迟之后发生2.", "不推荐的用法没有指出，文档更新慢，权威性极低W3School：连举的例子都是不推荐的用法，用code代码串。。。MDN：详细指出使用code不推荐，不仅如此，还发散性指出原因和eval()一样，真的很贴心很友好了以上图片均来源于MDN和W3School在最后，感谢踩过的坑，让我成长！初来乍到，多多关照，希望能坚持写技术博文。"]}
{"author": "Rolan", "title": "开发笔记：使用 mpvue 开发斗图小程序 ", "content": ["之前用过", "wepy", "框架写了个小程序", "GitHub", "-", "yshkk/shanbay-mina:", "基于", "wepy", "框架的", "“扇贝阅读”", "微信小程序", "，感觉写法上类似", "vue，但不那么彻底。现在美团点评发布的", "mpvue", "支持开发者可以用", "vue", "的语法开发微信小程序，正好有强需求需要一个斗图小程序，所以就尝试了下。项目地址GitHub", "-", "yshkk/bqb-mpvue:", "基于", "mpvue", "的表情包斗图微信小程序扫码体验截图开发细节和坑使用", "iView", "Weapp", "组件库相关代码", "pages/index/main.js", "第", "8", "行将组件库的", "dist", "目录拷贝到自己项目", "static", "目录，然后在需要用到组件的页面配置", "usingComponents", "即可。开发期间可能对组件的样式不太满意，或者一些蜜汁问题（比如", "input", "下边框突然消失", "issue", "），要改的话方式非常诡异", "相关", "issue", "，所以粗暴点的方式就是直接改组件库里的", "wxss", "文件。v-show", "和", "v-model", "不好使相关代码", "pages/index/index.vue", "第", "4", "行关于", "v-show", "相关", "issue", "，所以只能用", "v-if", "替代。使用", "v-if", "会销毁不显示的组件，但有个场景是期望保留原来的组件，因此只能曲线救国在组件外层包一个", "<", "view", ">", "使用", ":style=\"{display?condition?'block':'none'}\"", "的方式（其实最好是用", "keep-alive", "的方法，可惜", "mpvue", "不支持）。v-model", "就很奇怪了，好像", "input", "不能双向绑定，原因是自定义组件就没有支持", "v-model", "，所以得手动", "update", "data。同理使用组件库", "input", "后不能使用", "v-focus", "。(相关", "issue", ")模板语法里不能调用", "methods", "方法相关代码", "components/homppage.vue", "第", "52", "行可以说是血坑了，一直以为我使用姿势有误，费了好长时间。后来才从", "articles", "/", "美团小程序框架", "mpvue", "蹲坑指南.", "md", "at", "master", "·", "noahlam/articles", "·", "GitHub", "看到原来这是", "mpvue", "不支持。", "当时的场景是这样的：", "在图片列表里，给被用户", "“收藏”", "过的图片加个额外的", "className，该", "className", "可以给图片加个粉色边框，这样就能在图片列表中一眼看到哪些是被收藏过的。data", "里有一个表示所有图片的数组", "imageList", "和一个表示收藏列表的数组", "favoriteList", "。起初的写法是<image", "v-for=\"img", "in", "imageList\"", ":src=\"img.url\"", ":class=\"isFavorite(img.url)?'image-favorite':'image'\"", "复制代码其中", "isFavorite", "是在", "methods", "里的一个方法，判断当前图片", "url", "是否在", "favoriteList", "里。然而这样写一直不", "work，后来只能换个方案：在", "computed", "里跟据", "imageList", "和", "favoriteList计算出", "一个叫", "imageListWithFavorite", "的数组，遍历这个数据即可:joy:", "虽然很丑陋但是还能用。将用户收藏同步到本地存储相关代码", "components/homppage.vue", "第", "63", "行用户收藏的表情会放到微信提供的", "storage，类似浏览器的", "localstorage，这样在关闭小程序以后下次来还能看到自己的收藏，因此在组件需要", "watch", "favoriteList", "的变更并调用", "wx.setStorage", "方法。但是不知为何直接", "watch", "favoriteList", "并不会触发相应函数，而", "watch", "‘favoriteList.length’就能触发，希望有大佬能指点下。watch:", "{", "'favoriteList.length':", "{", "//", "将变化更新到本地存储", "handler:", "function", "(val,", "oldval)", "{", "this.updateStorage({method:", "val", ">", "oldval", "?", "'ADD'", ":", "'DELETE'})", "}", "}", "}", "复制代码表情包图片制作相关代码", "pages/maker/index.vue思路是初始化一个", "canvas，将表情模版（一张图片，url", "从跳转过来的页面的", "query", "里取得）绘制到", "canvas", "上，用户打字", "/", "设置颜色字体", "的时候调用", "updateCanvas", "。最后调用", "wx.canvasToTempFilePath", "方法输出成图片。", "关键代码如下ctx", "=", "wx.createCanvasContext('maker')", "//", "选择当前", "canvas", "...", "updateCanvas", "()", "{", "ctx.drawImage(this.path,", "0,", "0,", "300,", "300)", "//path", "为当前表情包的路径", "ctx.setTextAlign('center')", "//", "必须每次在", "updateCanvas", "重新设置，否则模拟器上生效但真机下不会生效", "ctx.setFontSize(this.fontSize)", "ctx.setFillStyle(this.currentColor)", "ctx.fillText(this.txt,", "this.x,", "this.y)", "ctx.draw()", "},", "复制代码有几个小坑：将图片绘制到", "canvas", "时指定的图片不能是一个远端图床的链接，必须先本地下载下来（调用", "wx.getImageInfo", "获取图片，得到本地一个临时", "path）才能绘制。canvas", "指定的大小单位是", "px，而用", "css", "控制的单位是", "rpx（mpvue", "用了", "px2rpx-loader", "，就算在", "css", "里写成", "px", "也会被编译成", "rpx）。小程序", "canvas", "的", "save", "和", "restore", "功能在这里很鸡肋，每次都需要完全重绘一次。特别是用户拖动文字更新文字坐标的功能，", "touchmove", "事件一直触发，就一直更新", "canvas，小程序里没有", "requestAnimationFrame", "的方法，所以就自己得~~", "从网上找~~", "封装一个，在拖动时起到节流的效果。canvas", "输出的图片只支持", "jpg", "或者", "png，因此即使用", "gif", "图的模版也只能生成静态的表情包，残念。总结大体上使用", "mpvue", "的体验还是挺好的。mpvue", "和", "wepy", "的写法上比较类似，mpvue", "对", "vue", "开发者来说更友好容易上手，wepy", "更接近于原生小程序。虽然框架的出现屏蔽了一些原生小程序写起来很丑陋的地方，", "但是不管用什么框架，原生小程序的文档还是需要掌握的", "，有一大堆的坑等着要踩，有时候不得不从编译出的文件里面找原因。"]}
{"author": "Rolan", "title": "微信小程序车牌键盘 ", "content": ["项目背景公司要做一个停车场微信小程序，支持临时车预支付以及支付记录查询等功能,其中涉及车牌输入的功能，为了提升用户体验，避免繁琐的输入，决定自己写一个键盘。效果图如下省份简写键盘如下:省份简写键盘英文简写键盘如下:英文简写键盘源代码目录结构目录结构wxml文件内容<view", "wx:if=\"{{isShow}}\"", "class=\"vehicle-panel\"", "style=\"height:430rpx;background-color:{{backgroundColor}}\">", "<!--省份简写键盘-->", "<block", "wx:if=\"{{keyBoardType", "===", "1}}\">", "<view", "class=\"vehicle-panel-row\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button'", "style=\"border:{{buttonBorder}}\"", "wx:for=\"{{keyVehicle1}}\"", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "</view>", "<view", "class=\"vehicle-panel-row\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button'", "style=\"border:{{buttonBorder}}\"", "wx:for=\"{{keyVehicle2}}\"", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "</view>", "<view", "class=\"vehicle-panel-row\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button'", "style=\"border:{{buttonBorder}}\"", "wx:for=\"{{keyVehicle3}}\"", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "</view>", "<view", "class=\"vehicle-panel-row-last\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button", "vehicle-panel-row-button-last'", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for=\"{{keyVehicle4}}\"", "style=\"border:{{buttonBorder}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "</view>", "</block>", "<!--英文键盘", "-->", "<block", "wx:else>", "<view", "class=\"vehicle-panel-row\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button", "vehicle-panel-row-button-number'", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for=\"{{keyNumber}}\"", "style=\"border:{{buttonBorder}}\"", "wx:for-index=\"idx\"", "wx:key=\"item\">{{item}}</view>", "</view>", "<view", "class=\"vehicle-panel-row\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button'", "style=\"border:{{buttonBorder}}\"", "wx:for=\"{{keyEnInput1}}\"", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "</view>", "<view", "class=\"vehicle-panel-row\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button'", "style=\"border:{{buttonBorder}}\"", "wx:for=\"{{keyEnInput2}}\"", "bindtap='vehicleTap'", "data-value=\"{{item}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "<view", "hover-class=\"vehicle-hover\"", "style=\"border:{{buttonBorder}}\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button", "vehicle-panel-row-button-img'>", "<image", "src='./delete.svg'", "class='vehicle-en-button-delete'", "bindtap='vehicleTap'", "data-value=\"delete\"", "mode='aspectFit'>删除</image>", "</view>", "</view>", "<view", "class=\"vehicle-panel-row-last\">", "<view", "hover-class=\"vehicle-hover\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button", "vehicle-panel-row-button-last'", "bindtap='vehicleTap'", "style=\"border:{{buttonBorder}}\"", "data-value=\"{{item}}\"", "wx:for=\"{{keyEnInput3}}\"", "wx:for-index=\"idx\"", "wx:key=\"idx\">{{item}}</view>", "<view", "hover-class=\"vehicle-hover\"", "style=\"border:{{buttonBorder}}\"", "hover-start-time=\"10\"", "hover-stay-time=\"100\"", "class='vehicle-panel-row-button", "vehicle-panel-ok'", "bindtap='vehicleTap'", "data-value=\"ok\">确定</view>", "</view>", "</block></view>json文件{", "\"component\":", "true}js文件Component({", "externalClasses:", "['v-panel'],", "properties:", "{", "isShow:", "{", "type:", "Boolean,", "value:", "false,", "},", "buttonBorder:", "{", "type:", "String,", "value:", "\"1px", "solid", "#ccc\"", "},", "backgroundColor:{", "type:", "String,", "value:", "\"#fff\"", "},", "//1为省份键盘，其它为英文键盘", "keyBoardType:", "{", "type:", "Number,", "value:", "1,", "}", "},", "data:", "{", "keyVehicle1:", "'陕京津沪冀豫云辽',", "keyVehicle2:", "'黑湘皖鲁新苏浙赣',", "keyVehicle3:", "'鄂桂甘晋蒙吉闽贵',", "keyVehicle4:", "'粤川青藏琼宁渝',", "keyNumber:", "'1234567890',", "keyEnInput1:", "'QWERTYUIOP',", "keyEnInput2:", "'ASDFGHJKL',", "keyEnInput3:", "'ZXCVBNM',", "},", "methods:", "{", "vehicleTap:", "function", "(event)", "{", "let", "val", "=", "event.target.dataset.value;", "switch", "(val){", "case", "'delete':", "this.triggerEvent('delete');", "this.triggerEvent('inputchange');", "break;", "case", "'ok':", "this.triggerEvent('ok');", "break;", "default:", "this.triggerEvent('inputchange',", "val);", "}", "},", "}});wxss文件:host", "{", "width:", "100%;}.vehicle-panel", "{", "width:", "100%;", "position:", "fixed;", "bottom:", "0;", "display:flex;", "flex-direction:column;", "justify-content:center;", "z-index:", "1000;}.vehicle-panel-row", "{", "display:", "flex;", "justify-content:", "space-between;", "align-items:", "center;}.vehicle-panel-row-last{", "display:", "flex;", "justify-content:", "space-between;", "align-items:", "center;}.vehicle-panel-row-button", "{", "background-color:", "#fff;", "margin:", "5rpx;", "padding:", "5rpx;", "width:", "80rpx;", "height:", "80rpx;", "text-align:", "center;", "line-height:", "80rpx;", "border-radius:", "10rpx;}.vehicle-panel-row-button-number", "{", "background-color:", "#eee;}.vehicle-panel-row-button-last", "{", "width:", "90rpx;", "height:", "90rpx;", "line-height:", "90rpx;}.vehicle-hover", "{", "background-color:", "#ccc;}.vehicle-panel-row-button-img", "{", "display:", "flex;", "justify-content:", "center;", "align-items:", "center;}.vehicle-en-button-delete", "{", "width:", "55rpx;", "height:", "85rpx;}.vehicle-panel-ok", "{", "background-color:", "#0F4BA1;", "color:", "#fff;", "width:", "150rpx;", "height:", "80rpx;}使用方式示例<v-panel", "is-show=\"{{isShow}}\"", "bindok=\"inputOk\"", "binddelete=\"inputdelete\"", "bindinputchange=\"inputChange\"", "key-board-type=\"{{keyBoardType}}\"", "backgroundColor=\"white\"", "/>", "属性属性名称类型默认值说明isShow布尔(boolean)false控制键盘是否显示,true显示，false不显示buttonBorder字符串(String)\"1px", "solid", "#ccc\"控制键盘按钮边框，同css", "border属性backgroundColor字符串(String)#fff控制键盘背景色,同csskeyBoardType数字(Number)1控制键盘显示类型,1为省份简写,2为英文简写事件事件名称触发情况返回值delete删除按钮按下的时候触发微信事件ok确定按钮按下时触发微信事件inputchange输入按钮按下或者删除按钮按下时触发输入的值完毕!以上代码仅供大家学习交流相关推荐：在微信小程序中使用“随机键盘”"]}
{"author": "Rolan", "title": "多人对战游戏开发实例之《组队小鸡射击》（附源码） ", "content": ["前言：该游戏项目主要是基于前端引擎Cocos", "Creator开发，涉及后端联网的部分，则通过接入Matchvs", "SDK完成快速开发工作。准备工作Matchvs", "JavaScript", "SDK", "下载地址Matchvs", "JavaScript", "的Cocos", "Creator", "插件使用手册Cocos", "Creator", "下载地址《组队小鸡射击》玩法简介：双方通过控制各自小鸡，通过不断点击屏幕进行空中飞行射击，被击中者将消耗以爱心为单位的生命值，游戏支持四人同时实时对战。点击并拖拽以移动​实现步骤游戏实现部分可拆分为三个步骤来实现：用户登录、随机匹配和创建房间及同屏游戏。用户登录​使用Cocos", "Creator(以下简称CC)创建游戏登录场景​", "使用CC", "拖动控件,", "还原设计稿", ",", "依托CC的良好的工作流,使得这部分的工作可以由游戏策划或者UI设计者来完成,程序开发者只需要在场景中挂载相应的游戏逻辑脚本.", "举个例子,在登录按钮挂在一个uiLogin.js的脚本完成用户登录功能.uilogin.fire新建js脚本文件选中场景任一控件添加组件,选中刚新建的脚本,在脚本的onLoad函数中给按钮添加点击监听,触发登录操作uiLogin.js​onLoad()", "{this.nodeDict[\"start\"].on(\"click\",", "this.startGame,", "this);},startGame()", "{Game.GameManager.matchVsInit();}实现this.startGame函数.", "登录之前需要初始化Matchvs", "SDK:uiLogin.jsuiLogin.jsvar", "uiPanel", "=", "require(\"uiPanel\");cc.Class({extends:", "uiPanel,", "properties:", "{},​onLoad()", "{", "this._super();", "this.nodeDict[\"start\"].on(\"click\",", "this.startGame,", "this);", "},​startGame()", "{", "Game.GameManager.matchVsInit();", "}});​​Game.GameManager.jsmatchVsInit:", "function()", "{mvs.response.initResponse", "=", "this.initResponse.bind(this);", "mvs.response.errorResponse", "=", "this.errorResponse.bind(this);", "//", "用户登录之后的回调", "mvs.response.loginResponse", "=", "this.loginResponse.bind(this);", "​var", "result", "=", "mvs.engine.init(mvs.response,", "GLB.channel,", "GLB.platform,", "GLB.gameId);", "if", "(result", "!==", "0)", "{", "console.log('初始化失败,错误码:'", "+", "result);", "}}初始化需要的几个参数在Matchvs官网注册即可得到,注册地址", "http://www.matchvs.comchannel:", "'MatchVS',", "platform:", "'alpha',", "gameId:", "201330,", "gameVersion:", "1,", "appKey:", "'7c7b185482d8444bb98bc93c7a65daaa',", "secret:", "'f469fb05eee9488bb32adfd85e4ca370',注册成功后,登录Matchvs游戏云,返回UserID,登录成功.gameManager.js​registerUserResponse:", "function(userInfo)", "{var", "deviceId", "=", "'abcdef';", "var", "gatewayId", "=", "0;", "GLB.userInfo", "=", "userInfo;​console.log('开始登录,用户Id:'", "+", "userInfo.id)​var", "result", "=", "mvs.engine.login(", "userInfo.id,", "userInfo.token,", "GLB.gameId,", "GLB.gameVersion,", "GLB.appKey,", "GLB.secret,", "deviceId,", "gatewayId", ");", "if", "(result", "!==", "0)", "{", "console.log('登录失败,错误码:'", "+", "result);", "}},​loginResponse:", "function(info)", "{if", "(info.status", "!==", "200)", "{", "console.log('登录失败,异步回调错误码:'", "+", "info.status);", "}", "else", "{", "console.log('登录成功');", "this.lobbyShow();", "}},随机匹配和创建房间使用CC创建大厅场景(uiLobbyPanel.fire)给用户选择匹配方式,创建匹配场景(uiMatching1v1.fire)", "给用户反馈比配进度和登录功能的实现步骤类似:写一个", "uiMatching1v1.js脚本挂在到场景中的控件上.uiMatching1v1.jsjoinRandomRoom:", "function()", "{var", "result", "=", "mvs.engine.joinRandomRoom(GLB.MAX_PLAYER_COUNT,", "'');", "if", "(result", "!==", "0)", "{", "console.log('进入房间失败,错误码:'", "+", "result);", "}},通过监听joinRoomResponse和joinRoomNotify匹配结果gameManager.jsjoinRoomResponse:", "function(status,", "roomUserInfoList,", "roomInfo)", "{if", "(status", "!==", "200)", "{", "console.log(\"失败", "joinRoomResponse:\"", "+", "status);", "return;", "}", "var", "data", "=", "{", "status:", "status,", "roomUserInfoList:", "roomUserInfoList,", "roomInfo:", "roomInfo", "}", "//", "把事件发给关心这个事件的节点脚本", "clientEvent.dispatch(clientEvent.eventType.joinRoomResponse,", "data);},​joinRoomNotify:", "function(roomUserInfo)", "{var", "data", "=", "{", "roomUserInfo:", "roomUserInfo", "}", "clientEvent.dispatch(clientEvent.eventType.joinRoomNotify,", "data);},同屏游戏", ",", "实现游戏同步还是按照上面的套路,新建场景(uiGamePanel.fire),在playerManager.js中,加载了player.js.在player.js中,攻击的动作使用Matchvs", "的", "sendEventEx发出,player.jshurt:", "function(murderId)", "{var", "msg", "=", "{", "action:", "GLB.PLAYER_HURT_EVENT,", "playerId:", "this.userId,", "murderId:", "murderId", "};", "Game.GameManager.sendEventEx(msg);}另一方的客户端收到后处理事情;gameManager.js​//", "玩家行为通知--sendEventNotify:", "function(info)", "{if", "(info.cpProto.indexOf(GLB.PLAYER_HURT_EVENT)", ">=", "0)", "{", "if", "(Game.GameManager.gameState", "!==", "GameState.Over)", "{", "player", "=", "Game.PlayerManager.getPlayerByUserId(cpProto.playerId);", "if", "(player)", "{", "player.hurtNotify(cpProto.murderId);", "}", "//", "检查回合结束--", "var", "loseCamp", "=", "Game.PlayerManager.getLoseCamp();", "if", "(loseCamp", "!=", "null)", "{", "Game.GameManager.gameState", "=", "GameState.Over", "if", "(GLB.isRoomOwner)", "{", "this.sendRoundOverMsg(loseCamp);", "}", "}", "}", "}}​开发完成后，", "再通过CC的微信小游戏一键发布功能上线微信即可。"]}
{"author": "Rolan", "title": "微信小程序调起键盘性能优化 ", "content": ["在小程序中，我们经常有调起键盘的操作场景，但是在不同的场景下解决方案不尽相同，还是需要具体问题具体分析。需求分析最近在项目中有一个需求，是从列表页点击评论按钮进入详情页时，在加载完页面后自动调起键盘进入评论状态。从需求来看，我们应该在onReady函数中调起键盘，因为onReady函数是在页面初次渲染完成时被调用。但是在实践中我们发现，对于一些配置不好的手机，其加载页面速度较慢，在onReady函数调用时页面并没有渲染完毕，就会导致placeholder和input组件位置错乱的现象。其本质原因是，onReady生命周期函数并不能在调用时承若已经将页面渲染完成了。（尽管文档中描述是已经完成了。）之前的操作是在onReady生命周期函数中调起键盘。this.setData({", "focus:", "true", "})", "复制代码发现这个问题后做了相应的延迟处理setTimeout(()", "=>", "{", "this.setData({", "focus:", "true", "})", "},", "300)", "复制代码但这是治标不治本的方法，手机性能好的用户会无谓的等待300毫秒，而手机性能很差的用户等待300毫秒也不一定就能解决这个问题。解决思路那么既然小程序并没有提供给我们一个理想的渲染结束后的回调函数，那么我们就换个思路：", "使用短轮询来处理，当页面渲染完成后才调起键盘的操作。既然要使用短轮询，那么我们去轮询什么呢？什么标志代表着页面渲染完成了呢？在这里，我是使用", "wx.createSelectorQuery()", "方法，它会返回一个SelectorQuery对象实例，在这个实例上调用select方法选择我想要去轮询的节点，在回调函数中判断参数是否为", "null", "。如果返回了监控的节点信息，那么说明已经渲染完成。这时就可以进行键盘调起操作了。let", "timer", "=", "setInterval(()", "=>", "{", "wx.createSelectorQuery().select('#comment-section').boundingClientRect(rect", "=>", "{", "if", "(rect", "!==", "null", "&&", "timer", "!==", "null)", "{", "clearInterval(timer)", "timer", "=", "null", "this.setData({", "focus:", "true", "})", "}", "}).exec()", "},", "50)", "复制代码在此之上，如果我们只粗暴的让", "focus", "为", "true", "并不是个明智的做法。在调起键盘时默认页面会上推，如果在评论很少的情况下这样的体验并不好。所以需要判断一个高度，超过这个值就上推，没超过就不上推。这个值视实际情况而定。", "上推的操作是由input组件的", "adjust-position", "属性决定，为true则上推，否则则不上推。这时回调返回的参数中的节点信息就可以派上用场了。//", "在this.setData({", "focus:", "true", "})前对节点高度进行判断", "if", "(rect.height", "<", "500)", "this.setData({", "push:", "false", "})", "else", "this.setData({", "push:", "true", "})", "复制代码onBlur函数问题在实际的操作中，我们发现在键盘被调起后会有概又自动收回。经过排查发现时onBlur函数的问题，在onBlur函数中，我们手动的设置", "focus", "为", "false", "，但其实并不需要这一步操作，反而带来了副作用。在我们去除了这部分代码后，键盘自动收起的问题得到了解决。封装起来虽然我们完成了这次任务的需求，但是显而易见的，这样的任务在未来肯定还会再次出现。所以机智的我们应该赶快把整套流程封装起来，以便下次直接调用。那么这时我们使用的方式就是这样的：const", "Util", "=", "require(\"xxx\")", "//", "引入封装的库", "/**", "*", "生命周期函数--监听页面初次渲染完成", "*/", "onReady:", "function", "()", "{", "Util.onTotalReady('#comment-section',", "50,", "rect", "=>", "{", "if", "(rect.bottom", "<", "500)", "this.setData({", "push:", "false", "})", "else", "this.setData({", "push:", "true", "}}", "this.setData({", "focus:", "true", "})", "})", "}", "复制代码小结在解决键盘调起的这个过程中我们可以看出微信小程序开发流程的简陋，这个问题的出现本质上是小程序提供给我们的生命周期函数的不够准确。否则在页面渲染完成的情况下我怎么会拿不到节点信息呢？像react中的componentWillMount生命周期函数中就不会出现这样的问题，所以希望小程序能再变强大一些，也让我们少写一点这种hack代码。"]}
{"author": "Rolan", "title": "weapp-cookie：一行代码让微信小程序支持 cookie ", "content": ["一行代码让微信小程序支持", "cookie，传送门：", "githubIntro微信原生的", "wx.request", "网络请求接口并不支持传统的", "Cookie，但有时候我们现有的后端接口确于依赖", "Cookie（比如服务器用户登录态），这个库可用一行代码为你的小程序实现", "Cookie", "机制，以保证基于", "cookie", "的服务会话不会失效，与", "web", "端共用会话机制Installnpm", "install", "weapp-cookie", "--save", "#", "将", "npm", "包复制到", "vendor", "文件夹，避免小程序可能不能找到文件（tips：使用", "wepy/mpvue", "等框架无需此步）", "cp", "-rf", "./node_modules/", "./vendor/", "复制代码Usage在小程序根目录的", "app.js", "一行代码引入即可//", "app.js", "import", "'./vendor/weapp-cookie/index'", "//", "tips:", "使用", "wepy/mpvue", "可以直接在入口", "js", "引入", "weapp-cookie", "模块", "//", "import", "'weapp-cookie'", "App({", "onLaunch:", "function", "()", "{", "}", "//", "...", "})", "复制代码原来的", "wx.request", "调用方式保持不变，引入后", "weapp-cookie", "会在底层自动代理", "wx.request", "的接口访问，以支持", "cookie", "存储和发送//", "pages/home/index.js", "Page({", "onLoad:", "function", "()", "{", "wx.request({", "url:", "'https://example.com/login',", "data:", "{", "username:", "'admin',", "password:", "'123456'", "},", "success:", "function", "(res)", "{", "/*", "*", "接口调用成功后", "weapp-cookie", "会自动保存后端发送的所有Cookie（比如：SessionID）", "*", "并在后续的所有请求中带上，以保证基于", "cookie", "的服务器会话机制不会失效，", "*", "实现与", "web", "端共用会话机制（无需再手动维护", "3rd_session_key）", "*/", "}", "})", "}", "})", "复制代码如果对你有用，欢迎", "star", "^_^"]}
{"author": "Rolan", "title": "小程序开发实用技巧——扩展 Page 页面对象 ", "content": ["小程序是通过调用", "Page", "函数来注册一个页面的：//index.js", "Page({", "data:", "{", "text:", "\"This", "is", "page", "data.\"", "},", "onLoad:", "function(options)", "{", "//", "Do", "some", "initialize", "when", "page", "load.", "},", "//", "Event", "handler.", "viewTap:", "function()", "{", "this.setData({", "text:", "'Set", "some", "data", "for", "updating", "view.'", "},", "function()", "{", "//", "this", "is", "setData", "callback", "})", "}", "})", "复制代码这里", "Page", "的作用相当于构造函数，", "Page", "会初始化页面对象（实例），然后将配置参数中的属性", "merge", "到页面对象上。假设你封装了个", "http", "模块负责发出请求，你想在页面对象中直接通过", "this.http", "引用这个模块，就需要扩展页面对象。要扩展一个对象，在", "JavaScript", "中的常见做法是扩展构造函数的", "prototype", "属性，这是", "Vue", "很多插件的实现：import", "axios", "from", "'axios'", "Vue.prototype.axios", "=", "axios", "//", "在", "vue", "组件中", "this.axios.get(api).then(callback)", "复制代码很不幸，在小程序中这个办法无效。", "Page", "并不是普通的构造函数，底层还做了很多其他事情，没办法直接通过", "Page.prototype", "扩展页面对象。我们可以转变思路，扩展传进", "Page", "的配置对象。既然始终要通过调用", "Page", "注册页面，可以定义一个函数，这个函数会将收到的配置对象参数进行处理，然后再传给", "Page", "。//", "wxPage.js", "import", "http", "from", "'../utils/http'", "const", "wxPage", "=", "function(config)", "{", "config.http", "=", "http", "return", "Page(config)", "}", "export", "default", "wxPage", "复制代码注册页面的时候改用这个", "wxPage", "：import", "Page", "from", "'./wxPage'", "Page({", "data:", "{", "text:", "\"This", "is", "page", "data.\"", "},", "onLoad:", "function(options)", "{", "console.log(this.http)", "//", "打印", "http", "模块变量", "this.http.get(api).then(callback)", "//", "直接调用", "http", "的方法", "},", "})", "复制代码直接修改", "Page", "函数为了增强页面对象，每个需要的页面都得引入", "wxPage", "是一件不太省心的事；更多时候我们是在维护一个老项目，需要扩展每个原有的页面对象，这时可以直接修改", "Page", "：const", "originalPage", "=", "Page", "//保存原来的Page", "Page", "=", "function(config)", "{", "//", "覆盖Page变量", "config.http", "=", "http", "return", "originalPage(config)", "}", "复制代码一般来说，修改", "Page", "的时机是在", "App", "onLoad", "的时候。这样原有的页面不用修改，直接就能通过", "this.http", "拿到", "http", "。通过扩展", "Page", "页面对象实现常见需求1.", "给生命周期方法增加通用逻辑有时我们希望在页面注册的", "onLoad", "阶段执行一些通用的逻辑，例如埋点，打", "log", "等，这时可以改写配置对象中的", "onLoad", "方法：const", "originalPage", "=", "Page", "Page", "=", "function(config)", "{", "const", "{", "onLoad", "}", "=", "config", "config.onLoad", "=", "function(onLoadOptions)", "{", "//", "打", "log、埋点……", "console.log('每个页面都会打出这个log')", "if", "(typeof", "onLoad", "===", "'function')", "{", "onLoad.call(this,", "onLoadOptions)", "}", "}", "return", "originalPage(config)", "}", "复制代码2.", "获取上一页页面对象小程序中的页面跳转会形成一个页面栈，栈中存放着每个页面对象，可以通过getCurrentPages", "方法获得这个页面栈。可以在页面", "onLoad", "的时候获取这个页面栈，然后取出倒数第二个对象，就是当前页上一页的页面对象：//", "接上...", "const", "{", "onLoad", "}", "=", "config", "config.onLoad", "=", "function(onLoadOptions)", "{", "const", "pages", "=", "getCurrentPages()", "this.__previousPage", "=", "pages[pages.length", "-", "2]", "//", "将上一页的页面对象赋为this.__previousPage", "if", "(typeof", "onLoad", "===", "'function')", "{", "onLoad.call(this,", "onLoadOptions)", "}", "}", "return", "originalPage(config)", "复制代码这样在页面对象中可通过引用", "this.__previousPage", "获取上一页页面对象的data及所有方法，这样在一些只需要两个页面互动的情景下，当前页直接调用上一个页面对象的方法（相当于回调）后再返回，比通过全局状态管理上一页的数据要方便。3.", "跳转页面并传递数据到下一页这个不多说了，直接看代码吧：//", "接上", "config.navigateTo", "=", "function(url,", "params)", "{", "//", "实现一个navigateTo方法，参数包括跳转url和要传递的参数", "this.__params", "=", "params", "wx.navigateTo({", "url", "})", "}", "config.onLoad", "=", "function(onLoadOptions)", "{", "const", "pages", "=", "getCurrentPages()", "this.__previousPage", "=", "pages[pages.length", "-", "2]", "//", "将上一页的页面对象赋为this.__previousPage", "if", "(this.__previousPage)", "{", "onLoadOptions.params", "=", "this.__previousPage.__params", "//", "获取上一页面的__params赋给onLoad函数的options", "delete", "this.__previousPage.__params", "}", "if", "(typeof", "onLoad", "===", "'function')", "{", "onLoad.call(this,", "onLoadOptions)", "}", "}", "//", "A", "页面跳转", "B", "页面", "this.navigateTo('urlToB',", "{", "foo:", "'bar'", "})", "//", "B", "页面的", "onLoad", "Page({", "onLoad(options)", "{", "console.log(options.params)", "//", "{", "foo:", "'bar'", "}", "}", "})", "复制代码就写到这里吧，在使用原生方案开发的时候，这些技巧还是挺实用的。以后再写写怎样构建小程序，使小程序支持文件预编译、require", "npm", "包等。"]}
{"author": "Rolan", "title": "微信小程序适配 iPhone X 总结 ", "content": ["本文主要介绍我们的知识小集小程序在适配", "iPhone", "X", "屏幕时遇到的一些问题以及总结，希望对你的小程序开发能有所帮助。iPhone", "X", "屏幕数据在去年", "9", "月份", "iPhone", "X", "正式发布后，引发了一波", "iOS", "App", "适配", "iPhone", "X", "的热潮和技术文章，详情可以参考掘金技术社区的这个专题：", "《iPhone", "X", "适配实践》我们这里先简单总结一下", "iPhone", "X", "屏幕的基础数据，方便后续在小程序开发中进行适配。屏幕尺寸：5.8", "英寸（对角线）屏幕物理分辨率：1125px", "×", "2436px，458", "ppi实际开发适配尺寸：375pt", "×", "812pt，@3x此外，由于在", "iPhone", "X", "屏幕顶部状态栏区域有“齐刘海”，以及在屏幕底部增加了“操作条”，如下图所示，因此，我们在开发中需要注意", "安全区域", "的问题。根据苹果官方的文档，iPhone", "X", "顶部状态栏的适配安全区域的高度为", "44pt，底部操作条区域的高度为", "34pt。另外，在", "iPhone", "X", "中，一些系统", "Bar", "的默认高度相比于之前的设备也发生了变化，如下表所示。所以在", "iOS", "App", "开发中，如果我们使用系统默认的", "UINavigationController", "和", "UITabBarController", "时，则无需额外的适配工作，iOS", "系统会自动适配好相关", "Bar", "的安全区域问题。如果我们使用了自定义的导航栏和标签栏，则需要注意根据设备类型区分设置这些", "Bar", "的不同高度。小程序的尺寸单位为了解决不同屏幕尺寸的适配问题，小程序自己定了一个尺寸单位：rpx（responsive", "pixel），它可以根据屏幕宽度进行自适应。小程序中规定，", "所有设备的屏幕宽度都为", "750rpx", "，根据设备屏幕实际宽度的不同，1rpx", "所代表的实际像素值也不一样。根据", "微信开发文档", "，在", "4.7", "英寸的", "iPhone", "设备上（iPhone", "6/7/8），屏幕宽度为", "375px（此处应该理解为", "375", "point），共有", "750", "个物理像素，则", "750rpx", "=", "375px", "=", "750", "物理像素，1rpx", "=", "0.5px", "=", "1物理像素。小程序中如何判断设备为", "iPhone", "X上面我们简要介绍了", "iPhone", "X", "的屏幕数据和小程序中的尺寸单位作为铺垫，现在终于要切入正题了，要在小程序中适配", "iPhone", "X", "屏幕，首先我们需要知道如何判断设备类型。微信的小程序", "API", "中提供了一个", "wx.getSystemInfo(OBJECT)", "方法用于获取用户手机的系统信息和设备信息，包含如下数据：上述每个字段的含义详见", "文档", "，我们不再一一赘述。因此，我们可以根据该方法返回的手机型号字段", "model", "是否包含", "iPhone", "X", "字符串来判断设备是否为", "iPhone", "X，也可以根据", "screenHeight", "的高度是否等于", "812", "来判断。NOTE:这里有一个小坑需要注意，在微信开发者工具中的模拟器，如果选择为", "iPhone", "X，此时获取到的", "model", "值为", "iPhone", "X", "，导致我以为真机也是这个值，于是直接用", "if", "(model", "==", "'iPhone", "X')", "来判断，但其实真机下", "model", "的值为这种格式：", "iPhone", "X", "(GSM+CDMA)<iPhone10,3>", "，因此我们需要用字符串检索匹配进行判断。综上，我们可以在", "app.js", "的", "globalData", "中添加一个字段", "isIPX", "用于标识当前设备是否为", "iPhone", "X，然后在小程序启动时", "onLaunch", "中调用", "wx.getSystemInfo(OBJECT)", "方法并在其", "success回调中读取", "model", "字段进行分析，代码大致如下：App({", "//", "全局数据", "globalData:", "{", "//", "其他数据定义", "...", "isIPX:", "false,", "//", "当前设备是否为", "iPhone", "X", "},", "//", "小程序启动入口", "onLaunch:", "function", "(options)", "{", "//", "其他启动代码...", "//", "判断设备是否为", "iPhone", "X", "this.checkIsIPhoneX()", "},", "checkIsIPhoneX:", "function()", "{", "const", "self", "=", "this", "wx.getSystemInfo({", "success:", "function", "(res)", "{", "//", "根据", "model", "进行判断", "if", "(res.model.search('iPhone", "X')", "!=", "-1)", "{", "self.globalData.isIPX", "=", "true", "}", "//", "或者根据", "screenHeight", "进行判断", "//", "if", "(res.screenHeight", "==", "812)", "{", "//", "self.globalData.isIPX", "=", "true", "//", "}", "}", "})", "},", "}", "如果需要小程序启动时立即获取设备相关信息，也可以调", "wx.getSystemInfoSync()", "方法，它会同步获取数据并立即返回。页面适配实战在小程序页面开发中，涉及到需要适配", "iPhone", "X", "的地方主要有：导航栏（NavigationBar），标签栏（TabBar）以及页面底部的吸底按钮。导航栏和标签栏适配如果我们使用微信小程序官方组件进行开发，没有进行自定义，在", "app.json", "文件中设置", "tabBar", "页面，且", "window", "的", "navigationStyle", "值为", "default", "，那么我们无需在", "iPhone", "X", "中对导航栏和标签栏进行适配，微信会自动帮我们适配好，如下图为知识小集小程序的首页：但是我们如果是自定义导航栏（在", "app.json", "文件中设置", "window", "的", "navigationStyle", "为", "custom", "，此时只保留右上角胶囊状的按钮，需要开发者自己画导航栏样式）和标签栏，则我们需要在每个页面中判断设备类型，并针对", "iPhone", "X", "屏幕在安全区域内进行布局，并修改相关", "Bar", "的高度值（见上述表格）。以自定义导航栏适配为例，步骤如下：（1）在每个页面的", "page.js", "中先读取", "app.js", "中的", "isIPX", "值，如下：const", "app", "=", "getApp()", "Page({", "data:", "{", "//", "页面其他数据...", "isIPX:", "app.globalData.isIPX,", "},", "//", "其他代码", "}", "（2）然后在", "page.wxss", "样式文件中对某一个视图", "View", "分别为普通屏幕和", "iPhone", "X", "屏幕写两种样式，如下：.navi-bar-view", "{", "height:", "64px;", "/*", "其他样式值", "*/", "}", ".navi-bar-view-IPX", "{", "height:", "88px;", "/*", "其他样式值", "*/", "}", "（3）最后在", "page.wxml", "页面结构布局中根据", "isIPX", "的值给", "View", "设置不同的", "class", "样式，如下：<view", "class=\"{{isIPX", "?", "'navi-bar-view-IPX'", ":", "'navi-bar-view'}}\">", "</view>", "此外，对于自定义导航栏和标签栏，我建议还是要遵循", "iPhone", "UI", "的设计规范，样式可以参考苹果官方的渲染图：吸底按钮适配在小程序页面中，吸底按钮是很常见的一种设计，我们一般会把一些重要的按钮放在页面底部悬浮不动，例如我们知识小集小程序的“小集详情页”底部的“收藏”和“转发”按钮：在", "iPhone", "X", "中我们需要把吸底按钮往上偏移", "34", "像素，可通过在", "CSS", "样式中设置", "padding-bottom", "为", "34px", "实现，参考代码如下：.feed-bottom-view", "{", "width:", "100%;", "height:", "48px;", "/*", "吸底按钮的高度", "*/", "bottom:", "0;", "opacity:", "0.95;", "position:", "fixed;", "border-top-style:", "solid;", "border-top-width:", "0.5px;", "/*", "分割线的高度", "*/", "border-color:", "lightgrey;", "background-color:", "#F8F8F8;", "}", ".feed-bottom-view-IPX", "{", "/*", "iPhone", "X", "内容往上偏移", "34px", "*/", "padding-bottom:", "34px;", "}", "<view", "class=\"{{isIPX", "?", "'feed-bottom-view", "feed-bottom-view-IPX'", ":", "'feed-bottom-view'}}\">", "<!--", "底部吸底按区域", "-->", "</view>", "备注：如前面所述，对于不同设备宽度，1rpx", "所代表的实际像素值也不一样，而在不同尺寸的", "iPhone", "设备（3.5/4.0/4.7/5.5", "英寸）中，虽然它们的宽度不同，但其导航栏+状态栏的高度都为", "64pt（iPhone", "X", "为", "88pt），标签栏", "TabBar", "的高度都为", "49pt（iPhone", "X", "为", "83pt）。所以在小程序开发中，当我们需要自定义导航栏、标签栏，或者适配", "iPhone", "X", "顶部和底部安全区域时，我建议此处的单位直接使用", "px", "（在小程序中对应", "iOS", "开发中的点", "pt", "）而不使用", "rpx", "（当然页面的其他元素的尺寸描述还是推荐使用", "rpx", "），以确保最终渲染显示的高度与", "iOS", "系统默认的一致。总结本文简要介绍了在小程序开发中如何适配", "iPhone", "X", "屏幕，更多细节请查阅我们在", "GitHub", "上开源的知识小集小程序的代码：", "awesome-tips-wx-app"]}
{"author": "Rolan", "title": "小程序自定义组件-可清除的input组件 ", "content": ["最近正在做的一个小程序项目中需要用到一个可清除的输入框控件，为了在项目中使用方便以及方便其他项目直接使用，便封装了一个可清除的input自定义组件。组件需要达到的需求是：输入框内没有内容时，删除按钮隐藏；当输入框内有内容时，删除按钮显示，点击删除按钮则清空输入框内所有内容。并且还可以设置输入框整体样式以及输入框左侧图标。明确了需求之后，就可以开始着手实现了。首先，在目标目录下新建一个自定义组件建好之后，我们需要来设计布局。根据需求来看，我们只需要三个组件：两个image和一个input。左边一个image提示图标，然后一个input输入框，最后一个image删除按钮。我们要把尽可能多的数据设置成可以修改的绑定数据，提高自定义组件的可扩展性。最终确定的wxml布局文件如下：<view", "class='input-class'>", "<image", "src='{{inputIcon}}'", "mode=\"scaleToFill\"", "class='icon-class'></image>", "<input", "placeholder='{{inputHint}}'", "bindconfirm='{{confirmTap}}'", "style='flex:1;width:100%;padding-left:12rpx;'", "bindinput='inputListener'", "bindconfirm='inputConfirm'", "value='{{inputValue}}'", "type='{{inputType}}'", "password='{{isPassword}}'", "confirm-type='{{confirmType}}'></input>", "<image", "class=\"{{isClearShow?'clearImgShow':'clearImgHide'}}\"", "src='clear.png'", "bindtap='clearTap'", "mode='widthFix'></image>", "</view>然后，我们就要来设置组件的一些属性和监听方法了。小程序的组件属性列表是定义在.js文件的properties里的。把需要暴露出去并可以修改的属性都写在这里面。其语法示例如下：properties:", "{", "myProperty:", "{", "//", "属性名", "type:", "String,", "//", "类型（必填），目前接受的类型包括：String,", "Number,", "Boolean,", "Object,", "Array,", "null（表示任意类型）", "value:", "'',", "//", "属性初始值（可选），如果未指定则会根据类型选择一个", "observer:", "function(newVal,", "oldVal,", "changedPath)", "{", "//", "属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串,", "如：'_propertyChange'", "//", "通常", "newVal", "就是新设置的数据，", "oldVal", "是旧数据", "}", "},", "myProperty2:", "String", "//", "简化的定义方式", "}我的属性列表如下：", "/**", "*", "组件的属性列表", "*/", "properties:", "{", "inputHint:", "{", "type:", "String,", "value:", "'搜索'", "},", "inputIcon:", "{", "type:", "String,", "value:", "'search.png'", "},", "inputType:", "{", "type:", "String,", "value:", "'text'", "},", "isPassword:", "{", "type:", "Boolean,", "value:", "false", "},", "confirmType:", "{", "type:", "String,", "value:", "\"done\"", "}", "}完成了属性列表的编写之后，接下来我们需要为自定义组件添加监听事件。事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。监听以及触发事件的语法是这样的：//触发事件", "//自定义组件触发事件时，需要使用", "triggerEvent", "方法，指定事件名、detail对象和事件选项", "methods:", "{", "onTap:", "function(){", "var", "myEventDetail", "=", "{}", "//", "detail对象，提供给事件监听函数", "var", "myEventOption", "=", "{}", "//", "触发事件的选项", "this.triggerEvent('myevent',", "myEventDetail,", "myEventOption)", "}", "}", "//监听事件", "<!--", "当自定义组件触发“myevent”事件时，调用“onMyEvent”方法", "-->", "<component-tag-name", "bindmyevent=\"onMyEvent\"", "/>", "<!--", "或者可以写成", "-->", "<component-tag-name", "bind:myevent=\"onMyEvent\"", "/>这里我们需要设置的触发事件有，输入框的输入事件以及输入框的确认事件。通过", "triggerEvent", "方法指定事件名以及事件触发事件参数", "/**", "*", "组件的方法列表", "*/", "methods:", "{", "inputListener:", "function", "(e)", "{", "var", "value", "=", "e.detail.value;", "var", "cursor", "=", "e.detail.cursor;", "if", "(value", "===", "null", "||", "value", "===", "undefined", "||", "value.length", "===", "0)", "{", "this.setData({", "isClearShow:", "false", "});", "}", "else", "{", "this.setData({", "isClearShow:", "true", "});", "}", "var", "detail", "=", "{", "value:", "value,", "cursor:", "cursor", "};", "this.triggerEvent('inputListener',", "detail);", "},", "inputConfirm:", "function", "(e)", "{", "var", "value", "=", "e.detail.value;", "var", "detail", "=", "{", "value:", "value", "}", "this.triggerEvent('inputConfirm',", "detail);", "},", "clearTap:", "function", "()", "{", "this.setData({", "isClearShow:", "false,", "inputValue:", "''", "});", "}", "}以上就已经完成了这个可清除input组件的自定义开发了。现在来看怎么使用这个组件。首先在需要使用此组件的页面.json文件中设置usingComponents属性来引入这个自定义组件", "\"usingComponents\":", "{", "//这里是设置的组价标签名称以及组件地址", "\"clearInput\":", "\"../../components/clearInput/clearInput\"", "}然后，我们就可以在页面中引用这个自定义组件了，引用的方式非常简单，通过我们在上一步设置的标签名称就可以引用了。<clearInput", "inputHint='搜索订单'", "icon-class='common_search_img'", "input-class='common_search_input'", "confirmType='search'", "bind:inputListener='inputListener'", "bind:inputConfirm='searchEvent'", "/>最终实现的效果图如下：项目GitHub地址：https://github.com/RaoMeng/TemplateOfHotel"]}
{"author": "Rolan", "title": "微信小程序 - 前三排名实现 ", "content": ["实现原理：利用背景图片以及nth-child实现", "作者：Sunsin原文：http://www.cnblogs.com/cisum/p/9370248.html"]}
{"author": "Rolan", "title": "微信小程序隐藏客服按钮，用图片替代&增加提示卡片可随时关闭。 ... ", "content": ["如图，本次案例要做的是右下角的客服按钮和蓝色渐变的提示卡片，可随时关闭的。微信官方给了客服按钮标签<contact-button", "type=\"default-dark\"", "size=\"100\"></contact-button>这个标签的样式不可修改，如果我们要换自己想改的图片，需要怎么做呢？就像我图片上的样式。我这个客服控件是放在一个正圆的view里的居中位置，所以，我这里先通过position定位到居中位置，把size放到最大。然后把透明度设置为0即可，然后给正圆这个view设置一图片背景，图片就是你想要显示的icon提示卡片提示卡片是一个view，view里面有一个×用来绑定隐藏事件的，bindtap=\"onChangeShowState\"就是用来隐藏这个view的index.wxml<!--", "提示卡片", "-->", "<view", "class=\"bright789_view_hide{{showView?'bright789_view_show':''}}\">", "<view", "class=\"bright789-text\">", "<view", "bindtap=\"onChangeShowState\"", "class=\"close\">×</view>", "<view", "class=\"text\">有疑问可以点这里咨询哦</view>", "</view>", "</view>", "<!--", "悬浮按钮", "-->", "<view", "class=\"zixun\"><contact-button", "type=\"default-dark\"", "size=\"100\"", "class=\"kf\"></contact-button></view>index.wxss.zixun{", "width:", "55px;", "height:", "55px;", "background:", "url(http://wxpad.cn/yunpan/cdn/imgsrc/1530949769.png)no-repeat;", "position:", "fixed;", "bottom:", "35px;", "right:", "35px;", "border-radius:", "50%;", "box-shadow:", "0", "0", "5px", "#ddd;", "text-align:", "center;", "font-size:", "14px;", "color:", "#333;", "}", ".zixun", ".kf{", "position:", "relative;", "top:", "0px;", "left:", "0px;", "margin:15px", "auto;", "opacity:", "0;", "}", ".bright789-text{", "position:", "fixed;", "bottom:", "100px;", "right:", "65px;", "width:", "200px;", "height:", "45px;", "background-image:", "linear-gradient(to", "left,", "#4481eb", "0%,", "#04befe", "100%);", "border-bottom-left-radius:", "50px;", "border-top-left-radius:", "50px;", "border-top-right-radius:", "50px;", "z-index:", "99999999;", "box-shadow:", "0", "0", "10px", "#eee;", "line-height:", "40px;", "text-indent:", "15px;", "}", ".bright789-text", ".close{", "font-size:", "1.5em;", "color:", "#fff;", "}", ".bright789-text", ".text{", "font-size:", "13px;", "color:", "#fff;", "margin-top:", "-38px;", "margin-left:", "20px;", "}", ".bright789_view_hide{", "display:", "none;", "}index.js//index.js", "//获取应用实例", "const", "app", "=", "getApp()", "Page({", "data:", "{", "showView:", "true", "},", "onLoad:", "function", "(options)", "{", "//", "生命周期函数--监听页面加载", "showView:", "(options.showView", "==", "\"true\"", "?", "true", ":", "false)", "},", "onChangeShowState:", "function", "()", "{", "var", "that", "=", "this;", "that.setData({", "showView:", "(!that.data.showView)", "})", "}", "})OK，制作完成！作者：TANKING"]}
{"author": "Rolan", "title": "微信小程序腾讯视频插件的使用 ", "content": ["在开发一个小程序项目时，需要在页面中观看视频，就需要使用到微信小程序的腾讯视频插件，这样就可以在页面中引用腾讯视频，而无需使用自己的服务器进行视频的播放，节约了很大的服务器开支。但是微信小程序插件的文档写的很不清楚，因此将我的解决方法写在这里。一、在小程序中引入插件。进入微信公众平台，在设置中找到第三方服务，在插件管理中添加插件。搜索到腾讯视频，点击添加，同时打开腾讯视频的详情，在里面找到该插件的appid与版本号。接着是代码部分，在app.json中添加", "\"plugins\":", "{", "\"tencentVideo\":", "{", "\"version\":", "\"1.1.1\",", "\"provider\":", "\"wxa75efa648b60994b\"", "}其中version是版本号，provider是appid。二、在需要使用的页面中引用该插件的组件官方文档并没有关于该方法的具体说明，所以会导致出现无法找到对应playerid的txv-video的问题打开想要使用插件页面的json文件，在里面添加", "\"usingComponents\":", "{", "\"txv-video\":", "\"plugin://tencentVideo/video\"", "}这就代表着可以在页面中使用txv-video组件啦三、在页面中使用组件进入wxml文件，在里面添加<txv-video", "vid=\"vid\"", "playerid=\"txv1\"></txv-video>这一步很简单，vid是腾讯视频的vid，playerid是该txv-video唯一识别码，这个组件不能通过css进行样式修改四、在js中进行引入如果你不想在js中对该插件进行控制的话，可以不引入。", "const", "TxvContext", "=", "requirePlugin(\"tencentVideo\");", "let", "txvContext", "=", "TxvContext.getTxvContext('txv1');", "txvContext.play();", "//播放这就是我成功引用腾讯视频插件的全部过程了，希望能够帮助到一样使用这个插件遇到问题的人。"]}
{"author": "Rolan", "title": "微信小程序 canvas 绘图问题总结 ", "content": ["业务中碰到微信小程序需要生成海报进行朋友圈分享，这个是非常常见的功能，没想到实际操作的时候花了整整一天一夜才搞好，微信的", "canvas", "绘图实在是太难用了，官方快点优化一下吧。", "业务非常简单，只需要将用到的图片，文案素材拼装到一张图片，保存到本地就可以了。", "首先创建画布，将一张网上的图片画到画布上。", "const", "ctx", "=", "wx.createCanvasContext('shareCanvas');", "ctx.drawImage(\"https://img3.doubanio.com/view/photo/l/public/p2327709524.jpg\",", "0,", "0,", "300,", "400);", "ctx.draw();", "复制代码网络图片", "这时候出现一个问题：在模拟器上没有报错，可是真机测试却什么也没画出来。网上搜索一阵发现微信小程序的", "canvas.drawImage", "是不支持网络图片的，只支持本地图片。所以，任何的网络图片都需要先缓存到本地，再通过", "drawImage", "调用存储的本地资源进行绘制，缓存可以通过", "wx.getImageInfo", "和", "wx.downloadFile", "实现，这次选用了", "wx.getImageInfo,", "wx.downloadFile", "没有试过，不知道可不可以。", "wx.getImageInfo({", "src:", "'https://img3.doubanio.com/view/photo/l/public/p2327709524.jpg',", "success:", "function", "(res)", "{", "console.log(res.width)", "console.log(res.path)", "}", "})", "复制代码这个方法可以拿到存储的本地图片地址，长宽以及一些简单的图形变化，将本地缓存的图片地址保存到全局变量或者缓存供", "wx.drawImage", "调用。", "还有一点需要注意的是", "draw", "方法是异步的，如果图片还没加载成功，有可能画出来的是空的，所以", "draw", "方法通常都会带有定时器这样的回调。", "ctx.draw(true,setTimeout(function(){", "wx.canvasToTempFilePath({", "canvasId:", "'shareCanvas',", "success:", "function(res){", "that.data.tmpPath", "=", "res.tempFilePath", "},", "})", "},1000));", "复制代码图片保存的授权问题", "绘图后通过", "1", "秒的延时将画好的新图片保存到本地，然后通过", "wx.saveImageToPhotosAlbum()", "保存到手机相册。这一步存在授权问题，需要考虑拒绝授权后的兼容性，也就是如果用户拒接授权以后怎么办？常见的做法是先通过", "wx.getSetting()", "获取用户的权限设置，如果用户拒绝了访问相册的权限，可以跳转到授权设置页面要求用户更改授权信息。", "小程序的授权设置", "api", "已经弃用了，现在只能通过组件形式，将", "button", "的", "open-type", "属性设置成", "openSetting，自动跳转到设置页面，总体来说没有之前方便了。如果页面本来已经有", "button可以先将", "open-type", "属性设成", "null，当遇到需要跳转的逻辑再通过", "setData", "设置，这样处理非常复杂，很容易出错，但是可以节省页面或者跳转；另一种处理方式是，当没有授权时先跳转到说明页面，说明需要授权的信息，在这个页面上添加一个", "open-type", "的button，点击以后跳转到设置页面，这次我们采用的是第一种方法：", "文字编辑换行", "下一步是文字编辑的问题，微信画文字是不支持自动换行的，所以只能手动计算每一行能够容纳的文字个数进行手动换行，比如一个文字加间距占", "10", "px，一行整体可以使用", "100", "px，那就是每行只能容纳", "10", "个字，第", "11", "个字另起一行开始画。", "将文字分割成", "10", "个字的数组：", "function", "canvasWorkBreak(maxWidth,", "fontSize,", "text)", "{", "const", "maxLength", "=", "maxWidth", "/", "fontSize", "const", "textLength", "=", "text.length", "let", "textRowArr", "=", "[]", "let", "tmp", "=", "0", "while", "(1)", "{", "textRowArr.push(text.substr(tmp,", "maxLength))", "tmp", "+=", "maxLength", "if", "(tmp", ">=", "textLength)", "{", "return", "textRowArr", "}", "}", "}", "复制代码将数组一行一行画到画布上：", "var", "height", "=", "200", "for", "(let", "item", "of", "['我的舍利佛','搜房法拉'])", "{", "if", "(item", "!==", "'a')", "{", "ctx.setFontSize(16);", "ctx.setFillStyle(\"#484a3d\");", "ctx.fillText(item,", "20,", "height);", "height", "+=", "50;", "}", "}", "复制代码多图绘制", "把每一种元素画完以后整个海报制作的流程就已经跑通了，但并不代表在实际业务中就可以使用了。首先面对的是海报生成的质量问题，假设我们的手机像素是", "320", "*", "400", "的，如果要将图片展示在手机上用于预览，只有两种选择：", "画一个分辨率小于手机分辨率的海报，让手机能完整的展示出来。但是这样的海报由于分辨率小，下载到手机相册分享用大屏手机观看的时候就非常影响体验了。这种做法的解决方案可以是画", "2", "张图，手机预览时隐藏大图，只显示小图；下载的时候将大图保存起来。", "画一张大图，直接通过", "previewImage", "进入手机预览模式，预览模式的图片可以直接保存到本地。这种方案的缺点在于预览模式无法设计", "UI，且下载的时候不能自定义文案，由于下载保存的入口很隐蔽，用户不一定能发现。", "图片太长怎么办？", "上面的图实际上是比较长的，你可以截取一部分显示出来，这样图片看起来就会更协调。在通过正常比例绘制完图片以后，可以通过填充矩形的方式覆盖一部分图片，然后在矩形上输入其他的内容，这样图片的一部分就被隐藏起来了。", "按钮置于最上层", "由于", "canvas", "是优先级最高的，总是会覆盖页面上的其他内容，所以「保存图片」的按钮可能会被覆盖掉而显示不出来，可以通过在", "button", "上套一层", "cover-view", "来解决。", "总结", "图片绘制本来应该是一个非常简单也非常成熟的技术，其他的框架都会有对应的组件来处理这些事情，可是微信小程序的", "canvas", "绘制可以用「非常难用」来形容，希望微信团队能尽快优化。", "你可以点击「阅读原文」获取源码。"]}
{"author": "Rolan", "title": "小程序分享，看这篇就够了 ", "content": ["官方文档最近在调研小程序的分享能力，本篇文档主要是调研小程序关于分享方面的玩法，目的是学习小程序在项目应用以及玩法链上的扩展。API层面onShareAppMessage小程序如果想对外分享，必须在", "page", "里面定义", "onShareAppMessage", "函数，来配置页面分享转发相关的信息。只有定义了此事件处理函数，右上角菜单才会显示", "“转发”", "按钮用户点击转发按钮的时候会调用此事件需要", "return", "一个", "Object，用于自定义转发内容一个页面可能会有多个分享，可以由插入的参数options来判断具体是由哪个位置进行分享，从而做不同的逻辑判断。return对象的返回函数：如果定义了该事件，又不想通过页面menu转发，可以通过", "hideShareMenu来隐藏掉注意事项：转发后不添加imageUrl的话，将截图作为转发的默认图片。from", "字段可以通过在转发成功后调取的", "success、complete", "来进行对", "menu", "和", "button", "的不同操作如果有携带", "shareTicket", "值，会在", "success", "回调产生，返回结果在", "shareTickets", "字段中，是一个数组，可以做一定处理wx.showShareMenu一般是用来配置相关的参数，常见的如", "withShareTicket", "，用它来获取群信息，群的相关标示。wx.showShareMenu({", "withShareTicket:", "true", "})", "复制代码wx.hideShareMenu隐藏menu级别的转发功能，但是button中还存在着转发。如果先设置", "showShareMenu", "，并且配置了", "withShareTicket，再用", "hideShareMenu", "方法，通过按钮转发，照样能获取", "shareTicket，如下：wx.showShareMenu({", "withShareTicket:", "true", "})", "wx.hideShareMenu({", "})", "复制代码wx.updateShareMenu更新shareMenu信息需要用update操作哦，这里需要注意下，一般都是会更新", "withShareTicket", "属性。wx.getShareInfo在拿到了shareTicket信息后，可以由此API获取转发详细信息wx.getShareInfo({", "shareTicket:", "res.shareTickets[0],", "success:", "...", "fail:", "...", "})", "复制代码相关回调的参数{", "errMsg:", "\"getShareInfo:ok\",", "iv:", "\"gRHeFU+Nhr36RmladCXnRQ==\",", "encryptedData:", "\"IQ/RwZLeQFUGuxv0bBfOrL/KLnXO+bxcyCBru5lB92FkHIg8ae…7TnHwU+rqgerFKvpvS5JbFyh+9liUqyb2bk6/LETYQ+h/FQ==\"", "}", "复制代码由iv和encryptedData进行解密，可以拿到openGId的值。为当前群对当前小程序的唯一值。额外还可以拿到群名称等更多的开放数据。button转发页面内需要转发时，需要给", "button", "组件设置", "open-type=\"share\"", "，并在触发的地方判断来源。获取分享链接流程在小程序中，获取openGId主要有两种途径，也一般围绕着两种途径做分享相关的开发：当用户打开", "withShareTicket", "的卡片时，可以在onLauch或者", "getShareInfo", "中获取加密信息，并且传给服务端获得openGId。当用户分享成功后，会在回调里收到一个", "shareTicket", "，然后通过", "getShareInfo", "来获得加密信息，获得openGId。拓展玩法APP分享到小程序传统APP要以小程序卡片的形式分享到微信，需要满足以下几个条件：要求发起分享的App与小程序属于同一微信开放平台帐号；支持分享小程序类型消息至好友会话，不支持“分享至朋友圈”", "“收藏”；微信客户端版本要求：6.5.6及以上微信客户端版本，若客户端版本低于6.5.6，小程序类型分享将自动转成网页类型分享。开发者必须填写网页链接字段，确保低版本客户端能正常打开网页链接；支持分享大图卡片样式，自定义图片建议长宽比是", "5:4。6.5.9及以上版本微信客户端小程序类型分享使用大图卡片样式。支持分享开发版/体验版小程序，为支持开发者调试，开发者工具包支持分享开发版/体验版小程序至微信，开发者可控制分享的小程序版本。具体流程图如下：朋友圈打开小程序在朋友圈中，发布图片附带小程序二维码，用户把图片分享到朋友圈中，看到的一方即可长恩识别在微信中打开小程序。", "通过这个玩法，实现了把小程序「分享」到朋友圈。至于图片的生成，canvas和服务器端生成都是比较成熟的解决方案。小程序支持打开APP这个玩法有一个前提：小程序卡片必须是由APP分享出去，才可以打开APP功能流程图如下：该途径可以作为小程序对于app的补充：", "产品可以通过", "App", "和小程序实现场景互补。比如用户", "Sherry", "将一个文档分享给用户", "Kevin，Kevin", "可以在小程序内直接查看。如果需要编辑，则可以直接打开", "App", "完成协同处理。这样一来，小程序不需要做的很重，只需满足基本功能，更多功能由", "App", "来补充。case举例：用户代打车，用户A想让用户B代打车，用户A将行程分享给用户B，用户B微信打开小程序之后，跳转美团打车APP完成相关复杂操作。小程序向公众号导流在小程序中，可以利用一些引导性文案指引用户点击进入客服会话页面，然后客服自动回复一条公众号图文消息，而图文消息则有引导关注公众号获取更多服务的指引文案。（", "经典用法，但是小心被封", "）"]}
{"author": "Rolan", "title": "我与小程序的故事以及小程序框架选型 ", "content": ["我的一些关于小程序的看法和社区框架选型比较，部分观点取之于社区。Vue重度使用者也许会在wepy和mpvue中徘徊，React和TypeScript重度使用者在现阶段当之无愧Taro首选。", "这是一篇我与小程序的故事，但小程序的过去却与我无关。", "曾经与她错失交臂，但愿一切还来得及。", "毕业后的两年内，一直在创业公司工作，但自己却错过了很多创业风口，如区块链和小程序，唯独跟风了机器学习，但这是一条漫长的路，需要潜心学术否则很难做出成绩，我曾在现公司AI", "Labs的某部门工作过一段时间，深知这一点。", "区块链和小程序在如今看来，无疑在过去的一年里都是程序员创业的风口，甚至可以说是风向标。", "我之前待过的一家创业公司，主要做股票行业投顾平台的业务，React", "Native承载了所有面向用户的APP产品需求，整个前后端技术团队最多的时候也只有11人，虽然是一家很小的创业公司，但两位创始人中，CEO曾是奇虎360", "Web产品及商业产品业务线副总经理，联合创始人是某大型券商高管，因此公司对产品的技术也曾多次摸索，数字货币涉及区块链，智能投顾涉及机器学习，量化投资涉及程序化交易，机会很多，但说实话要做好这些方向实在是太难，尤其16年国内股票市场一直处于熊市的低谷中徘徊。因思想，而光华；因变革，而机遇；因蜕变，而不凡。", "在16年小程序内测的时候就听说过小程序，但真正接触小程序是17年1月10日，某券商给我当时在的创业公司两个名额，我有幸受邀参加了在北京大学光华管理学院举办的”小程序，大变革-2017年小程序全国巡回沙龙“，小程序的正式发布仅仅是在一天之前的1月9日。", "小程序的诞生，就一路伴随着赞赏和争议不断，从发布上线时候不被大多数人看好，我便是其中之一，到如今的逐渐火热，甚至可以说是如日中天，在移动互联网创业领域一骑绝尘，17年后半年到如今的创业黑马。小程序刚出来的时候，我可能和大多数人的想法一样，中大型的互联网公司不可能去拥抱腾讯生态圈，受限于腾讯爸爸苛刻的游戏规则。", "然而在这一年里，小程序用时间与实践证明了自己的变革与价值，微信小程序的规则也在开发社区的影响下变得更加完善。", "对于第三方企业来讲，微信为自己带来了巨大的流量入口和低成本的拉新渠道，如滴滴、美团、京东等公司都推出了自己的小程序。像共享单车类的企业，微信是绝大多数用户的二维码扫码入口，小程序为其带来了巨大的流量入口，如摩拜单车、青桔单车、街兔电单车小程序。", "对于小程序开发者来说，小程序的开发生态不断地在完善，从最开始的原生框架，到类vue规范的wepy，再到近vue写法的mpvue，再到最近刚推出的遵循React规范的Taro。这期间，也曾有过类React的小程序框架Labrador，但小程序正式发布没多久就几乎停止维护了。", "真正让我感到惊喜的是Taro这个小程序框架，虽然推出的时间最短，但脚手架中自带TypeScript编译选项，这无疑是企业级小程序应用的首选框架，no，我认为，哪怕只是一个单人维护的小型应用，TypeScript也是必备的，可以让开发者避免一些低级错误的bug，以及让代码的可维护性更高。", "Taro", "是凹凸实验室打造的一套遵循", "React", "语法规范的多端统一开发框架，是React系开发者的福音。", "Taro官方称“只要书写一套代码，通过Taro编译工具将源代码分别编译出可以在不同端（微信小程序、H5、APP端[React", "Native]）运行的代码，同时Taro还提供了开箱即用的语法检测和自动补全等功能，有效地提升了开发体验和开发效率”。Taro所具备的优势：NPM包管理系统ES6+语法自由的资源引用CSS预处理器和后处理器（SCSS、Less、PostCSS）灵活的JSX写法TypeScript", "在我看来，wepy和mpvue都想尽可能地提供一套类vue的写法，但小程序的运行环境始终和Web端存在着差异，不可能完美地支持vue的所有指令及过滤器等等。开发者不但要去踩小程序自身的坑，还要去记住wepy和mpvue到底有哪些vue的特性不能使用，这着实是叫人头大啊。", "React和原生的小程序开发方式比更加现代化、规范化、组件化，JSX比Vue的字符串模板也具有更强的表现力。JSXrender", "()", "{", "return", "(", "{this.state.list.map((item,", "idx)", "=>", "(", "{item}", "))}", "this.func}>方法", ")}复制代码小程序模板<view", "class=\"index\">", "<view", "wx:key={idx}", "wx:for=\"{{list}}\"", "wx:for-item=\"item\"", "wx:for-index=\"idx\">{{item}}view>", "<view", "bindtap=\"func\">方法view>view>复制代码", "JSX", "其实本质上就是", "JS，我们可以在里面写任意的逻辑代码，这样一来就比字符串模板的表现力与操作性要强多了，况且，小程序的字符串模板功能比较羸弱，只有一些比较基本的功能。", "Taro有着和React完全一致的API和组件化系统。在", "Taro", "中，不用像原生小程序一样区分什么是", "App", "组件，什么是", "Page", "组件，什么是", "Component", "组件，Taro", "全都是", "Component", "组件，并且和", "React", "的生命周期几乎完全一致。", "Taro", "和", "React", "一样，同样使用声明式的", "JSX", "语法。相比起字符串的模板语法，JSX", "在处理精细复杂需求的时候会更得心应手，示例代码如下：Taro的其他几项优点：具备良好的开发效率和体验：编辑器对Taro的支持和React几乎是一样的。类型安全和运行时检测：可以使用TypeScript或Flow来对代码的可靠性进一步增强。高效的自动补全和", "ES6+", "语法：Taro", "的所有", "API（包括微信小程序等端能力接口）都有智能的提醒和自动补全，包括接口的参数和返回值。技术选型与权衡", "小程序社区已经有多个优秀的框架以小程序为核心对多端适配进行了探索，我们将各个开发框架的主要特点和特性进行了对比并制成图表。大家可以结合团队技术栈、技术需求以及框架特点、特性进行选型和权衡。在后续文章中，会带大家一起用Taro框架来实战开发小程序。"]}
{"author": "Rolan", "title": "小程序 LRU 存储设计 ", "content": ["为了解决小程序生成分享到朋友圈图片的问题，我们开启了", "画家计划---", "一个小程序图片生成库。该计划已开源，可移步：", "github.com/Kujiale-Mob…", "。", "大家知道", "Canvas", "的绘制有很多很蛋疼的坑，其中一个是它的", "drawImage", "方法，该方法在", "IDE", "中可以直接设置为网络图片的", "url", "进行绘制，但在真机上无法这样做。有这个坑后，我们就需要先把图片通过", "download", "下载到本地后，才能进行绘制。所以你的小程序中，如果有频繁绘制一些图片的需求，而又需要用到网络图片素材，这就导致每次绘制都要重新下载素材图片，产生很大的绘制性能问题。小程序本身是未提供文件", "LRU", "之类的缓存机制的。为了让我们的", "画家计划", "图片生成的更快，我们自己开发了的小程序文件进行", "LRU", "存储的相关代码。这样我们就无需重复下载可能会频繁使用到的绘图素材，大大增加了绘图速度。介绍下小程序的缓存系统小程序的缓存分为数据缓存，和文件缓存两部分。而文件缓存又分为临时文件缓存，和本地文件存储。其中本地文件存储的大小限制为", "10M。数据缓存我们可以使用小程序提供的一套异步和同步的方法来增删查结构化数据。同一个微信用户，同一个小程序的存储上限为", "10MB。如果空间不足时会在小程序级别进行", "LRU，也就是不经常使用的小程序的数据缓存区域会被全部清空。详细见微信官方文档：developers.weixin.qq.com/miniprogram…注：数据缓存区在体验版、开发版、和线上版都共用一套，并不会隔离。文件临时缓存我们在调用", "wx.downloadFile", "或者", "wx.chooseImage", "等获取文件或图片的方式成功后，我们会得到这个文件或图片的临时存储路径。文档上写的是", "临时路径的生命周期是在本次小程序启动期间内", "。不过没有对存储大小的限制进行说明，所以理论上不管多大文件都可以进行临时缓存，当然如果太大肯定会造成某些神奇的错误吧。本地存储我们在获得临时文件后，可以通过调用接口", "wx.saveFile", "把临时文件存储到本地空间中，本地空间存储限制为", "10M。如果存储满了后，后面的文件就无法存储成功了，会报超出最大存储上限的错误。而我们现在需要做的就是在这个本地存储空间上，开辟一个空间，作为我们下载文件的存储空间，因空间有限，所以我们需要对这块空间进行", "LRU", "管理。有关本地存储相关的接口可看以下文档：developers.weixin.qq.com/miniprogram…注：把临时文件通过调用", "saveFile", "成功后，这个临时文件路径就无效了。切记切记。文件", "LRU", "存储实现小程序端的本地存储有", "10M", "限制，但却无", "LRU，现在我们需要结合上面提到的小程序三种存储方式来实现一套小程序文件下载的", "LRU", "机制。数据结构设计{", "'key':", "{", "'path':", "//", "文件的存储路径", "'time':", "//", "时间戳，用来记录文件的最后访问时间，当存储不够时，会选择最远未被访问的文件进行删除", "'size':", "//", "文件大小", "}", "....", "'totalSize':", "//", "所有存储文件的当前总大小", "}", "复制代码其中我们用下载的", "url", "作为", "key。", "以上数据结构会存在在数据缓存区（后续我们会把这个区域称为", "storage", "区），并且在下载器构建之时会从", "storage", "中读取到内存中。以后的文件操作，也会实时同步到", "storage", "中记录的文件信息。你可以理解为，storage", "中存储了文件的基本信息，而", "path", "就相当于指向这个实际文件的指针。总体流程设计容错因为", "storage", "的存储，和文件操作都是异步的，所以有可能存在两者不一致的情况。此处的不一致情况分两种第一种，storage", "的某文件信息被删除了，但文件本身却因为出现神奇错误而未被删除。另外文件添加成功了，但", "storage", "中却未添加成功也属于此情况。第二种，storage", "中文件信息删除失败，但是文件却被删除了。以上两种性质不同，所以也需要区别对待。针对第一种会导致文件的存储空间和", "storage", "中记录的文件信息不一致，也即出现了游离的文件（未被", "storage", "跟踪）。而第二种，相当于存在了空指针，此种情况是绝对需要避免的，因为这会导致你在拿出一个不存在的文件使用。会直接导致严重bug。针对以上两种特殊情况，做了以下容错的处理。首先我们要保证文件的删除操作一定要在", "storage", "成功之后进行。这样保证了第二种不会出错。而针对第一种游离文件的情况。我们这边会在", "saveFile", "的时机进行兜底处理。如果存在了游离文件，最终会导致我们空间总大小计算不一致，这可能最终会导致，我们外部逻辑认为可以存储，但实际存储空间已经满了，这样就会导致", "saveFile", "报错，在", "saveFile", "出错后，不管啥原因，我们都把涉及到本策略存储相关的内容全部清空掉，重新来过。因为我们一直有", "tempFilePath", "兜底，所以即使这种情况出现，也不会影响用户正常使用。只是会影响一点用户体验（毕竟一下子没有以前的缓存了）。注：之所以不像保证第二种情况的方式来保证第一种情况，是因为我觉得不需要为处理极少会出现的错误场景而去浪费性能，影响用户体验。只要我们做好兜底，即使这种错误情况万一真的出现，整个系统也不会因此出问题，还是会正常使用。写在后面小程序有很多的坑。目前市面上很多小程序性能体验并不是很好。所以为了做一款高性能的小程序，是需要我们花大量的时间去试错，琢磨的。踩坑不止，生命不惜。目前这一套", "LRU", "的文件存储机制已经在我们开源的", "Painter", "库中使用，如有兴趣请移步：", "github.com/Kujiale-Mob…", "。"]}
{"author": "Rolan", "title": "微信小程序：一个json帮你完成分享朋友圈图片 ", "content": ["写在前面", "最近在做小程序，发现制作分享到朋友圈图片是每个项目必须的。遇到坑比较多，写起来也比较繁琐，也没有找到类似组件，所以就自己动手写了一个。", "演示", "左侧是", "canvasdrawer", "绘制的，右侧是UI给的图", "特性", "简单易用", "——", "一个", "json", "搞定绘制图片", "功能全", "——", "满足", "90%", "的使用场景", "绘制文本（换行、超出内容省略号、中划线、下划线、文本加粗）", "绘制图片", "绘制矩形", "保存图片", "多图绘制", "...", "代码量小", "体验", "git", "clone", "https://github.com/kuckboy1994/mp_canvas_drawer", "复制代码想在手机上使用配置自己的", "appid", "即可。", "编译模式中已经为你配置好比较常用的两种模式：", "普通绘制，绘制单张分享图。", "多图绘制，连续绘制分享图", "使用", "git", "clone", "https://github.com/kuckboy1994/mp_canvas_drawer", "到本地", "把", "components", "中的", "canvasdrawer", "拷贝到自己项目下。", "在使用页面注册组件", "{", "\"usingComponents\":", "{", "\"canvasdrawer\":", "\"/components/canvasdrawer/canvasdrawer\"", "}", "}", "复制代码", "在页面", "**.wxml", "文件中加入如下代码", "<canvasdrawer", "painting=\"{{painting}}\"", "bind:getImage=\"eventGetImage\"/>", "复制代码painting", "是需要传入的", "json。", "getImage", "方法是绘图完成之后的回调函数，在", "event.detail", "中返回绘制完成的图片地址。", "当前栗子中的", "painting", "简单展示一下。详细配置请看", "API", "painting（点击展开）", "{", "width:", "375,", "height:", "555,", "views:", "[", "{", "type:", "'image',", "url:", "'https://hybrid.xiaoying.tv/miniprogram/viva-ad/1/1531103986231.jpeg',", "top:", "0,", "left:", "0,", "width:", "375,", "height:", "555", "},", "{", "type:", "'image',", "url:", "'https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epJEPdPqQVgv6D8bojGT4DrGXuEC4Oe0GXs5sMsN4GGpCegTUsBgL9SPJkN9UqC1s0iakjQpwd4h4A/132',", "top:", "27.5,", "left:", "29,", "width:", "55,", "height:", "55", "},", "{", "type:", "'image',", "url:", "'https://hybrid.xiaoying.tv/miniprogram/viva-ad/1/1531401349117.jpeg',", "top:", "27.5,", "left:", "29,", "width:", "55,", "height:", "55", "},", "{", "type:", "'text',", "content:", "'您的好友【kuckboy】',", "fontSize:", "16,", "color:", "'#402D16',", "textAlign:", "'left',", "top:", "33,", "left:", "96,", "bolder:", "true", "},", "{", "type:", "'text',", "content:", "'发现一件好货，邀请你一起0元免费拿！',", "fontSize:", "15,", "color:", "'#563D20',", "textAlign:", "'left',", "top:", "59.5,", "left:", "96", "},", "{", "type:", "'image',", "url:", "'https://hybrid.xiaoying.tv/miniprogram/viva-ad/1/1531385366950.jpeg',", "top:", "136,", "left:", "42.5,", "width:", "290,", "height:", "186", "},", "{", "type:", "'image',", "url:", "'https://hybrid.xiaoying.tv/miniprogram/viva-ad/1/1531385433625.jpeg',", "top:", "443,", "left:", "85,", "width:", "68,", "height:", "68", "},", "{", "type:", "'text',", "content:", "'正品MAC魅可口红礼盒生日唇膏小辣椒Chili西柚情人',", "fontSize:", "16,", "lineHeight:", "21,", "color:", "'#383549',", "textAlign:", "'left',", "top:", "336,", "left:", "44,", "width:", "287,", "MaxLineNumber:", "2,", "breakWord:", "true,", "bolder:", "true", "},", "{", "type:", "'text',", "content:", "'￥0.00',", "fontSize:", "19,", "color:", "'#E62004',", "textAlign:", "'left',", "top:", "387,", "left:", "44.5,", "bolder:", "true", "},", "{", "type:", "'text',", "content:", "'原价:￥138.00',", "fontSize:", "13,", "color:", "'#7E7E8B',", "textAlign:", "'left',", "top:", "391,", "left:", "110,", "textDecoration:", "'line-through'", "},", "{", "type:", "'text',", "content:", "'长按识别图中二维码帮我砍个价呗~',", "fontSize:", "14,", "color:", "'#383549',", "textAlign:", "'left',", "top:", "460,", "left:", "165.5,", "lineHeight:", "20,", "MaxLineNumber:", "2,", "breakWord:", "true,", "width:", "125", "}", "]", "}", "复制代码", "API", "对象结构一览", "{", "width:", "375,", "height:", "555,", "views:", "[", "{", "type:", "'image',", "url:", "'url',", "top:", "0,", "left:", "0,", "width:", "375,", "height:", "555", "},", "{", "type:", "'text',", "content:", "'content',", "fontSize:", "16,", "color:", "'#402D16',", "textAlign:", "'left',", "top:", "33,", "left:", "96,", "bolder:", "true", "},", "{", "type:", "'rect',", "background:", "'color',", "top:", "0,", "left:", "0,", "width:", "375,", "height:", "555", "}", "]", "}", "复制代码", "数据对象的第一层需要三个参数:", "width、height、views。配置中所有的数字都是没有单位的。这就意味着", "canvas", "绘制的是一个比例图。具体显示的大小直接把返回的图片路径放置到", "image", "标签中即可。", "当前可以绘制3种类型的配置:", "image、text、rect。配置的属性基本上使用的都是", "css", "的驼峰名称，还是比较好理解的。", "image（图片）", "text（文本）", "rect", "(矩形，线条)", "Q&A", "最佳实践", "绘制操作的时候最好", "锁住屏幕", "，例如在点击绘制的时候", "wx.showLoading({", "title:", "'绘制分享图片中',", "mask:", "true", "})", "复制代码绘制完成之后", "wx.hideLoading()", "复制代码具体可以参考项目下的", "/pages/multiple", "二维码和小程序码如何绘制？", "二维码和小程序码可以通过调用微信官方的接口产生，需要后端配合。", "然后走", "type:", "image", "类型进行绘制即可。", "绘制流程相关", "views", "数组中的顺序代表绘画的先后顺序，会有覆盖的现象。请各位使用者注意。", "如何实现圆形头像？", "canvas", "中没有绘制圆形图片的方法，所以使用了", "hack", "的方式来实现的。使用一张中间镂空的图片盖在头像上就可实现当前效果。", "canvas", "drawer", "组件为什么不直接显示canvas画板和其内容呢？", "考虑到大部分场景，我们都是用来把图片保存到本地，或用以展示。", "保存到本地，返回临时文件给调用者一定是最佳的解决方式。", "展示，转化成图片之后，就可以使用", "image", "基础组件的所有显示模式了，还能设置宽高。", "TIPS", "如果有什么疑问，欢迎", "issues。", "如果觉得不错，能不能送我小", "✨", "✨", "，然我有更多的动力更新。", "github：github.com/kuckboy1994…"]}
{"author": "Rolan", "title": "微信大升级，“我的小程序”入口将会被哪些产品抢占？ ", "content": ["今年微信真的是动作不断，如今最新版微信在小程序下拉菜单中，加上了一个“我的小程序”入口。关注微信动态的朋友应该都知道，张小龙曾经说过下拉菜单不是入口，而现在一改版，无论怎样诡辩，它确实是一个入口，不知道明年张小龙会怎么圆这个“这不是入口”的黑色幽默……事实上在我们使用小程序的时候确实也能感到不方便，打开的小程序多了，想要再次找到某个小程序其实非常麻烦，所以也是一直猜测会有个类似订阅号一样的入口，把个人精选的小程序收纳起来。相信微信官方也是这么考虑，节省用户使用小程序的效率，当然还有另外一个客观因素就是，现在小程序的数量已经到达一定量级了，需要有“收藏夹“了。换句话说，小程序的生态，可能一定程度上已经不再是“野蛮生长”了，而即将进入强竞争的“弱肉强食”阶段了。微信这次升级开放了小程序“收藏夹”入口，应该会对小程序生态有着非常重要的影响。瞎猜一下，普通用户都会把哪些小程序放到“我的小程序”栏目里。一、工具类小程序工具类小程序主要是简单、方便、实用，但在以前没更新的微信版本中，用户经常会使用了某种工具小程序后，想要再找回便发现已经淹没在其他的小程序列表中了，十分麻烦，所以我个人最初一直认为商务名片类的小程序在原来的环境下很难做起来。不仅是商务名片小程序，像微信指数、公众号助手、QQ邮箱、腾讯文档这类工具型小程序都会面临同样的固定入口问题。但现在微信开放了“我的小程序”栏目，相信这类工具类小程序能够获得一波红利和发展。这类小程序主要以满足零碎的功能性需求为主，比如名片、待办事项提醒、公交卡、公交车查询、邮箱、字典、相册、题库等等。二、导航集合类小程序小程序并不像公众号一样带有明显的个人或品牌特质，因此我猜测可能会出现类似于网址导航一样的小程序占据“我的小程序”这一重要入口。通过导航合集类小程序，向外分发其他小程序的流量，比如说：有“好玩游戏导航”这个小程序，里面就是各种火热的小游戏板块，思路可能和“hao123”这类网址导航一样。当然这是否成真还需要时间检验，但一旦出现了整合导航类的小程序，那实际上就是个小程序版的“App", "Store”了，在其基础上便能构建出无数的商业模型，据我所知，已经有不少团队在做这一类的小程序导航了。三、碎片娱乐类小程序娱乐是人们打开小程序的原动力，特别是当娱乐拥有社交玩法后，容易形成病毒式传播。这里的娱乐主要会分为三小类：1、小游戏类似于弹一弹、跳一跳、海盗来了之类的轻量级小游戏可能会在一定时间内占据“我的小程序”收藏栏中，但由于小游戏的生命周期会相对比较短，可能不会长期霸屏。另外我也一直挺看好养成互动类的小游戏出现，比如：电子宠物、旅行青蛙，甚至早年间开心农场类的社交养成模式游戏，我个人认为可能在小程序固定栏中都能有一席之地。2.", "短视频短视频其实是个碎片化时间的大杀器，但目前在小程序中并没有太亮眼的表现。若把短视频类小程序固定到“我的小程序”栏目中，可以大大缩减用户切换消费短视频内容的步骤，不再需要切换APP了。3.", "轻资讯轻量级的资讯内容小程序可能也是用户收藏的目标，比如：段子类、要闻类、文摘类、问答类小程序。但说实话，目前内容类小程序并没有太抢眼的表现，几乎可以说是全军覆没。我个人把这个内容小程序全军覆没的原因更多归结在入口问题上，另外如今的内容型小程序似乎还是“太重”，现在增加了强势的用户入口后，内容类小程序会可能会有爆发。四、小程序列表乱得让人眼花最后吐槽一下，微信小程序这个下拉页面也太长了，占据了屏幕近一半的位置，总共能有10个小程序的展示坑位，看得人眼花，绝对是一项对眼力的挑战，是不是感觉已经有点“手机淘宝APP”首页了？而且如果收藏的小程序使用频率高，很多时候“最近使用”和“我的小程序”会相对重合。我个人感觉像其他收藏栏一样，把“我的小程序”折叠起来说不定会更高效？微信的改版让微信生态系统越来越庞大，几乎手机所有功能，你都能够在微信中实现，配合上腾讯王卡免流量的特权，你似乎真能不使用其他的任何APP，可看出腾讯的野心和版图所在。这次“我的小程序”入口能够有效解决小程序“用完即走”的留存弊病，让用户“走了还来”，也算是向质量过硬的小程序的一种流量倾斜吧，但具体会发生什么变化，相信过不了多久就能从市场的反应中看出来，拭目以待吧~#专栏作家#郑卓然，公众号：传播体操（ID:chuanboticao），人人都是产品经理专栏作家。广告营销、新媒体运营领域老司机，专注分享营销、运营、商业的干货文章及独特见解。本文原创发布于人人都是产品经理。未经许可，禁止转载。题图来自网络"]}
{"author": "Rolan", "title": "喂，快给我打一个小程序预览码 ", "content": ["需求开发小程序的朋友们随时都会听到一句话：“喂，快给我打一个xxx环境的预览码”，无论你正在干什么，都得赶紧地回一句：“稍等，这就给你打码……”然后苦逼的你build了一个xxx环境的包，打开了微信开发者工具，点了一下预览，等了一下，预览码出来了，你复制丢给你的爸爸们。终于有一天，你正在专心致志做一些不可描述的事情时，“喂，快给我打一个xxx环境的预览码”，这时你内心怒吼了一句：“老子不给你打码！你自己打去！”于是就有了这个需求，要搞个东西让爸爸们自主打码，嗯，应该就是只有一个按钮，点一下就可以出现预览二维码的东西，意淫了一下应该是这样的：没错！就这样干！规划一下干大事就要从胡思乱想开始，现在来想想要搞成这个功能，需要做点什么准备工作吧。找微信开发者工具的接口最重要的事情莫过于看看微信开发者工具有没有给我们提供这样的接口让我们去操作，经过一番查阅文档我们会发现，果然有！https://developers.weixin.qq....会发现，文档给我们提供了两种方式的接口，命令行调用以及HTTP调用。有了接口，一切都好办了，无非就是调一下接口，拿到二维码，贴到页面上去而已嘛，很简单。梳理开发流程我们就把这个简单的事情，用流程图说明一下：https://www.processon.com/vie...所需技术工欲善其事，必先利其器，我们要搞这个东西，还是先要把用到的技术整理一下。微信开发者工具一个小程序项目（这里以一个mpvue项目为例子）前端vue", "+", "vux，这里前端没什么需要做的东西，这样的搭配纯属是因为本来就正在做移动端的东西，直接拿来用而已。后端koa2，当然后端用什么都可以，这里选择koa2，纯属是因为我也不会用别的……前后端HTTP请求统一用axios涉及到node操作命令行需要用到shelljs好像没别的东西了，用到了再说吧。撸起袖子从后端开始为了省事，直接把前后端的东西放在一起。项目目录：可以看到server这个目录下放的都是后端的东西。server/index.js先看看入口文件index.js，从这里我们可以知道后端要做两件事情，第一要能访问到前端build出来的静态资源，第二要能与前端通过HTTP接口进行交互。见代码：const", "path", "=", "require('path')", "const", "Koa", "=", "require('koa')", "const", "koaStatic", "=", "require('koa-static')", "const", "bodyParser", "=", "require('koa-bodyparser')", "const", "router", "=", "require('./router')", "const", "app", "=", "new", "Koa()", "const", "port", "=", "9871", "app.use(bodyParser())", "//", "处理静态资源", "这里是前端build好之后的目录", "app.use(koaStatic(", "path.resolve(__dirname,", "'../dist')", "))", "//", "路由处理接口", "app.use(router.routes()).use(router.allowedMethods())", "//", "监听端口", "app.listen(9871)", "console.log(`[demo]", "start-quick", "is", "starting", "at", "port", "${port}`)", "静态资源方面的话使用koa-static即可，重点是怎样给前端提供接口，这就要看路由了。server/router/index.jsconst", "Router", "=", "require('koa-router')", "//", "业务逻辑", "const", "wx", "=", "require('../controller/wx')", "const", "router", "=", "new", "Router({", "//", "接口前缀", "比如open接口", "请求路径就是/api/open", "prefix:", "'/api'", "})", "router.get('/open',", "wx.open)", ".get('/login',", "wx.login)", ".get('/preview',", "wx.preview)", ".get('/build',", "wx.build)", "module.exports", "=", "router", "这里可以清晰看到，后端提供了四个接口，但具体每个接口的业务逻辑则封装在controller里的wx.js，如果以后还有别的业务逻辑，就在controller加相应的模块即可。server/controller/wx.js//", "微信开发者工具接口调用逻辑", "const", "{open,", "login,", "preview,", "build}", "=", "require('../utli/wxToolApi')", "//", "处理成功失败返回格式的工具", "const", "{successBody,", "errorBody}", "=", "require('../utli')", "class", "WxController", "{", "/**", "*", "根据环境对mpvue项目进行打包", "*", "@returns", "{Promise<void>}", "*/", "static", "async", "build", "(ctx)", "{", "//", "前端传过来的get参数", "const", "query", "=", "ctx.request.query", "if", "(!query", "||", "!query.env)", "{", "ctx.body", "=", "errorBody(null,", "'构建项目失败')", "return", "}", "const", "[err,", "data]", "=", "await", "build(query.env)", "ctx.body", "=", "err", "?", "errorBody(err,", "'构建项目失败')", ":", "successBody(data,", "'构建项目成功')", "}", "/**", "*", "打开微信开发者工具", "*", "@returns", "{Promise<void>}", "*/", "static", "async", "open", "(ctx)", "{", "const", "[err,", "data]", "=", "await", "open()", "ctx.body", "=", "err", "?", "errorBody(err,", "'打开微信开发者工具失败')", ":", "successBody(data,", "'打开微信开发者工具成功')", "}", "/**", "*", "登录微信开发者工具", "*", "@returns", "{Promise<void>}", "*/", "static", "async", "login", "(ctx)", "{", "const", "[err,", "data]", "=", "await", "login()", "ctx.body", "=", "err", "?", "errorBody(err,", "'登录二维码返回失败')", ":", "successBody(data,", "'登录二维码返回成功')", "}", "/**", "*", "查看预览码", "*", "@returns", "{Promise<void>}", "*/", "static", "async", "preview", "(ctx)", "{", "const", "[err,", "data]", "=", "await", "preview()", "ctx.body", "=", "err", "?", "errorBody(err,", "'预览二维码返回失败')", ":", "successBody(data,", "'预览二维码返回成功')", "}", "}", "module.exports", "=", "WxController", "为了代码更加清晰，这里将具体操作微信开发者工具的接口逻辑抽到util/wxToolApi.js里去了，仅仅处理怎样以统一格式返回给前端。util/wxToolApi.jsconst", "{promiseWrap,", "successBody,", "errorBody}", "=", "require('../utli')", "const", "{INSTALL_PATH,", "PROJECT_PATH,", "PORT_PATH,", "PORT_FILE_NAME,", "HOST}", "=", "require('../const')", "const", "{readFile}", "=", "require('../utli/nodeApi')", "const", "shell", "=", "require('shelljs')", "const", "axios", "=", "require('axios')", "module.exports", "=", "{", "/**", "*", "根据环境对mpvue项目进行打包", "*", "@param", "env", "[doc,", "pre,", "prd]", "*", "@returns", "{*}", "*/", "build", "(env)", "{", "return", "promiseWrap(new", "Promise((resolve,", "reject)", "=>", "{", "//", "进入项目目录", "shell.cd(PROJECT_PATH)", "//", "执行打包命令", "shell.exec(`npm", "run", "build:${env}`,", "function", "(code,", "stdout,", "stderr)", "{", "resolve(stdout)", "})", "}))", "},", "/**", "*", "打开微信开发者工具", "*", "@returns", "{*}", "*/", "open", "()", "{", "return", "promiseWrap(new", "Promise((resolve,", "reject)", "=>", "{", "//", "进入项目目录", "shell.cd(INSTALL_PATH)", "//", "执行微信开发者工具接口“命令行启动工具”", "shell.exec(`cli", "-o", "${PROJECT_PATH}`,", "function", "(code,", "stdout,", "stderr)", "{", "if", "(stderr)", "return", "reject(stderr)", "resolve(stdout)", "})", "}))", "},", "/**", "*", "获取微信开发者工具端口号", "*", "@returns", "{Promise<*>}", "*/", "async", "getPort", "()", "{", "shell.cd(PORT_PATH)", "//", "http", "服务在工具启动后自动开启，HTTP", "服务端口号在用户目录下记录，可通过检查用户目录、检查用户目录下是否有端口文件及尝试连接来判断工具是否安装/启动。", "const", "[err,", "data]", "=", "await", "readFile(PORT_FILE_NAME)", "return", "err", "?", "errorBody(err,", "'读取端口号文件失败')", ":", "successBody(data,", "'读取端口号文件成功')", "},", "/**", "*", "微信开发者工具进行登录", "*", "@returns", "{*}", "*/", "login", "()", "{", "return", "promiseWrap(new", "Promise(async", "(resolve,", "reject)", "=>", "{", "//", "获取端口号", "const", "portData", "=", "await", "module.exports.getPort()", "if", "(portData.code", "!==", "0)", "{", "reject(portData)", "return", "}", "const", "port", "=", "portData.data", "axios.get(`http://${HOST}:${port}/login?format=base64`)", ".then(res", "=>", "{", "resolve(res.data)", "})", ".catch(e", "=>", "{", "reject(e)", "})", "}))", "},", "/**", "*", "微信开发者工具获取预览码", "*", "@returns", "{*}", "*/", "preview", "()", "{", "return", "promiseWrap(new", "Promise(async", "(resolve,", "reject)", "=>", "{", "const", "portData", "=", "await", "module.exports.getPort()", "if", "(portData.code", "!==", "0)", "{", "reject(portData)", "return", "}", "const", "port", "=", "portData.data", "axios.get(`http://${HOST}:${port}/preview?format=base64&projectpath=${encodeURIComponent(PROJECT_PATH)}`)", ".then(res", "=>", "{", "resolve(res.data)", "})", ".catch(e", "=>", "{", "reject(e)", "})", "}))", "}", "}", "这里有一点需要注意，为什么只有open接口需要用命令行调用方式？那是因为HTTP调用方式必须加端口，比如open接口#", "打开工具", "http://127.0.0.1:端口号/open", "#", "打开/刷新项目", "http://127.0.0.1:端口号/open?projectpath=项目全路径如果你根本都没有打开微信开发者工具，在以下地方就会找不到端口：端口号文件位置：", "macOS", ":", "~/Library/Application", "Support/微信web开发者工具/Default/.ide", "Windows", ":", "~/AppData/Local/微信web开发者工具/User", "Data/Default/.ide所以作为一个全自动化打码工具，怎么可能还要自己去手动打开微信开发者工具呢！前端后端的东西基本就那么多，终于到前端了，前端十分简单，就不多说了：<template>", "<div>", "<group", "title=\"请选择环境\">", "<radio", ":options=\"envOption\"", "v-model=\"env\"></radio>", "</group>", "<x-button", "class=\"btn\"", "type=\"default\"", "@click.native=\"handlePreviewProject\">点击预览</x-button>", "<div", "v-if=\"loginImg\"", "class=\"code\">", "<divider>请先登录</divider>", "<img", "class=\"code-img\"", ":src=\"loginImg\"", "alt=\"\">", "</div>", "<div", "v-if=\"preImg\"", "class=\"code\"", "id=\"preImg\">", "<divider>预览二维码</divider>", "<img", "class=\"code-img\"", ":src=\"`${base64Prefix}${preImg}`\"", "alt=\"\">", "</div>", "</div>", "</template>", "<script>", "import", "{openProject,", "login,", "previewProject,", "buildProject}", "from", "'SERVICES/index'", "import", "{showLoading,", "hideLoading}", "from", "'UTILS'", "import", "{", "Divider,", "XButton,", "Radio,", "Group", "}", "from", "'vux'", "export", "default", "{", "data", "()", "{", "return", "{", "//", "data表示取得数据的协定名称，image/png", "是数据类型名称，base64", "是数据的编码方法，逗号后面就是这个image/png文件base64编码后的数据。", "base64Prefix:", "'data:image/png;base64,',", "//", "登录二维码", "loginImg:", "'',", "//", "预览二维码", "preImg:", "'',", "//", "环境", "默认为doc", "env:", "'doc',", "//", "所有的环境选项", "envOption:", "['doc',", "'pre',", "'prd']", "}", "},", "components:", "{", "Divider,", "XButton,", "Radio,", "Group", "},", "methods:", "{", "handleError", "(msg)", "{", "alert(msg)", "},", "async", "login", "()", "{", "const", "{data:", "{code,", "data,", "msg}}", "=", "await", "login()", "if", "(code", "!==", "0)", "{", "this.handleError(msg)", "return", "code", "}", "this.loginImg", "=", "data", "return", "code", "},", "async", "previewProject", "()", "{", "const", "{data:", "{code,", "data,", "msg}}", "=", "await", "previewProject()", "if", "(code", "!==", "0)", "{", "this.handleError(msg)", "return", "code", "}", "this.preImg", "=", "data", "return", "code", "},", "async", "handlePreviewProject", "()", "{", "showLoading()", "//", "重置二维码", "this.resetImg()", "//", "打开微信开发者工具", "const", "{data:", "{code}}", "=", "await", "openProject()", "if", "(code", "!==", "0)", "{", "//", "登录微信开发者工具", "await", "this.login()", "hideLoading()", "return", "}", "//", "根据环境打包", "await", "buildProject(this.env)", "//", "预览", "await", "this.previewProject()", "hideLoading()", "},", "resetImg", "()", "{", "this.loginImg", "=", "''", "this.preImg", "=", "''", "}", "}", "}", "</script>", "<style", "lang='less'>", ".btn", "{", "width:", "90%!important;", "margin:", "30px", "auto", "30px", "auto;", "}", ".code", "{", "display:", "flex;", "align-items:", "center;", "flex-direction:", "column;", ".code-img", "{", "width:", "300px;", "height:", "300px;", "}", "}", "</style>", "这里有一个坑就是，login返回的base64是带了data:image/jpeg;base64,前缀的，所以可以直接放到img的src里，但是获取预览码的preview返回的却没有这个前缀！所以需要自己加上去，就是那个base64Prefix：'data:image/png;base64,'最后其实到这里已经基本实现了整个打码功能，但如果真的要可以用还有很多事情没做。部署到测试机器上。虽然可以直接用自己的机子作为部署这个工具的机器，但这实在是有点……如果要部署到测试机器上，有一个问题就是，微信开发者工具依赖图形界面，而服务器一般是命令行，虽然有", "https://github.com/cytle/wech...", "这样的项目移植微信开发者工具到linux，但这种部署方式似乎还是怪怪的。假设完成了上述部署，进行小程序项目打包的环节需要修改一下，变成根据选择的环境，到相应的代码仓库（比如gitlab）拉取该环境的最新代码，然后进行安装依赖才能执行打包命令。既然都做到这一步了，也不差把上传小程序也加上去，微信开发者工具接口也有提供，这样一来整个测试打码到上线的步骤都有了。End~"]}
{"author": "Rolan", "title": "【微信小程序】性能优化 ", "content": ["内容整理于微信公开课", "为什么要做性能优化？", "一切性能优化都是为了体验优化", "1.", "使用小程序时，是否会经常遇到如下问题？", "打开是一直白屏", "打开是loading态，转好几圈", "我的页面点了怎么跳转这么慢？", "我的列表怎么越滑越卡？", "2.", "我们优化的方向有哪些？", "启动加载性能", "渲染性能", "3.", "启动加载性能", "1.", "首次加载", "你是否见过小程序首次加载时是这样的图？", "这张图中的三种状态对应的都是什么呢？", "小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包。", "2.", "加载顺序", "小程序加载的顺序是如何？", "微信会在小程序启动前为小程序准备好通用的运行环境。这个运行环境包括几个供小程序使用的线程，并在其中完成小程序基础库的初始化，预先执行通用逻辑，尽可能做好小程序的启动准备。这样可以显著减少小程序的启动时间。", "通过2，我们知道了，问题1中第一张图是资源准备（代码包下载）；第二张图是业务代码的注入以及落地页首次渲染；第三张图是落地页数据请求时的loading态（部分小程序存在）", "3.", "控制包大小", "提升体验最直接的方法是控制小程序包的大小，这是最显而易见的", "勾选开发者工具中“上传代码时，压缩代码”选项；", "及时清理无用的代码和资源文件（包括无用的日志代码）", "减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限", "从开发者的角度看，控制代码包大小有助于减少小程序的启动时间。对低于1MB的代码包，其下载时间可以控制在929ms（iOS）、1500ms（Android）内。", "4.", "采用分包加载机制", "根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；", "使用分包时需要注意代码和资源文件目录的划分。启动时需要访问的页面及其依赖的资源文件应放在主包中。", "5", "采用分包预加载技术", "在4的基础上，当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包，而是可以根据后期数据，做子包预加载，将用户在当先页可能点击的子包页面先加载，当用户点击后直接跳转；", "这种基于配置的子包预加载技术，是可以根据用户网络类型来判断的，当用户处于网络条件好时才预加载；是灵活可控的", "6.", "采用独立分包技术", "目前很多小程序主包+子包（2M+6M）的方式，但是在做很多运营活动时，我们会发现活动（红包）是在子包里，但是运营、产品投放的落地页链接是子包链接，这是的用户在直达落地时，必须先下载主包内容（一般比较大），在下载子包内容（相对主包，较小），这使得在用户停留时间比较短的小程序场景中，用户体验不是很好，而且浪费了很大部分流量；", "可以采用独立分包技术，区别于子包，和主包之间是无关的，在功能比较独立的子包里，使用户只需下载分包资源；", "7.", "首屏加载的优化建议", "7.1", "提前请求", "异步请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据；当然，如果能在前置页面点击跳转时预请求当前页的核心异步请求，效果会更好；", "7.2", "利用缓存", "利用storage", "API,", "对变动频率比较低的异步数据进行缓存，二次启动时，先利用缓存数据进行初始化渲染，然后后台进行异步数据的更新，这不仅优化了性能，在无网环境下，用户也能很顺畅的使用到关键服务；", "7.3", "避免白屏", "可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据-->", "详情页），没有数据的模块可以进行骨架屏的占位，使用户不会等待的很焦虑，甚至走了；", "7.4", "及时反馈", "及时的对需要用户等待的交互操作进行反馈，避免用户以为小程序卡了，无响应", "渲染性能优化", "1.", "小程序渲染原理", "双线程下的界面渲染，小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。", "分析这个流程不难得知：页面初始化的时间大致由页面初始数据通信时间和初始渲染时间两部分构成。其中，数据通信的时间指数据从逻辑层开始组织数据到视图层完全接收完毕的时间，数据量小于64KB时总时长可以控制在30ms内。传输时间与数据量大体上呈现正相关关系，传输过大的数据将使这一时间显著增加。因而减少传输数据量是降低数据传输时间的有效方式。", "2.", "避免使用不当setData", "在数据传输时，逻辑层会执行一次JSON.stringify来去除掉setData数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将setData所设置的数据字段与data合并，使开发者可以用this.data读取到变更后的数据。因此，为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：", "2.1", "不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；", "2.2", "数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；", "2.3", "与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下", "提升数据更新性能方式的代码示例", "Page({", "onShow:", "function()", "{", "//", "不要频繁调用setData", "this.setData({", "a:", "1", "})", "this.setData({", "b:", "2", "})", "//", "绝大多数时候可优化为", "this.setData({", "a:", "1,", "b:", "2", "})", "//", "不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外", "this.setData({", "myData:", "{", "a:", "'这个字符串在WXML中用到了',", "b:", "'这个字符串未在WXML中用到，而且它很长…………………………'", "}", "})", "//", "可以优化为", "this.setData({", "'myData.a':", "'这个字符串在WXML中用到了'", "})", "this._myData", "=", "{", "b:", "'这个字符串未在WXML中用到，而且它很长…………………………'", "}", "}", "})", "复制代码2.4", "切勿在后台页面进行setData", "在一些页面会进行一些操作，而到页面跳转后，代码逻辑还在执行，此时多个webview是共享一个js进程；后台的setData操作会抢占前台页面的渲染资源；", "3.", "用户事件使用不当", "视图层将事件反馈给逻辑层时，同样需要一个通信过程，通信的方向是从视图层到逻辑层。因为这个通信过程是异步的，会产生一定的延迟，延迟时间同样与传输的数据量正相关，数据量小于64KB时在30ms内。降低延迟时间的方法主要有两个。", "1.去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；", "2.事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。", "4.", "视图层渲染原理", "4.1首次渲染", "初始渲染发生在页面刚刚创建时。初始渲染时，将初始数据套用在对应的WXML片段上生成节点树。节点树也就是在开发者工具WXML面板中看到的页面树结构，它包含页面内所有组件节点的名称、属性值和事件回调函数等信息。最后根据节点树包含的各个节点，在界面上依次创建出各个组件。", "在这整个流程中，时间开销大体上与节点树中节点的总量成正比例关系。因而减少WXML中节点的数量可以有效降低初始渲染和重渲染的时间开销，提升渲染性能。", "简化WXML代码的例子", "<view", "data-my-data=\"{{myData}}\">", "<view", "class=\"my-class\"", "data-my-data=\"{{myData}}\"", "bindtap=\"onTap\">", "<text>", "{{myText}}", "text>", "view>", "view>", "<view", "class=\"my-class\"", "data-my-data=\"{{myData}}\"", "bindtap=\"onTap\">", "{{myText}}", "view>", "复制代码4.2", "重渲染", "初始渲染完毕后，视图层可以多次应用setData的数据。每次应用setData数据时，都会执行重渲染来更新界面。初始渲染中得到的data和当前节点树会保留下来用于重渲染。每次重渲染时，将data和setData数据套用在WXML片段上，得到一个新节点树。然后将新节点树与当前节点树进行比较，这样可以得到哪些节点的哪些属性需要更新、哪些节点需要添加或移除。最后，将setData数据合并到data中，并用新节点树替换旧节点树，用于下一次重渲染。", "在进行当前节点树与新节点树的比较时，会着重比较setData数据影响到的节点属性。因而，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。", "5.", "使用自定义组件", "自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用。", "6.", "避免不当的使用onPageScroll", "每一次事件监听都是一次视图到逻辑的通信过程，所以只在必要的时候监听pageSrcoll", "总结", "小程序启动加载性能", "控制代码包的大小", "分包加载", "首屏体验（预请求，利用缓存，避免白屏，及时反馈", "小程序渲染性能", "避免不当的使用setData", "合理利用事件通信", "避免不当的使用onPageScroll", "优化视图节点", "使用自定义组件"]}
{"author": "Rolan", "title": "微信小程序Java登录流程（ssm实现具体功能和加解密隐私信息问题解决方案） ... ", "content": ["文章有不当之处，欢迎指正，如果喜欢微信阅读，你也可以关注我的微信公众号：", "好好学java，获取优质学习资源。一、登录流程图二、小程序客户端doLogin:function(callback", "=", "()", "=>{}){", "let", "that", "=", "this;", "wx.login({", "success:function(loginRes){", "if(loginRes){", "//获取用户信息", "wx.getUserInfo({", "withCredentials:true,//非必填", "默认为true", "success:function(infoRes){", "console.log(infoRes,'>>>');", "//请求服务端的登录接口", "wx.request({", "url:", "api.loginUrl,", "data:{", "code:loginRes.code,//临时登录凭证", "rawData:infoRes.rawData,//用户非敏感信息", "signature:infoRes.signature,//签名", "encrypteData:infoRes.encryptedData,//用户敏感信息", "iv:infoRes.iv//解密算法的向量", "},", "success:function(res){", "console.log('login", "success');", "res", "=", "res.data;", "if(res.result==0){", "that.globalData.userInfo", "=", "res.userInfo;", "wx.setStorageSync('userInfo',JSON.stringify(res.userInfo));", "wx.setStorageSync('loginFlag',res.skey);", "console.log(\"skey=\"+res.skey);", "callback();", "}else{", "that.showInfo('res.errmsg');", "}", "},", "fail:function(error){", "//调用服务端登录接口失败", "//", "that.showInfo('调用接口失败');", "console.log(error);", "}", "});", "}", "});", "}else{", "}", "}", "});", "}", "复制代码微信小程序端发起登录请求，携带的参数主要有：code:loginRes.code,//临时登录凭证", "rawData:infoRes.rawData,//用户非敏感信息", "signature:infoRes.signature,//签名", "encrypteData:infoRes.encryptedData,//用户敏感信息", "iv:infoRes.iv//解密算法的向量", "复制代码参数解释：", "code:loginRes.code,//临时登录凭证：", "必传", "，通过code来换取后台的", "sessionKey和", "openId", "rawData:infoRes.rawData,//用户非敏感信息", "signature:infoRes.signature,//签名", "encrypteData:infoRes.encryptedData,//用户敏感信息", "iv:infoRes.iv//解密算法的向量signature,//签名、", "encryptedData", ",//用户敏感信息、", "iv", "//解密算法的向量:这三个参数是用来解码用户敏感信息的，比如电话号码等信息。需要的数据主要有：", "skey", "，用于标志用户的唯一性。三、Java后台/**", "*", "登陆接口", "*/", "@RequestMapping(\"/login\")", "@ApiResponses({", "@ApiResponse(code", "=", "404,", "message", "=", "\"服务器未找到资源\"),", "@ApiResponse(code", "=", "200,", "message", "=", "\"请求成功\"),", "@ApiResponse(code", "=", "500,", "message", "=", "\"服务器错误\"),", "@ApiResponse(code", "=", "401,", "message", "=", "\"没有访问权限\"),", "@ApiResponse(code", "=", "403,", "message", "=", "\"服务器拒绝访问\"),", "})", "@ApiOperation(value", "=", "\"小程序登录\",", "httpMethod", "=", "\"POST\",", "notes", "=", "\"小程序登录\")", "public", "ResponseEntity<LoginDataResult>", "login(", "@ApiParam(required", "=", "true,", "value", "=", "\"临时登录凭证code\",", "name", "=", "\"code\")", "String", "code,", "@ApiParam(required", "=", "true,", "value", "=", "\"用户非敏感信息\",", "name", "=", "\"rawData\")", "@RequestParam(value", "=", "\"rawData\",", "required", "=", "true)", "String", "rawData,", "@ApiParam(required", "=", "true,", "value", "=", "\"签名\",", "name", "=", "\"signature\")", "@RequestParam(value", "=", "\"signature\",", "required", "=", "true)", "String", "signature,", "@ApiParam(required", "=", "true,", "value", "=", "\"用户敏感信息\",", "name", "=", "\"encrypteData\")", "@RequestParam(value", "=", "\"encrypteData\",", "required", "=", "true)", "String", "encrypteData,", "@ApiParam(required", "=", "true,", "value", "=", "\"解密算法的向量\",", "name", "=", "\"iv\")", "@RequestParam(value", "=", "\"iv\",", "required", "=", "true)", "String", "iv", ")", "{", "ObjectMapper", "mapper", "=", "new", "ObjectMapper();", "logger.info(\"signature=============================================================\"+signature);", "logger.info(\"encrypteData==========================================================\"+encrypteData);", "logger.info(\"iv========================================================================\"+iv);", "RawData", "data", "=", "null;", "WxMaJscode2SessionResult", "session", "=", "null;", "String", "openid", "=", "null;", "String", "sessionKey", "=", "null;", "String", "phoneNumber", "=", "null;", "try", "{", "if", "(rawData", "!=", "null", "&&", "!\"\".equals(rawData))", "{", "//1、获取用户非敏感信息", "data", "=", "mapper.readValue(rawData,", "RawData.class);", "}", "session", "=", "this.wxService.getUserService().getSessionInfo(code);", "//获取到openid和sessionkey", "openid", "=", "session.getOpenid();", "sessionKey", "=", "session.getSessionKey();", "logger.info(\"sessionkey=========================================================\"+sessionKey);", "/*", "//2、获取用户手机号", "phoneNumber", "=", "phone(code,", "signature,", "rawData,", "encrypteData,", "iv);", "logger.info(\"phoneNumber=========================================\"+phoneNumber);", "*/", "}", "catch", "(IOException", "e)", "{", "e.printStackTrace();", "logger.info(\"获取用户信息失败\");", "LoginDataResult", "loginDataResult", "=", "new", "LoginDataResult();", "loginDataResult.setCode(\"2\");", "loginDataResult.setMsg(\"请求失败\");", "return", "ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(loginDataResult);", "}", "catch", "(WxErrorException", "e)", "{", "e.printStackTrace();", "logger.info(\"获取用户信息失败\");", "}", "//3、向数据库插入用户信息", "String", "skey", "=", "insertUser(data,", "openid,", "phoneNumber);", "//4、缓存openid,", "sessionKey,", "skey到redis", "redisCache(openid,", "sessionKey,", "skey);", "//5、把新的skey返回给小程序", "LoginDataResult", "loginDataResult", "=", "new", "LoginDataResult();", "loginDataResult.setSkey(skey);", "loginDataResult.setCode(\"1\");", "loginDataResult.setMsg(\"请求成功\");", "return", "ResponseEntity.status(HttpStatus.OK).body(loginDataResult);", "}", "/**", "*", "缓存openid，sessionKey,skey等信息", "*", "@param", "openid", "小程序用户唯一标志", "*", "@param", "sessionKey", "小程序会话标志", "*", "@param", "skey", "后台生成的用户唯一标志，会话管理", "*/", "private", "void", "redisCache(String", "openid,", "String", "sessionKey,", "String", "skey)", "{", "//根据openid查询skey是否存在", "String", "skey_redis", "=", "jedisClient.hget(\"WEXIN_USER_OPENID_SKEY\",", "openid);", "if", "(StringUtils.isNotBlank(skey_redis))", "{", "//存在", "删除", "skey", "重新生成skey", "将skey返回", "jedisClient.hdel(\"WEXIN_USER_OPENID_SKEY\",", "openid);", "jedisClient.hdel(\"WEIXIN_USER_SKEY_OPENID\",", "skey_redis);", "jedisClient.hdel(\"WEIXIN_USER_SKEY_SESSIONKEY\",", "skey_redis);", "}", "//", "缓存一份新的", "jedisClient.hset(\"WEXIN_USER_OPENID_SKEY\",", "openid,", "skey);", "jedisClient.expire(\"WEXIN_USER_OPENID_SKEY\",432000);//设置5天过期", "jedisClient.hset(\"WEIXIN_USER_SKEY_OPENID\",", "skey,", "openid);", "jedisClient.expire(\"WEIXIN_USER_SKEY_OPENID\",432000);//设置5天过期", "jedisClient.hset(\"WEIXIN_USER_SKEY_SESSIONKEY\",", "skey,", "sessionKey);", "jedisClient.expire(\"WEIXIN_USER_SKEY_SESSIONKEY\",432000);//设置5天过期", "}", "/**", "*", "将用户信息插入到数据库", "*", "@param", "data", "用户信息", "*", "@param", "openid", "*", "@param", "phoneNumber", "手机号", "*", "@return", "*/", "private", "String", "insertUser(RawData", "data,", "String", "openid,", "String", "phoneNumber)", "{", "//判断用户数据库是否存在,不存在，入库。", "Member", "user", "=", "userService.selectUserByOpenid(openid);", "//uuid生成唯一key", "String", "skey", "=", "UUID.randomUUID().toString();", "if", "(user", "==", "null)", "{", "//入库", "user", "=", "new", "Member();", "user.setId(skey);", "user.setCountry(data.getCountry());", "user.setCreatedate(new", "Date());", "user.setDf(1);", "user.setGender(data.getGender().equals(\"1\")", "?", "1", ":", "2);//1为男，2为女", "user.setHeadimg(data.getAvatarUrl());", "user.setNickname(data.getNickName());", "user.setOpenid(openid);", "user.setCitycode(data.getCity());", "user.setProvincecode(data.getProvince());", "user.setMobileno(phoneNumber);", "//插入到数据库", "userService.insertUser(user);", "}", "else", "{", "//已存在", "logger.info(\"用户openid已存在,不需要插入\");", "return", "user.getId();//返回用户唯一标志skey", "}", "return", "skey;", "}", "/**", "*", "获取用户板绑定的手机号", "*", "@param", "sessionKey", "小程序session", "*", "@param", "signature", "签名", "*", "@param", "rawData", "用户信息", "*", "@param", "encryptedData", "小程序加密数据", "*", "@param", "iv", "小程序向量", "*", "@return", "*/", "@ApiOperation(value", "=", "\"用户手机号获取\",", "httpMethod", "=", "\"GET\",", "notes", "=", "\"用户手机号获取\")", "public", "String", "phone(String", "sessionKey,", "String", "signature,", "String", "rawData,", "String", "encryptedData,", "String", "iv)", "{", "String", "phoneNumber", "=", "null;", "try", "{", "byte[]", "bytes", "=", "WxMiniappUtils.decrypt(Base64.decodeBase64(sessionKey),", "Base64.decodeBase64(iv),", "Base64.decodeBase64(encryptedData));", "String", "phone", "=", "new", "String(bytes,", "\"UTF8\");", "logger.info(\"phone=====================================\"+phone);", "}", "catch", "(NoSuchPaddingException", "e)", "{", "e.printStackTrace();", "}", "catch", "(NoSuchAlgorithmException", "e)", "{", "e.printStackTrace();", "}", "catch", "(InvalidAlgorithmParameterException", "e)", "{", "e.printStackTrace();", "}", "catch", "(InvalidKeyException", "e)", "{", "e.printStackTrace();", "}", "catch", "(BadPaddingException", "e)", "{", "e.printStackTrace();", "}", "catch", "(IllegalBlockSizeException", "e)", "{", "e.printStackTrace();", "}", "catch", "(UnsupportedEncodingException", "e)", "{", "e.printStackTrace();", "}", "return", "null;", "}", "复制代码下面对上面代码进行分析：3.1获取openid和sessionKeysession", "=", "this.wxService.getUserService().getSessionInfo(code);", "//获取到openid和sessionkey", "openid", "=", "session.getOpenid();", "sessionKey", "=", "session.getSessionKey();", "复制代码这段代码是不是十分的简洁，这里用到了一个", "第三方的sdk（weixin-java-tools）", "，通过这个sdk可以非常简便的获取到openid和sessionKey，具体的", "demo", "。当然，如果你不想用", "第三方的sdk", "，也可以自己实现，实现代码如下：public", "static", "JSONObject", "getSessionKeyOrOpenId(String", "code){", "//微信端登录code", "String", "wxCode", "=", "code;", "String", "requestUrl", "=", "\"https://api.weixin.qq.com/sns/jscode2session\";", "Map<String,String>", "requestUrlParam", "=", "new", "HashMap<String,", "String>(", ");", "requestUrlParam.put(", "\"appid\",\"你的小程序appId\"", ");//小程序appId", "requestUrlParam.put(", "\"secret\",\"你的小程序appSecret\"", ");", "requestUrlParam.put(", "\"js_code\",wxCode", ");//小程序端返回的code", "requestUrlParam.put(", "\"grant_type\",\"authorization_code\"", ");//默认参数", "//发送post请求读取调用微信接口获取openid用户唯一标识", "JSONObject", "jsonObject", "=", "JSON.parseObject(", "UrlUtil.sendPost(", "requestUrl,requestUrlParam", "));", "return", "jsonObject;", "}", "复制代码3.2解密用户敏感数据获取用户信息3.2.1controller这个部分自己遇到了好多的坑，由于需要获取用户的手机号码，需要解密用户的信息。/**", "*", "获取用户板绑定的手机号", "*", "@param", "sessionKey", "小程序session", "*", "@param", "signature", "签名", "*", "@param", "rawData", "用户信息", "*", "@param", "encryptedData", "小程序加密数据", "*", "@param", "iv", "小程序向量", "*", "@return", "*/", "@ApiOperation(value", "=", "\"用户手机号获取\",", "httpMethod", "=", "\"GET\",", "notes", "=", "\"用户手机号获取\")", "public", "String", "phone(String", "sessionKey,", "String", "signature,", "String", "rawData,", "String", "encryptedData,", "String", "iv)", "{", "String", "phoneNumber", "=", "null;", "try", "{", "byte[]", "bytes", "=", "WxMiniappUtils.decrypt(Base64.decodeBase64(sessionKey),", "Base64.decodeBase64(iv),", "Base64.decodeBase64(encryptedData));", "String", "phone", "=", "new", "String(bytes,", "\"UTF8\");", "logger.info(\"phone=====================================\"+phone);", "}", "catch", "(NoSuchPaddingException", "e)", "{", "e.printStackTrace();", "}", "catch", "(NoSuchAlgorithmException", "e)", "{", "e.printStackTrace();", "}", "catch", "(InvalidAlgorithmParameterException", "e)", "{", "e.printStackTrace();", "}", "catch", "(InvalidKeyException", "e)", "{", "e.printStackTrace();", "}", "catch", "(BadPaddingException", "e)", "{", "e.printStackTrace();", "}", "catch", "(IllegalBlockSizeException", "e)", "{", "e.printStackTrace();", "}", "catch", "(UnsupportedEncodingException", "e)", "{", "e.printStackTrace();", "}", "return", "null;", "}", "复制代码3.2.2decrypt工具类这里调用了", "WxMiniappUtils.decrypt", "这个工具类，工具类如下：/**", "*", "解密用户手机号算法", "*", "@param", "sessionkey", "小程序登录sessionKey", "*", "@param", "iv", "向量", "*", "@param", "encryptedData", "*", "@return", "*", "@throws", "NoSuchPaddingException", "*", "@throws", "NoSuchAlgorithmException", "*", "@throws", "InvalidAlgorithmParameterException", "*", "@throws", "InvalidKeyException", "*", "@throws", "BadPaddingException", "*", "@throws", "IllegalBlockSizeException", "*/", "public", "static", "byte[]", "decrypt(byte[]", "sessionkey,", "byte[]", "iv,", "byte[]", "encryptedData)", "throws", "NoSuchPaddingException,", "NoSuchAlgorithmException,", "InvalidAlgorithmParameterException,", "InvalidKeyException,", "BadPaddingException,", "IllegalBlockSizeException", "{", "AlgorithmParameterSpec", "ivSpec", "=", "new", "IvParameterSpec(iv);", "Cipher", "cipher", "=", "Cipher.getInstance(\"AES/CBC/PKCS5Padding\");", "SecretKeySpec", "keySpec", "=", "new", "SecretKeySpec(sessionkey,", "\"AES\");", "cipher.init(Cipher.DECRYPT_MODE,", "keySpec,", "ivSpec);", "return", "cipher.doFinal(encryptedData);", "}", "复制代码这里用到的", "Cipher", "类是", "javax.crypto", "的类。3.2.3问题但是这里使用这个", "decrypt", "工具类的时候，遇到了好多的问题。第一：AES解密是报错javax.crypto.BadPaddingException:", "pad", "block", "corrupted这个问题是由于，工具类使用了", "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", "。解决：Cipher", "cipher", "=", "Cipher.getInstance(\"AES/ECB/ZeroBytePadding\");。第二：java.security.InvalidAlgorithmParameterException:", "Wrong", "IV", "length:", "must", "be", "16", "这个问题是由于，解码出来的iv不是16位，好像是15位，这个为什么我也不太清楚。解决：这个怎么解决，自己也没有找到方法，如果有大神解决，望告知！我的解决方法：其实我发现这个问题并不是这个工具类的问题，我折腾了一天发现，这个工具类并不是不能够解码手机号，有的是可以的，有的解析不到手机号，只有普通的信息，所以我觉得，这个可能是微信用户注册的时候，是不是用手机号注册的，所以会出现有些能够解析，有的不能解析。如果有大神有其他方法，望告知！3.2.4解析成功数据{\"phoneNumber\":\"13880684012\",\"purePhoneNumber\":\"13880684012\",\"countryCode\":\"86\",\"watermark\":{\"timestamp\":1519460296,\"appid\":\"wx6ede2086ee29a89f\"}}", "复制代码如果解析到了这样的json数据，说明是成功了的。3.2.5", "另外一种方案public", "class", "AES", "{", "public", "static", "final", "AES", "instance", "=", "new", "AES();", "public", "static", "boolean", "initialized", "=", "false;", "/**", "*", "AES解密", "*", "@param", "content", "密文", "*", "@return", "*", "@throws", "InvalidAlgorithmParameterException", "*", "@throws", "NoSuchProviderException", "*/", "public", "byte[]", "decrypt(byte[]", "content,", "byte[]", "keyByte,", "byte[]", "ivByte)", "throws", "InvalidAlgorithmParameterException", "{", "initialize();", "try", "{", "Cipher", "cipher", "=", "Cipher.getInstance(\"AES/CBC/PKCS7Padding\");", "Key", "sKeySpec", "=", "new", "SecretKeySpec(keyByte,", "\"AES\");", "cipher.init(Cipher.DECRYPT_MODE,", "sKeySpec,", "generateIV(ivByte));//", "初始化", "byte[]", "result", "=", "cipher.doFinal(content);", "return", "result;", "}", "catch", "(NoSuchAlgorithmException", "e)", "{", "e.printStackTrace();", "}", "catch", "(NoSuchPaddingException", "e)", "{", "e.printStackTrace();", "}", "catch", "(InvalidKeyException", "e)", "{", "e.printStackTrace();", "}", "catch", "(IllegalBlockSizeException", "e)", "{", "e.printStackTrace();", "}", "catch", "(BadPaddingException", "e)", "{", "e.printStackTrace();", "}", "catch", "(NoSuchProviderException", "e)", "{", "//", "TODO", "Auto-generated", "catch", "block", "e.printStackTrace();", "}", "catch", "(Exception", "e)", "{", "//", "TODO", "Auto-generated", "catch", "block", "e.printStackTrace();", "}", "return", "null;", "}", "public", "static", "void", "initialize(){", "if", "(initialized)", "return;", "Security.addProvider(new", "BouncyCastleProvider());", "initialized", "=", "true;", "}", "//生成iv", "public", "static", "AlgorithmParameters", "generateIV(byte[]", "iv)", "throws", "Exception{", "AlgorithmParameters", "params", "=", "AlgorithmParameters.getInstance(\"AES\");", "params.init(new", "IvParameterSpec(iv));", "return", "params;", "}", "}", "复制代码这个也会有上面的问题，有时候会解析失败！具体方法，还在摸索中，有大神知道方法和原有，望告知！3.2.6第三方sdk方法WxMaPhoneNumberInfo", "phoneNoInfo", "=", "this.wxService.getUserService().getPhoneNoInfo(sessionKey,", "encryptedData,", "iv);", "phoneNumber", "=", "phoneNoInfo.getPurePhoneNumber();", "复制代码这个也会有上面的问题出现，有时候会解析失败！四、总结1.小程序端发起请求并携带主要参数2.java后台接到/login请求后，根据code去调用微信接口获取用户唯一标识openid和sessionKey3.根据openid查询mysql数据库，判断该用户是否存在，如果不存在将用户非敏感信息和其他初始化数据存入到数据库中，如果已存在，不操作4.根据openid查询redis数据库，判断openid对应的skey是否存在，如果存在则删除原来老的skey以及对应的openid和sessionKey5.通过uuid生成唯一的skey，用openid做键，skey做值，存入到redis中6.然后把skey做键，openid和sessionKey的json串做值也重新存入到redis中7.根据解密算法，参数有encryptedData、sessionKey和iv，获取用户信息userInfo,如果userInfo字段不满足需要，可通过userInfo.put(", "\"balance\",user.getUbalance()", ");添加所需要的字段和值8.将微信小程序需要的数据封装到map中，返回给小程序端。参考资料（感谢）https://blog.csdn.net/abcwanglinyong/article/details/80267901https://github.com/binarywang/weixin-java-miniapp-demohttps://www.cnblogs.com/nosqlcoco/p/6105749.htmlhttps://www.cnblogs.com/suxiaoqi/p/7874635.html"]}
{"author": "Rolan", "title": "精确计算微信小程序scrollview高度，全机型适配 ", "content": ["众所周知，可以滑动的", "scroll", "组件在移动端非常的重要，几乎每个页面都要用到。而小程序的", "scroll-view", "组件就比较坑了，非得指定一个高度才能正常使用。布局复杂的时候谁还给你算高度啊。。。坑归坑，没办法，还是得用……既然官方要求必须传高度，那就想办法计算吧。一、布局分析，推导公式先给个示例图：这是一个稍微复杂点的页面，最上面是两个", "tab", "标签，每个标签的页面是一个子组件。第二个子组件布局是上面一个标题，下面是", "scroll-view", "。再画个解剖图吧……页面分三部分，tab，title，scroll-view。不要忘了每个部分间还有", "margin", ",", "这里设置的是每个", "margin", "都是", "10px", "。所以要计算", "scroll-view", "的高度可以得出下面", "公式", "：scroll-view", "的高度", "=", "页面可用高度", "-", "tab高度", "-", "title高度", "-", "10", "-", "10", "复制代码为什么减两个", "10", "呢？上面说了", "10", "是", "margin", "的距离，", "tab", "与", "title", "有", "10px", "的", "margin，", "title", "与", "scroll-view", "也有", "10px", "的", "margin", "。需要注意的是计算用的单位都是", "px", "，不是小程序的", "rpx", "。因为下面调用接口获取可用屏幕高度时得到的就是", "px", "。二、计算变量的高度2.1", "计算单个节点高度上面的公式中的变量有：页面可用高度,", "title", "的高度，", "tab", "的高度。这里需要计算的就是", "页面可用高度", "和", "title", "的高度，因为为了简单", "tab", "的高度是写死的", "50px", ",", "当然不写死也没关系，在父组件中计算", "tab", "的高度传给子组件就好。下面正式开始计算//计算", "scroll-view", "的高度", "computeScrollViewHeight()", "{", "let", "that", "=", "this", "let", "query", "=", "wx.createSelectorQuery().in(this)", "query.select('.title').boundingClientRect(function(res)", "{", "//得到标题的高度", "let", "titleHeight", "=", "res.height", "//scroll-view的高度", "=", "屏幕高度-", "tab高(50)", "-", "10", "-", "10", "-", "titleHeight", "//获取屏幕可用高度", "let", "screenHeight", "=", "wx.getSystemInfoSync().windowHeight", "//计算", "scroll-view", "的高度", "let", "scrollHeight", "=", "screenHeight", "-", "titleHeight", "-", "70", "that.setData({", "scrollHeight:", "scrollHeight", "})", "}).exec()", "},", "复制代码这里主要是通过小程序封装的", "API", "来计算的。wx.getSystemInfoSync()", "可以得到设备的各种信息，关于高度的参数有两个，一个是屏幕高度", "screenHeight", "，一个是可使用窗口高度", "windowHeight", "。注意计算的时候要用", "windowHeight", "，这样算出来的高度才是对的。", "screenHeight", "是手机的屏幕高度，包含了手机的状态栏和小程序标题栏。有了可用屏幕高度，还需要元素的高度。计算元素高度小程序也提供了", "API，参见WXML节点信息API。具体用法看文档就好了，精简的使用步骤就是：let", "query", "=", "wx.createSelectorQuery().in(this)", "query.select('.title').boundingClientRect(function(res)", "{", "//在这里做计算，res里有需要的数据", "}).exec()", "复制代码注意在组件", "component", "里使用的话，要用", "wx.createSelectorQuery().in(this)", "，将选择器的选取范围更改为自定义组件component内。（初始时，选择器仅选取页面范围的节点，不会选取任何自定义组件中的节点。）如果想同时测量多个节点的高度呢？2.2", "计算多个节点高度能计算单个当然也能同时计算多个。如下：computeScrollViewHeight()", "{", "let", "that", "=", "this", "let", "query", "=", "wx.createSelectorQuery().in(this)", "query.select('.search').boundingClientRect()", "query.select('.title-wrapper').boundingClientRect()", "query.exec(res", "=>", "{", "let", "searchHeight", "=", "res[0].height", "let", "titleHeight", "=", "res[1].height", "let", "windowHeight", "=", "wx.getSystemInfoSync().windowHeight", "let", "scrollHeight", "=", "windowHeight", "-", "searchHeight", "-", "titleHeight", "-", "30", "-", "5", "-", "50", "this.setData({", "scrollHeight:", "scrollHeight})", "})", "},", "复制代码有几个节点就写几个", "query.select('.search').boundingClientRect()", "，", "然后调用", "query.exec()", "执行操作获取节点信息的数组。注意：调用封装好的", "computeScrollViewHeight()", "的时机是在生命周期函数的", "ready()", "中，不能在", "created()", "，否则取不到数据。参见Component构造器三、在", "wxml", "使用计算的结果计算完成后如何使用呢？<scroll-view", "scroll-y", "style='height:", "{{scrollHeight", "+", "\"px\"}}'></<scroll-view>", "复制代码通过上面的方法使用。注意：一定要在变量后面加上单位", "px", "，不加的话会出错。以上就是精确计算微信小程序scrollview高度的方法，从此再也不担心", "scroll-view", "高度错乱了！"]}
{"author": "Rolan", "title": "手把手教你搭建小程序音视频 ", "content": ["欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~本文由腾讯视频云终端团队", "发表于云+社区专栏Demo", "体验升级微信到最新版本，发现页卡", "=>", "小程序", "=>", "搜索“腾讯视频云”，即可打开小程序Demo：注册小程序并开通相关接口出于政策和合规的考虑，微信暂时没有放开所有小程序对", "<live-pusher>", "和", "<live-player>", "标签的支持：个人账号和企业账号的小程序暂时只开放如下表格中的类目：主类目子类目", "【社交】直播【教育】在线教育【医疗】互联网医院，公立医院【政务民生】所有二级类目【金融】基金、信托、保险、银行、证券/期货、非金融机构自营小额贷款、征信业务、消费金融打开微信公众平台", "注册并登录小程序，并在小程序管理后台的<font", "color='red'>", "“设置", "-", "接口设置”", "</font>中自助开通该组件权限，如下图所示：注意：如果以上设置都正确，但小程序依然不能正常工作，可能是微信内部的缓存没更新，请删除小程序并重启微信后，再进行尝试。安装微信小程序开发工具下载并安装最新版本的微信开发者工具，使用小程序绑定的微信号扫码登录开发者工具。获取Demo源码并调试step1:", "访问SDK", "+", "Demo，获取小程序", "Demo", "源码。step2:", "打开安装的微信开发者工具，点击【小程序项目】按钮。step3:", "输入小程序", "AppID，项目目录选择上一步下载下来的代码目录（", "注意：", "目录请选择", "根目录", "，根目录包含有", "project.config.json", "文件，请不要只选择", "wxlite", "目录！），点击确定创建小程序项目。step4:", "再次点击【确定】进入开发者工具。step5:", "请使用手机进行测试，直接扫描开发者工具预览生成的二维码进入。step6:", "<font", "color='red'>开启调试模式</font>，体验和调试内部功能。开启调试可以跳过把这些域名加入小程序白名单的工作。Demo访问的测试地址Demo小程序会访问如下表格中的测试服务器地址，这些服务器使用的云服务是我们为大家提供的一个体验账号，平时很多客户都会在上面做测试。如果您希望使用自己的后台服务器，以免被其他客户打扰，请关注文档后一节内容：<live-room>", "和", "<rtc-room>", "相关demo需要访问如下地址：<webrtc-room>", "相关demo需要访问如下地址：搭建自己的账号和后台服务器这部分我们将介绍如何将Demo默认的测试用服务器地址，换成您自己的服务器，这样一来，您就可以使用自己的腾讯云账号实现上述功能，同时也便于您进行二次开发。1.", "搭建", "<webrtc-room>", "的服务器1.1", "这个服务器能做什么？点击demo里的互动课堂", "<webrtc-room>", "功能，您会看到一个房间列表，这个房间列表是怎么实现的呢？在看到视频房间列表以后，如果你要创建一个视频房间，或者进入一个其他人建好的视频房间，就需要为", "所对应的几个属性（", "sdkAppID", "、", "userID", "、", "userSig", "、", "roomID", "和", "privateMapKey", "）传递合法的参数值，这几个参数值怎么获取呢？1.2", "这个服务器要怎么搭建？下载", "webrtc_server", "，这是一份", "java", "版本的实现，根据", "README.md", "中的说明就可以了解怎么使用这份源码。1.3", "服务器建好了我怎么用？小程序", "源码中，将", "wxlite/config.js", "文件中的", "webrtcServerUrl", "修改成：https://您自己的域名/webrtc/weapp/webrtc_room小程序实现", "WebRTC", "能力肯定是为了跟", "Chrome", "浏览器进行视频通话，浏览器端的源代码可以点击", "Chrome(src)", "下载到，将", "component/WebRTCRoom.js", "文件中的", "serverDomain", "修改成：https://您自己的域名/webrtc/weapp/webrtc_room2.", "搭建", "<live-room>", "和", "<rtc-room>", "的服务器2.1", "这个服务器能做什么？（用于直播连麦）和", "（用于视频通话）都是基于腾讯云", "LVB", "和", "IM", "两个基础服务实现的扩展功能，需要一个叫做", "RoomService", "的后台组件配合才能运行。2.2", "这个服务器要怎么搭建？下载", "RoomService", "的", "java", "版本源代码，根据", "README.md", "中的说明就可以了解怎么使用这份源码。2.3", "服务器建好了我怎么用？小程序", "源码中，将", "wxlite/config.js", "文件中的", "serverUrl", "和", "roomServiceUrl", "修改成：https://您自己的域名/roomservice/小程序如果使用", "<live-room>", "和", "<rtc-room>", "两个标签，在", "PC", "端就不能用", "Chrome", "浏览器配对了，需要改用WebEXE", "混合解决方案。将", "GitHub(WebEXE)", "源码中", "liveroom.html、double.html文件中的", "RoomServerDomain", "修改成:https://您自己的域名/roomservice/3.", "Wafer", "零成本服务器部署方案", "（Node.js）如果您是一位资深的", "Web", "前端工程师，暂时找不到合适的服务器，但又想快速拥有自己的调试后台，可以使用腾讯云的", "Wafer", "功能进行零成本的一键部署方案（Wafer", "只支持", "Node.js", "语言的后台代码），您需要你做的只是：step1:", "下载", "小程序", "源码。step2:", "根据", "一键部署指引", "完成部署。step3:", "将", "GitHub(WebEXE)", "源码中", "liveroom.html、double.html文件中的", "RoomServerDomain修改成:https://您自己的域名/roomservice/"]}
{"author": "Rolan", "title": "微信小游戏好友排行榜快速开发教程 ", "content": ["要做这个好友排行榜.必然要有好友的战绩比分,然后再做排序,最后将数据呈现在UI上", ",", "可以分为下面几个步骤:保存每个用户的分数获取好友列表,并获取好友的分数渲染排行榜保存每个用户的分数保存每个用户的分数,需要调用微信的云存储API,将用户的分数持久化的存起来", ".//", "保存用户数据,注意限制单条数据容量不得超过1024字节,", "//", "单个用户数据总条数不得超过128条", "wx.setUserCloudStroage(Object)复制代码//存储最高分", "var", "score", "=", "100;", "var", "kvScore", "=", "{\"key\":\"score\",\"value\":score};", "wx.setUserCloudStroage({\"KVDataList\":[kvScore]},\"success\":function(){", "//", "});复制代码获取好友列表,并获取好友的分数​", "游戏中将玩家的分数保存起来以后,需要调用微信的云存储API", "wx.getFirendCloudStorage,", "获取玩家的微信好友数据,这样就拿到了每个好友的最高分.值得一提的是,微信的这个接口在内部隐蔽的使用其微信的社交关系链", ".返回列表中的包含的", "调用过wx.setUserCloudStroage", "这个接口的用户.渲染排行榜对分数进行排序", ",", "得到一个排行榜let", "sharedCanvas", "=", "wx.getSharedCanvas()", "function", "drawRankList", "(data)", "{", "data.forEach((item,", "index)", "=>", "{", "//", "...", "})", "}", "wx.getFriendCloudStorage({", "success:", "res", "=>", "{", "let", "data", "=", "res.data", "drawRankList(data)", "}", "})复制代码注意这个", "sharedCanvas", ",", "这是独有的画布", ",与小游戏中的画布不是同一个东东.使用sharedCanvas来自定义显示玩家的用户排行榜重要说明​", "上述所涉及的微信接口", ",", "都只能在微信小游戏的", "子域", "使用", ",", "微信官网也称之为开放数据域", ",", "其实应该称之为", "封闭数据域", ".", "​", "为什么这么说呢?​", "因为子域的js代码执行环境和小游戏本身的代码执行环境是隔离的.", "两者之间不能相通", ",", "子域只能接收外部的消息(如游戏的最高分),不能往外发消息(不能把用户的好友关系链数据发给开发者服务器)", ",", "内存不共享,也就意味着,开发者拿不到微信的社交关系链数据", ".", "在这样的封闭条件下,开发者能做的只能是在子域的画布上将排行榜数据以个性化的UI元素展示出来", "。"]}
{"author": "admin", "title": "微信小程序开发教程第五章：名片夹详情页开发 ", "content": ["先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay", "自动播放，interval", "轮播的时间，duration", "切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg", "与", "ClickImg：切换全屏与非全屏轮播图，绑定了点击事件", "changeClick", "来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播", "index（currentNumber），与图片", "length", "集合（cardnum）。其中", "currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var", "number", "=", "e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后", "getBackStyle，把", "changeClick", "切换到", "imgFullScrenn", "待命。再次点击返回原样式，切换后事件又走回到", "getBackStyle", "了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环", "block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息", "var", "chinaMessage", "=", "res.card.groups[0].fields;var", "personMessage=", "[]", "for(var", "i", "=", "0;i", "personMessage.push(chinaMessage[i])", "}", "//为空或者null是不显示判断", "for(var", "k", "in", "personMessage){", "if(personMessage[k].value==null", "||", "personMessage[k].value==\"\"){", "personMessage[k][\"display\"]", "=", "\"none\";", "}else{", "personMessage[k][\"display\"]", "=", "\"block\";", "}", "}具体以", "json", "数据格式来处理，我们需要做的就是给它绑定", "display", "的值，然后我们调用即可。微信此版本的", "setData", "不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上", "forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的", "bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是", "js", "的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是", "push", "上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的", "demo", "有实现方式）。可以看下实现的效果："]}
{"author": "admin", "title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "content": ["效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件", "swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical", "加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是", "nextSlide：再看下", "nextSlide", "事件。currentSlide", "是当前页面的", "index，改变它即可完成切换效果，可以看上图初始化数据时设置了", "cs", "是", "0。因而赋值当前", "data.cs+1", "即可，再把绑定点击事件", "clickNext", "切换成", "nextSlideAgain。再看下", "nextSlideAgain", "事件，执行的减去", "1", "个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是", "wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是", "MD5", "加密，requster", "交互层。怎么引用", "MD5.js？当然是模块化", "require，被引用的", "js", "不要忘记", "module.exports", "出来。下面是", "requester.js", "引用", "MD5.js。ApplicationRoot", "是服务器地址（配置服务器时在开发设置页面查看", "AppID", "和", "AppSecret，配置服务器域名）。Require.js", "这里", "module.exports", "是暴露方法出去。这时候在全局", "app.js", "里面引入", "require.js", "映射到全局", "global，这个", "global", "是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是", "requester.js", "里面的封装。图二是需要调用数据的页面渲染。"]}
{"author": "admin", "title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "content": ["序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1.", "获取微信小程序的", "AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的", "AppID。", "利用提供的帐号，登录", "https://mp.weixin.qq.com", "，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的", "AppID", "了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份", "-", "开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2.", "创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的", "AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个", "quick", "start", "项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的", "demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3.", "编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是", "app.js、app.json、app.wxss", "这三个。其中，.js", "后缀的是脚本文件，.json", "后缀的文件是配置文件，.wxss", "后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js", "是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用", "MINA", "提供的丰富的", "API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch:", "function", "()", "{//", "调用", "API", "从本地缓存中获取数据var", "logs", "=", "wx.getStorageSync('logs')", "||", "[]logs.unshift(Date.now())wx.setStorageSync('logs',", "logs)},getUserInfo:function(cb){var", "that", "=", "this;if(this.globalData.userInfo){typeof", "cb", "==", "\"function\"", "&&", "cb(this.globalData.userInfo)}else{//", "调用登录接口wx.login({success:", "function", "()", "{wx.getUserInfo({success:", "function", "(res)", "{that.globalData.userInfo", "=", "res.userInfo;typeof", "cb", "==", "\"function\"", "&&", "cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json", "是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口", "背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\":", "\"#fff\",\"navigationBarTitleText\":", "\"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss", "是整个小程序的公共样式表。我们可以在页面组件的", "class", "属性上直接使用", "app.wxss", "中声明的样式规则。```/**app.wxss**/.container", "{height:", "100%;display:", "flex;flex-direction:", "column;align-items:", "center;justify-content:", "space-between;padding:", "200rpx", "0;box-sizing:", "border-box;}```###", "4.", "创建页面在这个教程里，我们有两个页面，index", "页面和", "logs", "页面，即欢迎页和小程序启动日志的展示页，他们都在", "pages", "目录下。微信小程序中的每一个页面的【路径", "+", "页面名】都需要写在", "app.json", "的", "pages", "中，且", "pages", "中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js", "后缀的文件是脚本文件，.json", "后缀的文件是配置文件，.wxss", "后缀的是样式表文件，.wxml", "后缀的文件是页面结构文件。index.wxml", "是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了", "、、", "来搭建页面结构，绑定数据和交互处理函数。index.js", "是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js//", "获取应用实例var", "app", "=", "getApp()Page({data:", "{motto:", "'Hello", "World',userInfo:", "{}},//", "事件处理函数bindViewTap:", "function()", "{wx.navigateTo({url:", "'../logs/logs'})},onLoad:", "function", "()", "{console.log('onLoad')var", "that", "=", "this//", "调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){//", "更新数据that.setData({userInfo:userInfo})})}})```index.wxss", "是页面的样式表：```/**index.wxss**/.userinfo", "{display:", "flex;flex-direction:", "column;align-items:", "center;}.userinfo-avatar", "{width:", "128rpx;height:", "128rpx;margin:", "20rpx;border-radius:", "50%;}.userinfo-nickname", "{color:", "#aaa;}.usermotto", "{margin-top:", "200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖", "app.wxss", "中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用", "app.wxss", "中指定的样式规则。index.json", "是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖", "app.json", "的", "window", "中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用", "app.json", "中的默认配置。**logs", "的页面结构**```{{index", "+", "1}}.", "{{log}}```logs", "页面使用", "控制标签来组织代码，在", "上使用", "wx:for-items", "绑定", "logs", "数据，并将", "logs", "数据循环展开节点//logs.jsvar", "util", "=", "require('../../utils/util.js')Page({data:", "{logs:", "[]},onLoad:", "function", "()", "{this.setData({logs:", "(wx.getStorageSync('logs')", "||", "[]).map(function", "(log)", "{return", "util.formatTime(new", "Date(log))})})}})运行结果如下：5.", "手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。*", "下载最新微信开发者工具，打开后你会看到该界面：*", "点击「新建", "web+」项目，随后出现如下画面：*", "该页面内的各项内容需要注意——*", "AppID：依照官方解释来填。*", "Appname:", "项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。*", "本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。*", "准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。*", "如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的", "demo", "项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："]}
{"author": "admin", "title": "微信小程序开发教程第二章：项目构架 ", "content": ["微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着", "h5", "的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作", "DOM", "转为操作数据，基于微信提供的一个过桥工具实现很多", "h5", "在公众号很难实现的功能，有点类似于", "hybrid", "开发，不同于", "hybrid", "开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作", "DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上", "Console", "可以看到：在首页", "console", "可以看出顺序是", "App", "Launch-->App", "Show-->onload-->onShow-->onReady。首先是整个", "app", "的启动与显示，app", "的启动在", "app.js", "里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。*", "wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。*", "wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。*", "wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的", "js", "插件也很难使用，因为以前我们的", "js", "插件也基本上全部是一操作", "dom", "的形式存在，而微信应用号此次的架构是不允许操作任何", "dom，就连以前我们习惯使用的动态设置的", "rem.js", "也是不支持的。此次微信还提供了", "WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！*", "找到项目文件夹，导入你的编辑器里面。在这里，我使用了", "Sublime", "Text", "编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。*", "接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。*", "示例项目的「tabBar」是五个菜单按钮：*", "找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：*", "你可以根据实际项目需求更改，其中：*", "「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。*", "「“list”」下的代码顺序必须依次放置，不能随便更改。*", "「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。*", "「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。*", "「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。*", "「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个", "icons），所以在你设计微信应用的", "UI", "和基本架构时就要预先考虑好菜单栏的排布。*", "根据以上代码规则，我做好了示例项目的基本架构，供你参考：*", "「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。*", "以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。*", "「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：*", "修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接", "F5", "刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。*", "另外，公共样式可以在「app.wxss」里直接引用。*", "「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"]}
{"author": "admin", "title": "微信小程序开发教程第三章：项目结构以及配置 ", "content": ["找到创建的", "demo", "文件夹，把项目导入到你的编辑器，这里使用的是Sublime", "Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个", "tabBar", "页面，以及", "app", "的一些配置文件，如名片盒项目的", "tabBar", "是", "3", "个切换菜单我们先找到", "app.json", "文件打开配置好这几个菜单，配置好", "tabBar，这个直接把配置文件改成你自己设计的即可。App.json", "里面有几个配置项：*", "Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报", "page", "错误）。*", "Window：配置顶部的一些样式，文档介绍比较详细。*", "tabBar：底部的几项配置，见名知意。*", "networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。*", "iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。*", "text：可以去掉，全部去掉会发现底部", "tabar", "高度会减少很多。", "Json", "文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持", "require，假数据使用的是", ".js", "文件形式，里面的数据结构", "json", "一致，把", "data", "暴露出去即可然后取数据", "require", "进来即可，这一点使用很方便；Images：图片路径；Page：除", "tabar", "以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的", "css", "文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js", "目前只能依照这样，是微信应用号的一个规范吧。Wxss", "文件是引入你写的样式文件，也可以直接在里面写样式。Js", "文件需全部配置到", "pages", "里面才能生效。"]}
{"author": "admin", "title": "微信小程序开发教程第四章：首页面开发 ", "content": ["进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template", "名片很多，需要用模板、这里需要微信提供的基础组件大致是", "input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view", "(右边", "ABC", "跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。*", "名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以", "template", "分离出来。*", "Template：定义一个模板，name", "模板的名字其实是个作用域。*", "Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。*", "支持自定义属性", "data，这里用作判断线上名片以及线下名片。*", "View", "里面是一些数据引入，里面是支持三目运算符。引入", "template", "时非常方便，is", "和", "name", "一样，data", "是", "nameData", "传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和", "json", "数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是", "nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的", "json", "数据格式来操作的）名片的样式由于很多页面需要使用放在", "common.css", "里面，这个", "common.css", "是所有页面都需要用到，一些初始化设置。它是在", "app.wxss", "里面引用之后才能被映射到全局", "APP。搜索框：其中", "bindChange", "为输入框发生改变事件。微信提供的", "bindchange", "在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在", "index.js", "里面写事件```bindInputChange:function(e){//发生搜索事情var", "self", "=", "this;", "//this绑定，这个this指向微信的提供windowvar", "Text", "=", "e.detail.value.toUpperCase();", "//取到输入的内容if(Text==\"\"){", "//如果输入为空", "一些东西需要显示", "否则不显示show_letter", "=", "\"block\";}else{show_letter", "=", "\"none\";}this.setData({show_letter:show_letter,showSheet:true});var", "res", "=", "nameData;", "获取到传递的数据if(data_type==\"name\"){}else", "if(data_type==\"time\"){res", "=", "timeData;", "};for(var", "k", "in", "res){", "//for-in循环取到data里面的cardsvar", "data", "=", "res[k].cards;for(var", "i", "=", "0;iIf(data[i].userName!=null", "&&", "data[i].userName.indexOf(Text)!=-1){data[i][\"display\"]", "=", "\"block\";", "//存在就是赋值显示}else{data[i][\"display\"]", "=", "\"none\";", "//", "不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件", "action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js", "配置：Data", "初始化数据：这里得取非，直接设置", "false", "调不出来:", "调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个", "loading", "效果（暂时没做动画，后期再考虑。）Loading", "布局首页的最外层", "view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照", "api", "使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom", "长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的", "ABC", "跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"]}
{"author": "admin", "title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "content": ["整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时", "bindinput", "事件，大家别使用", "bindchange", "事件，这里的", "bindchange", "事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了", "from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件", "bindtouchstart", "与", "bindtouchmove，这里必须绑定它的", "id，这个", "id", "都是不同的，我这使用的用户创建完成后在后台生成的一个", "id", "号，之后我再", "block", "出来使用在这里，这个", "id", "都是唯一的，不能是相同的", "id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了", "css3", "的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap", "点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart", "发生后，会执行", "bindtouchmove", "事件，在这里我们可以判断是否左右滑动：*", "Var", "dataId", "=", "e.currentTarget.id", "//获取到前面唯一的id；If(key){", "//用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；*", "Touch是获取触摸点的一些数据，touches", "是一个触摸点的数组，每个触摸点包括以下属性：*", "pageX,pageY：距离文档左上角的距离，文档的左上角为原点", "，横向为", "X", "轴，纵向为", "Y", "轴；*", "clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；*", "screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用", "clientX,clientY", "即可。我们在", "bindtouchstart", "时记录到开始的点，在", "bindtouchmove", "记录到触摸结束的点，如果", "X", "轴滑动大于", "Y", "轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在", "wxml", "里面", "block", "的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的", "id==", "当前被事件操作的", "id，那么我给改数组再添加一个", "right", "向右偏移", "15%，否则其他都不偏移，右滑同理，直接全部设置为", "0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X", "轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个", "catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在", "data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是", "copy", "首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给", "checked", "设置", "Boole", "开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是", "from", "表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"]}
{"author": "天下雪", "title": "微信小程序试用报告：前端源码逻辑和工作流 ", "content": ["文件基本结构：", "先看入口app.js，app(obj)注册一个小程序。接受一个", "object", "参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({", "onLaunch:", "function", "()", "{", "//调用API从本地缓存中获取数据", "var", "logs", "=", "wx.getStorageSync('logs')", "||", "[]", "logs.unshift(Date.now())", "wx.setStorageSync('logs',", "logs)", "},", "getUserInfo:function(cb){", "var", "that", "=", "this", "if(this.globalData.userInfo){", "typeof", "cb", "==", "\"function\"", "&&", "cb(this.globalData.userInfo)", "}else{", "//调用登录接口", "wx.login({", "success:", "function", "()", "{", "wx.getUserInfo({", "success:", "function", "(res)", "{", "that.globalData.userInfo", "=", "res.userInfo", "typeof", "cb", "==", "\"function\"", "&&", "cb(that.globalData.userInfo)", "}", "})", "}", "})", "}", "},", "globalData:{", "userInfo:null", "}})", "我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性", "onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。", "var", "logs", "=", "wx.getStorageSync('logs')", "||", "[]获取本地缓存中的logs属性，如果值为空，那么设置logs=[]", "与HTML5中的localStorage作用相似logs.unshift(Date.now())", "当前登录时间添加到数组中", "wx.setStorageSync('logs',", "logs)", "将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据", "getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数", "var", "that", "=", "this", "if(this.globalData.userInfo){//用户信息不为空", "typeof", "cb", "==", "\"function\"", "&&", "cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；", "}else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。", "wx.login({", "success:", "function", "()", "{", "wx.getUserInfo({", "success:", "function", "(res)", "{", "console.log(res)", "that.globalData.userInfo", "=", "res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口", "typeof", "cb", "==", "\"function\"", "&&", "cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息", "}", "})", "}", "})", "}", "}", "globalData对象用来存储全局数据，在其他地方调用", "然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多", "tab", "等、", "最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。", "{", "\"pages\":[", "\"pages/index/index\",", "\"pages/logs/logs\"", "],", "\"window\":{", "\"backgroundTextStyle\":\"light\",", "\"navigationBarBackgroundColor\":", "\"#fff\",", "\"navigationBarTitleText\":", "\"WeChat\",", "\"navigationBarTextStyle\":\"black\"", "}}", "然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。", "先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。", "index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。", "<!--index.wxml--><view", "class=\"container\">//视图容器", "<view", "bindtap=\"bindViewTap\"", "class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js", "page()设置添加", "<image", "class=\"userinfo-avatar\"", "src=\"{{userInfo.avatarUrl}}\"", "background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的", "<text", "class=\"userinfo-nickname\">{{userInfo.nickName}}</text>", "</view>", "<view", "class=\"usermotto\">", "<text", "class=\"user-motto\">{{motto}}</text>", "</view></view>", "index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个", "OBJECT", "参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var", "app", "=", "getApp()", "//", "获取入口文件app的应用实例Page({", "data:", "{", "motto:", "'Hello", "World',", "userInfo:", "{}", "},", "//自定义事件处理函数，点击.userinfo的容易触发此函数", "bindViewTap:", "function()", "{", "wx.navigateTo({//全局对象wx的跳转页面方法", "url:", "'../logs/logs'", "})", "},", "onLoad:", "function", "()", "{//发生页面加载时，自动触发该生命周期函数", "console.log('onLoad')", "var", "that", "=", "this", "//调用应用实例的方法获取全局数据", "app.getUserInfo(function(userInfo){", "//更新数据，页面自动渲染", "that.setData({", "userInfo:userInfo", "})", "})", "}})", "index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。", "再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。", "logs.wxml文件<!--logs.wxml--><view", "class=\"container", "log-list\">", "<block", "wx:for=\"{{logs}}\"", "wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>", "<text", "class=\"log-item\">{{index", "+", "1}}.", "{{log}}</text>", "</block></view>", "logs.js", "文件//logs.jsvar", "util", "=", "require('../../utils/util.js')", "//util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({", "data:", "{", "logs:", "[]", "},", "onLoad:", "function", "()", "{", "this.setData({", "logs:", "(wx.getStorageSync('logs')", "||", "[]).map(function", "(log)", "{//通过wx.getStorageSync获取本地缓存的logs日志数据", "return", "util.formatTime(new", "Date(log))//日期格式化", "})", "})", "}})", "logs.json文件{", "\"navigationBarTitleText\":", "\"查看启动日志\"", "//当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}", "基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"]}
{"author": "天下雪", "title": "微信小程序教程：app配置指南 ", "content": ["//app.json页面", "{//页面注册，有几个页面都要在pages里面注册\"pages\":[\"pages/index/index\",\"pages/logs/logs\",\"pages/main/main\",\"pages/main1/main1\",\"pages/main2/main2\",\"pages/main3/main3\",],//上导航配置及app背景颜色设置\"window\":{//是否开启下拉刷新\"enablePullDownRefresh\":true,//窗口背景颜色，在上拉刷新，下拉刷新，navigate切换页面时可以看见\"backgroundColor\":\"#eee\",//下拉背景字体、loading", "图的样式，仅支持", "dark/light,（string形式）\"backgroundTextStyle\":\"light\",//上导航条背景颜色\"navigationBarBackgroundColor\":", "\"orange\",//上导航标题文字\"navigationBarTitleText\":", "\"上导航标题文字\",\"navigationBarTextStyle\":\"white\"", "//上导航标题字体颜色，仅支持white和black", "},//底部导航配置\"tabBar\":", "{\"color\":", "\"#a9b7b7\",//导航字体默认颜色\"selectedColor\":", "\"#eb4f38\",//导航字体选中时颜色\"borderStyle\":", "\"black\",", "//上border颜色，仅支持", "black/white（string形式）\"backgroundColor\":", "\"rgba(0,0,0,0.4)\",//底部导航背景色\"list\":", "[", "//导航列表2-5个{\"pagePath\":", "\"pages/index1/index1\",", "//每个导航的网页对应的路径\"text\":", "\"首页\",", "//标题\"iconPath\":", "\"images/wechat.png\",", "//默认小图标路径\"selectedIconPath\":", "\"images/wechatHL.png\"", "//选中时的小图标路径},{\"pagePath\":", "\"pages/index2/index2\",\"text\":", "\"日记\",\"iconPath\":", "\"images/pause.png\",\"selectedIconPath\":", "\"images/play.png\"},{\"pagePath\":", "\"pages/index3/index3\",\"text\":", "\"指南\",\"iconPath\":", "\"images/pause.png\",\"selectedIconPath\":", "\"images/play.png\"},]},//网络请求超时时间\"networkTimeout\":", "{\"request\":", "10000,\"downloadFile\":", "9000,\"uploadFile\":8000,\"connectSocket\":7000},//是否开启debug模式\"debug\":", "true}//说明：根据官方文档，上述color和bg-color类型为HexColor即16进制类型，（指定仅支持", "black/white，string形式的除外），但实测rbg,rgba和red这些类型目前也支持，但是建议大家还是按文档要求来设置为16进制类型即:", "#ffffff", "类型；////使用时仅需将文件复制下来，根据需求改动即可；////app.json为标准的json文件，所以不能存在有注释，使用的时候需把注释去掉；", "//app.js页面App({//当小程序初始化完成时，会触发", "onLaunch（全局只触发一次）onLaunch:", "function", "()", "{//onLaunch时调用API从本地缓存中获取数据var", "logs", "=", "wx.getStorageSync('logs')", "||", "[]logs.unshift(Date.now())wx.setStorageSync('logs',", "logs)},//获取用户登录信息getUserInfo:function(cb){var", "that", "=", "thisif(this.globalData.userInfo){typeof", "cb", "==", "\"function\"", "&&", "cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success:", "function", "()", "{wx.getUserInfo({success:", "function", "(res)", "{that.globalData.userInfo", "=", "res.userInfotypeof", "cb", "==", "\"function\"", "&&", "cb(that.globalData.userInfo)}})}})}},//获取后台数据onshow:function(){wx.request({url:", "'test.php',data:", "{x:", "'xxx',y:", "'yyy'},header:", "{'Content-Type':", "'application/json'},success:", "function(res)", "{console.log(res.data)}})},//设置全局数据//本页面通过this.globalData即可取得数据", "globalData:{userInfo:null}//其他页面可以通过getApp()获取到小程序实例", "//其他页面可以通过getApp().globalData.xxx获取到全局数据})", "//app.wxss页面.common", "{height:", "100%;display:", "flex;flex-direction:", "column;align-items:", "center;justify-content:", "space-between;padding:", "200rpx", "0;box-sizing:", "border-box;}//仅支持:类:.commonID:#common标签：common多个标签：common1,common2", "伪类::after伪类::before//不支持层级，如.common", ">", "view", "或者.common", "view//引入新的单位rpx:rpx（responsive", "pixel）:", "可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在", "iPhone6", "上，屏幕宽度为375px，共有750个物理像素，则750rpx", "=", "375px", "=", "750物理像素，1rpx", "=", "0.5px", "=", "1物理像素。及新的rem:rem（root", "em）:", "规定屏幕宽度为20rem；1rem", "=", "(750/20)rpx", "。//写在app.wxss里面的样式将被设置为公有的，对于其他页面都是可用的"]}
{"author": "天下雪", "title": "微信小程序官方文档里看不到的小Tips ", "content": ["1.", "WXML(HTML)", "1.1", "小程序的WXML没有HTML的宽容度?那么高，单标签必需是", "/>", "结尾的。不然会报错。", "1.2", "官方推荐使用的基础标签是块标签，给了作为文本标签，但是使用其他标签比如div也是可以使用的，并且都是inline标签。并且wxml的parser会把标签上的不在白名单上的属性都去掉，class,", "id,", "data", "这些应该都在白名单内，但是href什么的是不会有的，所以如果你用传统的html的标签构建页面理论上也是可行的，不过这些都是inline标签，需要自行设定display。", "1.3", "scroll-view", "的scroll-top,", "scroll-left", "是可以修改scroll-view的滚动位置的。但是用户自己滚动了之后小程序并不会去改变", "scroll-top,", "scroll-left", "的赋值（并不是双向同步的）。如果这时使用setData去修改的话，scroll-top,", "scroll-left", "的赋值和上一次的值相同，小程序是不会运用这个修改的，所以表现就是设置没有生效。这时只能先设置一个其他值，再设置回去（这里还可以体现setData方法是同步的）。scroll-view", "获取scroll位置，只能通过bindscroll的回调函数获取，所以需要取scroll位置的请自行预存好。scroll-view", "还是有webview的", "scroll", "的臭毛病，在居顶位置如果第一个动作是向下滚动的，会导致之后手怎么滑都滚不动，设置scroll-top", "不为0，设个1就好了。", "1.4", "input", "目前只支持文字居左，其他都是不行的（模拟器可以）。如果你做表单，建议把input等表单元素都放在form中，from触发submit时会返回内部所有表单元素的name-value。不然只能绑定所有表单元素的", "change", "事情来获取，甚是麻烦。", "1.5", "只有", "checkbox-group", "有", "change", "事件，单个的checkbox是没有的，如果你只有一个checkbox，", "觉得外面套一个checkbox-group麻烦又不美观的话，可以用", "switch", "type=\"checkbox\"", "代替。", "1.6", "map", "组建目前直接在app第一个页面加载会出现加载失败。需要在onLoad之后再加在。可以先wx:if=\"false\"", "然后onLoad的之后改成", "true", "就行了。", "1.7", "map,", "canvas", "像是在webview上面盖一个native组件的感觉。它们是没法被overflow", "以及", "上面盖元素的，你可以认为z-index写多高都没法在他上面。所以不建议在页面上做弹层和蒙层。canvas", "无法放在scroll-view中滚动会定位在初始位置，如果你给canvas设置背景颜色的话，你会发现背景色块跟着滚了，图没滚。2.", "WXSS(CSS)", "2.1", "WXSS", "和", "CSS很像，基本所有的CSS都支持，小程序还提供了", "rpx", "这个单位。一屏幕宽是750rpx。推荐使用这个来作为布局。不过有一些细小的差别我下面会列出", "2.2", "WXSS不支持", "大括号嵌套（{{}}", "）。所以key-frames，CSS", "animation", "就不可用了，不过transition", "是可用的。", "2.3", "目前测试引入字体也是不可用的，前面WXML中提到的内容看SVG也是没法使用的。所以icon目前只能用图的方式做了。", "2.4", "WXSS中是不能引入本地资源的,", "只能使用线上资源（模拟器是可以，但是别信），可以使用base64。", "2.5", "WXSS的", "rule", "是不支持集联的。所以不能", "body", ".main", "{background:#000;}", "这么写。所以写起来还是比较费劲的。每个class都得很长，不然怕重名。不过支持", "li.current", "{color:", "red;}", "这样的写法，支持after，", "before伪类，但是不支持", "first-child", "last-child", "nth-child", "这类伪类。", "2.6", "app.wxss", "和每个", "page", "的wxss", "的覆盖关系是:", "如果有同名", "rule", "的话，page", "会覆盖", "app", "的，不是merge是覆盖。", "3.", "JS", "3.1", "JS", "的运行环境和view的运行环境是隔离的。JS只能通过事件获取时机和setData方法修改数据来改变view。", "3.2", "JS", "目前有个很大的问题是无法获取到页面px级的宽度高度,", "所有事件回调的单位都是px级的而不是rpx的，但是又不知道当前rpx，px的转换关系。比如过你用canvas画图。你都不知道边界在哪里，这个很蛋疼。", "3.3", "上面有说过", "setData方法如果上一个值和下一个值相同时，是不会触发view修改的（见1.3）", "3.4", "使用", "navigate", "跳转的时候可以使用queryString的方式跟在相对地址上，onLoad事件会在入参中传入（会转化成object），但是", "navigate", "back的时候没有一个官方给出的数据通讯机制。可以使用getApp()", "获取到全局对象，给上面加点东西，自行实现。navigate", "最多5个什么的就不说了。", "3.5", "canvas", "getActions被调用之后，actions是会被清空的。即连续调用两次getActions，第二次是空数组。", "3.6", "开发者工具是nw写的，我就看了看裙底的源码，开发者工具中WXML确实是有parser再拼装的过程的。但是并不能说明小工具是native的，从css的支持力度到webview的一些bug相似度来看，我还是觉得像webview，但是组件比如map，canvas什么的用的是原生view，然后盖在webview上的感觉。但是不管怎么说", "auto-focus", "能自动呼出键盘就已经是个很大的好评了。"]}
{"author": "天下雪", "title": "微信小程序开发准备：必修课程推荐 ", "content": ["今天，我们都想学前端！！！1、HTML基础入门带你从最最基础的知识开始，认识", "HTML，通过", "HTML", "文件的结构、常用的标签、元素、属性、样式、超文本等内容让大家对", "HTML", "有一个完整的认识！2、HTML5基础入门HTML5有很多新特性，这个教程就带你入门了解HTML5的一些新特性。我们知道啊：html是结构", "（网页一个架子，显示内容）、css是样式（添加背景图片，边框等来修饰）、js是行为（用户操作，华丽的动画）所以呢，光学HTML肯定是不够滴，还需要学习css和js才行啊。3、CSS速成教程这个教程啊，就是带你入门学习CSS知识的，让你对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。4、Javascript基础这个教程呢，是教你学习", "JavaScript", "的语法及事件、对象、DOM", "等基础知识，可以让网页按照你的想法“动”起来。以上呢，是基础，基础打牢了才能动手开发呀，但是，光有理论基础是不够的，还需要在实际开发“小程序”之前，做一些项目，练练手，把所学到的基础知识加以运用！5、HTML5两步实现拼图游戏这个项目就是教你使用HTML5和css3实现的九宫格拼图游戏。做出来是这样的：6、SCSS（SASS）画小黄人这个项目呢，教你通过", "SCSS（SASS）画一个会眨眼睛的小黄人，主要学习", "CSS3。画出来是这样的：7、JavaScript实现玫瑰花这个项目呢，主要是教你用JavaScript语言实现一朵漂亮的玫瑰花。实现出来是这样的："]}
{"author": "qq515373375", "title": "微信小程序用户信息解密 C# ", "content": ["背景有幸参加微信小程序的内测，由于公司之前已经有自己的服务大号，积累转化了大量的会员所以在做小程序时，要实现会员的互通，想到的是", "unionid", "开发文档wx.login(OBJECT)调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid）", "及本次登录的", "会话密钥（session_key）参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=1474887500719wx.getUserInfo(OBJECT)获取用户信息，需要先调用", "wx.login", "接口其中需要的unionid在调用成功返回的参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html?t=1474887500618是个加密数据，解密算法参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html", "实现code", "换取", "session_key前端先调", "wx.login", "得到code后端换取session_key和openid，", "openid返回前端，session_key保存（缓存）解密用注意：一个code只能换取一次；再次调用", "wx.login，", "会导致上一次的", "session_key", "失效，解密出来的都是乱码", "2.", "解密前端先调", "wx.getUserInfo", "得到encryptData用login返回的openid，encryptData", "调后端解密刚开始按开发文档，用C#", "系统自带AES解密失败报“填充无效，无法被移除”异常在网上扒拉了一圈，也没找到有用的信息，最终在github上，找带了参考代码，自己再改改，才解密成功结语代码本身没啥牛逼的，希望贴出来能对后面的开发伙伴有所帮助", ":)"]}
{"author": "Rolan", "title": "小程序js文件改变参数并在视图上及时更新 ", "content": ["一、简单参数XX.wxml<view>", "<text>{{str}}</text></view><button", "bindtap=\"change\">改变</button>XX.jsPage({", "data:", "{", "str:'早上好'", "},", "change:", "function()", "{", "this.setData({", "str:\"晚上好\"", "})", "}})二、已知下标的数组XX.wxml<view>", "<text>{{array[0].text}}</text></view><button", "bindtap=\"change\">改变</button>XX.jsPage({", "data:", "{", "array:", "[{text:", "'早上好'}],", "},", "change:", "function()", "{", "this.setData({", "'array[0].text':'晚上好'", "})", "}})三、动态下标的数组XX.wxml<view>", "<block", "wx:for=\"array\"", "wx:key=\"index\">", "<text>{{item.text}}</text>", "<button", "bindtap=\"change\"", "data-index=\"index\">改变</button>", "</block></view><button", "bindtap=\"change\">改变</button>XX.jsPage({", "data:{", "array:[", "{text:'1111'},", "{text:'2222'},", "{text:'3333'}", "]", "},", "change:function(e){", "let", "param", "=", "{};", "let", "string", "=", "\"array[\"+e.target.dataset.index+\"].text;", "param[string]", "=", "'0000';", "this.setData(param);", "}})希望对大家有所帮助哦"]}
{"author": "Rolan", "title": "“小红书”——给你安利几个小程序的“坑” ", "content": ["写在前面小程序发布至今已有一年多时间，很多人都已经在小程序道路上狂奔。最近我也开始了学习小程序，学了一段时间后，想看看这段时间的学习效果，于是边学习边开始了我的第一个小程序。相信很多人都用过小红书吧，我可是被它安利了很多好东西呢，所以想着就仿写一个小红书的微信小程序吧。下面我就给大家“安利”几个我在写的过程中的“坑”。因为花的时间不多，功能有很多没有完善，页面写的不是很好看，请各位将就着看啦。╮(╯▽╰)╭准备工作开发环境：WXML(HTML),WXSS(CSS),Javascript开发工具：vscode，", "微信开发者工具辅助工具：Markman：图标标注工具，可用于取色、测量。Easy-Mock：可以伪造假数据，在js中引用就好了。点这里可以查看我的项目数据。Markdown：在线编辑器GifCam：Gif录制工具微信小程序开发文档Iconfont-阿里巴巴矢量图标库", "：各种需要的小图标都有哦遇到的几个问题1、首页导航栏左右滑动效果图：这部分，是通过微信小程序的", "scroll-view组件来完成的。代码如下：<scroll-view", "class=\"navBar-box\"", "scroll-x=\"true\"", "style=\"white-space:", "nowrap;", "display:flex", "\">", "<view", "class=\"cate-list", "{{curIndex==index?'on':''}}\"", "wx:for=\"{{category}}\"", "wx:key=\"{{item.id}}\"", "data-id=\"{{item.id}}\"", "data-index=\"{{index}}\"", "bindtap=\"switchCategory\">", "{{item.name}}", "</view>", "</scroll-view>scroll-x=\"true\"是设置其水平方向滑动，如果要设置垂直方向滑动，则使用scroll-y=\"true\"。这里要注意的是，使用横向滚动时，需要给一个固定宽度，同理，竖向滚动则要设置固定高度。导航列表的每一项一定要设置宽度，其所有项的总宽度要小于scroll-view的宽度，否则列表项会垂直排列。因为导航列表项的个数比较多，这里使用了", "wx:for", "循环将列表项循环出来。这样减少了很多代码量，真是个好东西φ(゜▽゜*)♪一些使用scroll-view的注意事项：请勿在", "scroll-view", "中使用", "textarea、map、canvas、video", "组件scroll-into-view", "的优先级高于", "scroll-top在滚动", "scroll-view", "时会阻止页面回弹，所以在", "scroll-view", "中滚动，是无法触发", "onPullDownRefresh若要使用下拉刷新，请使用页面的滚动，而不是", "scroll-view", "，这样也能通过点击顶部状态栏回到页面顶部2、首页文章列表随着点击导航栏列表改变效果图：这部分，是通过微信小程序的", "swiper组件来完成的。代码如下：<swiper", "class=\"notes\"", "current=\"{{toView}}\">", "<swiper-item", "class=\"category\"", "wx:for=\"{{detail}}\"", "wx:key=\"{{item.id}}\">", "<scroll-view", "class=\"cate-box\"", "id=\"{{item.id}}\"", "scroll-y>", "<--", "文章列表内容", "-->", "<view", "class=\"note\"", "wx:for=\"{{item.notes}}\"", "wx:for-item=\"notes\"", "wx:key=\"{{index}}\">", "<view", "class=\"note-info\">", "<navigator", "url=\"../index/note-info/note-info\"", ">", "<view", "class=\"home-note-img\">", "<image", "src=\"{{notes.note_image}}\"/>", "</view>", "<span>{{notes.title}}</span>", "</navigator>", "</view>", "<!--", "作者信息", "-->", "<view", "class=\"note-handle\">", "<navigator", "class=\"writer\"", "url=\"../index/note-writer/note-writer\">", "<image", "class=\"photo-img\"", "src=\"{{notes.writer_img}}\"/>", "<span", "class=\"name\">{{notes.writer}}</span>", "</navigator>", "<view", "class=\"like\">", "<image", "class=\"like-icon\"", "src=\"/images/like.png\"/>", "<span>{{notes.like}}</span>", "</view>", "</view>", "</view>", "</scroll-view>", "</swiper-item>", "</swiper>使用swiper组件，将所有文章列表包起来，每个swiper-item表示不同的列表模块。之前在导航栏各列表项绑定了不同的值，在点击导航时触发", "switchCategory", "事件，swiper-item根据导航点击的不同值，展示相对应的item文章列表。在这里我使用了Easy-Mock将页面的数据放在里面，然后用", "wx:request", "请求数据就行了。//", "请求数据", "wx.request({", "url:", "'https://www.easy-mock.com/mock/5b1e17a0d4a14a3247a6cd6b/',", "success:", "(res)", "=>", "{", "this.setData({", "detail:", "res.data.data", "})", "}", "})通过", "wx:for", "循环，将每个文章页内容获取过来。在swiper-item里面使用scroll-view，使得页面可以滚动。内容超出一屏的时候，文章列表右边就会出现滚动条，这样也太丑了吧。那如何能让这个滚动条不出现呢，那就是让它隐藏掉。通过在全局样式中设置scroll隐藏,这样就好看多了。::-webkit-scrollbar{", "height:", "0;", "width:", "0;", "color:", "transparent;", "//", "透明", "}3、搜索页面的历史记录在搜索框中输入要搜索的内容后，输入的内容会增加到历史记录里面。这里我用", "wx：for循环historyRecord，index值区分不同的搜索内容，recordItem是要输出在历史记录的值。代码如下：<view", "class=\"search-history\">", "<text", "class=\"history-record\">历史记录</text>", "<view", "class=\"search-history-item\"", "wx:for=\"{{historyRecord}}\"", "wx:key=\"{{index}}\">", "<text>{{item.recordItem}}</text>", "</view>", "</view>因为文章的详情页还没有写，所以输入搜索内容后弹出的相似内容后，按enter键触发bindconfirm事件，使用", "wx.navigateTo", "直接跳回了搜索页面，之前输入的搜索内容就会增加到历史记录里面。bindconfirm:", "function(e){", "var", "recordItem", "=", "e.detail.value;", "this.saveHistory({", "id:", "0,", "recordItem", "})", "wx.navigateTo({", "//跳转到搜索页面", "url:", "'../searchbar/searchbar',", "})", "this.setData({", "searchContext:''", "})", "},4、收货地址的添加使用微信小程序提供的表单组件，很快就将添加地址的页面做好了。值得一提的就是picker。picker", "：从底部弹起的滚动选择器，现支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器。它的一些属性，可点击查看", "picker。<!--", "wxml", "-->", "<picker", "bindchange=\"bindaddressChange\"", "value=\"{{addressValue}}\"", "range=\"{{addressRange}}\">", "<view", "class=\"weui-select", "weui-select_in-select-after\"", "name=\"adress\">{{addressRange[addressValue]}}</view>//", "js", "设置初始值", "data:", "{", "addressValue:", "0,", "//地址下标", "addressRange:", "[\"北京市\",\"江西省\",", "\"湖南省\",", "\"上海市\",\"湖北省\",\"浙江省\",", "\"福建省\",", "\"重庆市\"],", "},", "</picker>但是这块地方，表单验证及添加地址信息提交到地址列表中，有让我一阵子头疼。首先就是表单验证，当你提交表单时触发", "formSubmit", "事件，对表单进行验证。如果未输入内容或者输入内容格式有误，通过", "wx.showModal()", "给用户提示。代码如下：formSubmit:", "function(e){", "var", "warn", "=", "\"\";", "var", "that", "=", "this;", "var", "flag", "=", "false;", "if(!e.detail.value.name){", "//判断输入内容", "warn", "=", "\"请填写收件人！\";", "}", "else", "if(!e.detail.value.tel){", "warn", "=", "\"请填写手机号码！\";", "}", "else", "if(!(/^1(3|4|5|7|8)\\d{9}$/.test(e.detail.value.tel))){", "warn", "=", "\"手机号码格式不正确！\";", "}", "else", "if(!e.detail.value.adress){", "warn", "=", "\"请选择地区！\";", "}", "else", "if(!e.detail.value.doorAdress){", "warn", "=", "\"请填写详细地址！\";", "}", "else", "if(!e.detail.value.IDcard){", "warn", "=", "\"请填写身份证号码\";", "}", "else", "if(!(/(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/).test(e.detail.value.IDcard)){", "warn", "=", "\"身份证号码格式不正确\"", "}", "else{", "flag=true;", "//", "存储到全局变量adressInfo", "app.globalData.adressInfo.push(e.detail.value);", "wx.navigateTo({", "url:", "'/pages/my/adress/adress'", "})", "}", "if(flag==false){", "wx.showModal({", "title:", "'提示',", "content:warn", "})", "}", "},添加地址信息提交到地址列表中，这部分要怎么解决呢？我一开始的思路是，将添加的地址信息存在本地，然后在地址列表那获取添加的地址信息。这样就不得不提下wx.setStorage(", ")和wx.getStorage(", ")这两个方法了。wx.setStorage()", "：将数据存储在本地缓存中指定的", "key", "中，会覆盖掉原来该", "key", "对应的内容，这是一个异步接口。wx.getStorage()", "：从本地缓存中异步获取指定", "key", "对应的内容。wx:getStorage是从本地缓存中异步获取指定", "key", "对应的内容。Key指定了，所以再添加的地址就会覆盖原来的key对应的内容，从而得不到保存地址的效果，只有一条数据。//添加地址信息到本地缓存", "add-adress.js", "submitdate:", "function", "(event)", "{", "var", "adressInfo", "=", "event.detail.value;", "wx.setStorage({", "key:", "'adressInfo',", "data:", "adressInfo,", "success:", "function", "(res){", "wx.navigateTo({", "url:", "'/pages/my/adress/adress'", "})", "}", "})", "},", "//地址列表里获取缓存在本地的地址信息", "adress.js", "var", "that=this;", "wx.getStorage({", "key:'adressInfo',", "success:function(res){", "console.log(res);", "var", "adressInfo=[];", "adressInfo.push(res.data);", "that.setData({", "adressInfo", "})", "}", "})于是呢，就去请教了几位大佬，看有什么方法可以解决这个问题。经过讨论，得出了解决办法：将添加的地址信息push到全局上去，然后再从全局里面获取，这样就不会将之前的数据覆盖。而且这样处理，代码量大大的减少了。", "代码如下：//", "定义globalData对应的全局变量", "app.js", "globalData:", "{", "userInfo:", "null,", "adressInfo:[]", "}", "//", "提交地址信息，调用定义的变量", "add-adress.js", "submitdate:", "function", "(event)", "{", "app.globalData.adressInfo.push(event.detail.value);", "wx.navigateTo({", "url:", "'/pages/my/adress/adress'", "})", "console.log(app.globalData.adressInfo);", "},", "//获取地址信息,调用定义的变量", "adress.js", "var", "that=this;", "that.setData({", "adressInfo:app.globalData.adressInfo", "})注意：需要在调用全局变量的文件里，开始的时候初始化", "app", "这个对象const", "app", "=", "getApp();5、Easy-Mock数据接口的引入问题使用Easy-Mock伪造数据时，一定要书写规范，我在这里踩的\"坑\"就是：数据属性名，不能包含“-”（比如：note-image）。这样虽然数据接口能够创建，但是引入的时候就会报错，引入的数据为空。数据属性名可以用“_”（比如：note_image)。总结以上便是我觉得比较容易掉坑，比较难的地方。还有很多没有完成的功能，后续我会慢慢完善。对于小程序这方面，完全还是新手，给跟我一样的新手的一个建议，除了看微信小程序开发文档之外，也可以多看一看开源的小程序项目源码，遇到问题，可以看看别人是怎么解决的。各个社区也是很好的平台，可以将问题发布出来，大家一起解决。本文如果有不好的地方，或者更好的方法，欢迎大佬们指出，一起学习。", "本文为个人原创，如果你想对我的项目想要了解更多，可以查看我的", "项目源码", "。希望这篇文章对你有帮助，欢迎大家点赞收藏~~"]}
{"author": "Rolan", "title": "微信小程序支付流程梳理 ", "content": ["用", "thinkjs", "封装了个小程序支付的", "Service", "在这里记录一下，顺便梳理一下小程序支付的流程和思路。首先，先把官网的流程图放上来，然后按照图一步步的来。第一步：用户请求开发者后台，发起下单请求发起请求前在小程序端调用", "wx.checkSession()", "查看", "session_key", "是否过期如果过期了", "重新调用", "wx.login()", "返回", "session_key", "和", "openid如果没过期", "继续下一步操作，请求开发者后台第二步：开发者查找一下数据库或者缓存里是否有", "openid", "和", "session_key如果有生成订单编号", "out_trade_no如果没有返回错误消息，缺少", "openid", "、", "session_key第三步：开发者服务器请求统一下单", "API", ",带上要求的参数：appid", "mch_id", "nonce_str", "sign", "body", "out_trade_no", "total_fee", "spbill_create_ip", "nonce_str", "获取随机字符串：test.jsjs/*", "*", "功能：", "返回32位随机字符串", "*", "create", "by", "tiankai", "on", "2018-06-25", "15:39", "*/", "getNonceStr(){", "let", "char", "=", "'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';", "let", "len", "=", "32;", "let", "result", "=", "'';", "for(let", "i", "=", "0;", "i", "<", "len;", "i++){", "let", "randomNum", "=", "Math.floor(Math.random()*char.length);", "result", "+=", "char[randomNum];", "}", "return", "result;", "}", "sign", "参数签名,", "第二个tab（js）是调用函数的方法,", "key", "为商户平台设置的密钥", "key", "test.jsjsjs/*", "*", "功能：sign", "参数签名", "*", "create", "by", "tiankai", "on", "2018-06-26", "12:00", "*/", "async", "makeSign(params,", "key){", "//", "生成签名", "sign", "let", "strOrderArr", "=", "Object.keys(params).sort();", "let", "stringA", "=", "\"\";", "strOrderArr.map(val", "=>{", "//如果参数值为空，或者验证返回的", "sign", "不参与签名", "if(", "think.isNullOrUndefined(params[val])", "||", "val", "===", "'sign'", "||", "params[val].length", "===", "0", ")", "return;", "stringA", "+=", "val", "+", "\"=\"", "+", "params[val]", "+", "\"&\";", "});", "let", "stringSignTemp", "=", "stringA", "+", "\"key=\"", "+", "key;", "let", "sign", "=", "think.md5(stringSignTemp).toUpperCase();", "return", "sign;", "}", "得到这几个参数就开始发起请求统一下单", "API", "了，这里需要注意的是，请求参数应该以", "xml", "的形式传送过去，这里借助一个工具", "xml2js", "把对象转换为", "xml,也可以把", "xml", "转换为", "对象、json。安装", "xml2jsnpm", "i", "xml2js", "使用", "xml2jstest.jsjsconst", "xml2js", "=", "require('xml2js');", "//xml->json", "//xml2js默认会把子子节点的值变为一个数组,", "explicitArray设置为false", "var", "xmlParser", "=", "new", "xml2js.Parser({explicitArray", ":", "false,", "ignoreAttrs", ":", "true})", "//json->xml", "var", "jsonBuilder", "=", "new", "xml2js.Builder();", "请求参数转换为", "xmltest.jsjs/*", "*", "功能：获取统一下单", "API", "请求XML参数", "*", "create", "by", "tiankai", "on", "2018-06-25", "15:23", "*/", "async", "getUnifiedOrderParams(){", "let", "signString", "=", "{", "appid:", "config.appid,", "mch_id:", "config.mchid,", "nonce_str:", "await", "this.getNonceStr(),", "body:", "'短信平台-短信套餐购买',", "out_trade_no:", "'20180926125346',//订单号", "total_fee:", "88,//订单金额", "//APP和网页支付提交用户端ip，Native支付填调用微信支付API的机器IP", "//需要自行获取，这里只是为了测试直接写上了", "spbill_create_ip:", "'123.12.12.123',", "notify_url:", "config.notify_url,", "trade_type:", "'JSAPI',", "openid:", "await", "think.cache('openId')", "}", "let", "sign", "=", "await", "this.makeSign(signString,config.key);", "signString.sign", "=", "sign;", "/*", "console.log(\"--------------------------\");", "*", "console.log(sign);", "*", "console.log(\"--------------------------\");", "*/", "let", "xml", "=", "await", "jsonBuilder.buildObject(signString);", "/*", "console.log(xml);", "*/", "return", "xml;", "}", "然后就可以发起统一下单API请求了test.jsjs/*", "*", "功能：调用统一下单API接口", "*", "create", "by", "tiankai", "on", "2018-06-26", "11:01", "*/", "async", "unifiedOrder(){", "let", "xmlParams", "=", "await", "this.getUnifiedOrderParams();", "let", "unifiedOrderUrl", "=", "config.unifiedOrderUrl;", "let", "opt", "=", "{", "method:", "\"POST\",", "mode:", "'cors',", "headers:", "{", "'content-type':", "'text/xml'", "},", "body:", "xmlParams", "}", "let", "res", "=", "await", "this.fetch(unifiedOrderUrl,", "opt);", "//这里微信返回的也是", "xml", "let", "result", "=", "await", "res.text();", "let", "data", "=", "null;", "//", "微信返回的", "XML", "转换为", "JSON", "xmlParser.parseString(result,function(err,", "jsonData){", "if(!err){", "/*", "console.log(jsonData);", "*/", "data", "=", "jsonData;", "}", "});", "return", "data;", "}", "第四步：当请求成功时", "判断一下", "return_code", "和", "result_code如果它们都等于", "SUCCESS", "的时候，微信会把我们需要的预支付订单信息", "prepay_id", "返回来，否则返回", "return_msg", "给前端", "展示具体错误第五步：拿上", "prepay_id", ",进行再次签名，然后返回给前端test.jsjs/*", "*", "功能：统一下单接口返回", "prepay_id", "再次签名", "返回给前端", "*", "create", "by", "tiankai", "on", "2018-06-26", "15:45", "*/", "async", "payParams(){", "let", "signString", "=", "{", "appid:", "config.appid,", "timeStamp:", "+new", "Date(),", "nonce_str:", "await", "this.getNonceStr(),", "package:", "null,", "signType:", "'MD5'", "}", "//调用", "统一下单", "API", "let", "jsonData", "=", "await", "this.unifiedOrder();", "if(think.isNullOrUndefined(jsonData)", "&&", "jsonData.xml.return_code", "===", "'SUCCESS'", "&&", "jsonData.xml.result_code", "===", "'SUCCESS'", "){", "signString.package", "=", "'perpay_id='+jsonData.xml.perpay_id", "}else{", "return", "jsonData.xml.return_msg;", "}", "//进行再次签名", "let", "paySign", "=", "await", "this.makeSign(signString,config.key);", "signString.paySign", "=", "paySign;", "let", "{", "appid,", "signType,", "...result", "}", "=", "signString;", "//", "result", "中不包括", "appid", "和", "signType", "返回给前端", "return", "result;", "}", "第六步：用户确认支付后，小程序端调用支付接口，根据返回结果提示用户test.jsjswx.requestPayment({", "'timeStamp':", "'',", "'nonceStr':", "'',//后端返回的随机字符串", "'package':", "'',//后端返回的", "'signType':", "'MD5',", "'paySign':", "'',//后端返回的", "'success':function(res){", "},", "'fail':function(res){", "}", "});", "第七步：支付成功后，微信服务器会把支付结果返回给配置的", "notify_url", "，开发者根据支付结果，更新服务器的订单状态。大体流程就是这，现在进行到了", "第四步", "公司小程序", "appid", "还没申请下来", "商户号", "mch_id", "也没有，等过段时间继续更新。（18/6/27）"]}
{"author": "Rolan", "title": "小程序基础核心组件库处理Banner、图片上传、列表刷新 ", "content": ["小程序基础库版本", "1.9.90", "以上（可升级小程序开发工具为最新）。项目git地址：", "git.coding.net/prin/mangom…组件库引入", "将mangom-we-demo项目下的pages/mangom-we文件夹导入到项目的的pages目录下，与其他page同级。样式导入//app.wxss中导入样式", "@import", "'pages/mangom-we/mg.wxss';//Demo.json配置文件中引入组件，代码如下", "{", "\"usingComponents\":", "{\"banner\":", "\"../mangom-we/banner/banner\"}", "}", "/**", "Demo.xml结构中使用组件", "*", "ds是组件接受数据的统一定义属性，imgUrls是提供的数组数据", "*", "class-img-item是控制banner中子项的样式展示，无需自定义的话则使用默认样式", "*/", "<banner", "ds=\"{{imgUrls}}\"", "class-img-item=\"mg-banner-img-item\"/>小程序在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，为了解组件支持样式默认和自定义，采用所有组件默认样式配置在一个样式表中提供使用，且开放自定义组件样式属性功能。Banner轮播图组件支持是否自动轮播配置支持banner样式的设置支持指示器的屏蔽支持点击item的点击回调1.在.json配置文件中配置banner组件的引入。{", "\"navigationBarTitleText\":", "\"Banner组件\",", "\"usingComponents\":", "{", "\"banner\":", "\"../mangom-we/banner/banner\"", "}", "}2.在.wxml结构文件中引入组件结构。<!--pages/banner/banner.wxml-->", "<banner", "ds=\"{{imgUrls}}\"", "autoplay=\"{{false}}\"", "class-item=\"mg-banner-item\"", "binditemPress=\"onBannerItemPress\"/>", "<view", "bindtap='onBannerItemPress'>", "<text>我是内容</text>", "</view>", "3.在.js行为文件中提供数据并处理点击子项回调。//", "pages/banner/banner.js", "Page({", "/**", "*", "页面的初始数据", "*/", "data:", "{", "imgUrls:", "[", "'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',", "'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',", "'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'", "],", "},", "/**", "*", "生命周期函数--监听页面加载", "*/", "onLoad:", "function", "(options)", "{", "},", "/**", "*", "Banner子项点击回调", "*/", "onBannerItemPress:", "function", "(e)", "{", "let", "itemId", "=", "e.detail.dataSource", "console.log(\"点击子项返回的id值\"", "+", "itemId)", "}", "})图片上传组件支持看大图功能支持拍照或者相册中选择支持多选1.在界面.json配置文件中引入组件使用。{", "\"component\":", "true,", "\"usingComponents\":", "{", "\"uploader\":", "\"../mangom-we/uploader/uploader\"", "}", "}2.界面.wxml结构文件中引入组件。<!--pages/uploader/uploader.wxml-->", "<uploader", "url=\"{{url}}\"", "hideHeader=\"{{false}}\"", "binduploadSuccess=\"uploadSuccess\"", "binduploadFail=\"uploadFail\"", "/>", "3.在.js文件中处理回调结果。", "图片上传后，会返回图片的相关信息，可以按照如下代码方式获取所有上传成功的photoUrl集合。Page({", "data:", "{", "url:", "'https://xxx.xxx.cn/upload/upavatar?spaceId=1&channel=ios&accessToken=XfIJVGMjPuMrwZpWTh',", "preUploadImgs:", "[],", "//待上传到服务端的图片链接", "},", "/**", "*", "图片上传成功，组装待上传字符串", "*/", "uploadSuccess:", "function", "(e)", "{", "let", "url", "=", "e.detail.dataSource.data", "let", "obj", "=", "JSON.parse(url)", "let", "photoUrl", "=", "obj.data.photoUrl", "this.data.preUploadImgs.push(photoUrl)", "console.log(this.data.preUploadImgs)", "}", "});下拉刷新，上拉加载获取数据下拉刷新（注意：下拉刷新样式默认是白色的，可以在app.json文件中设置主色来提升效果）\"backgroundColor\":", "\"#f0145a\"1.在界面配置.json文件中开启下拉刷新，并引入加载更多组件。{", "\"usingComponents\":", "{", "\"load-more\":", "\"../mangom-we/load-more/load-more\"", "},", "\"window\":", "{", "\"enablePullDownRefresh\":", "true", "}", "}2.在结构.wxml文件中引入加载更多组件结构<!--上拉加载更多组件", "-->", "<view", "wx:if=\"{{showLoadMore}}\">", "<load-more", "loadingComplete=\"{{loadingComplete}}\"", "/>", "</view>", "3.行为层.js处理（具体可参考demo实例）1.导入mangom", "import", "mangom", "from", "'../mangom-we/mangom.js'", "2.", "在data{}中加入页面的初始数据", "data:", "{", "showLoadMore:", "false,", "//显示加载更多", "loadingComplete:", "false,", "//显示加载完成", "},", "3.监听下拉刷新回调", "//下拉加载", "onPullDownRefresh:", "function", "()", "{", "//清空加载更多结束", "//开始刷新", "mangom.beginRefresh()", "//处理耗时任务", "获取最新信息耗时任务(()=>{", "//回调成功", "successCallBack", "mangom.overRefresh()", "})", "},", "3.监听加载更多", "onReachBottom:", "function", "()", "{", "mangom.beginLoadMore(this)", "},", "4.处理加载更多完成", "//加载更多数据和刷新数据应该能融于一起", "loadData:", "function", "()", "{", "let", "that", "=", "this", "this.data.loadNum++", "if", "(this.data.loadNum", ">", "6)", "{", "return", "}", "//获取响应数据", "需根据业务数据返回参考如下封装", "放在本项目的公共行为处理工具类中", "setTimeout(()", "=>", "{", "let", "rspWorlds", "=", "this.data.testRspWords", "if", "(this.data.loadNum", "===", "6)", "{", "rspWorlds", "=", "[{", "msg:", "'加载完毕的数据'", "},", "{", "msg:", "'加载完毕的数据'", "}]", "}", "else", "{", "this.data.words", "=", "this.data.words.concat(rspWorlds);", "}", "console.log(rspWorlds", "&&", "rspWorlds.length", "<", "PAGE_SIZE)", "that.setData({", "words:", "this.data.words,", "loadingComplete:", "this.data.loadNum!=0&&", "rspWorlds", "&&", "rspWorlds.length", "<", "PAGE_SIZE,", "showLoadMore:", "false", "//把\"上拉加载\"的变量设为false，隐藏", "})", "},", "1000)", "}"]}
{"author": "Rolan", "title": "微信小程序客服自动回复消息功能踩坑 ", "content": ["小程序接入客服，我们就需要调用微信客服功能。很简单，只需要在页面中使用", "<button", "open-type=\"contact\"", "/>", "可以显示进入客服会话按钮。", "然后我们就能登录网页版的微信公众平台的客服页面进去回复各种千奇百怪的问题了。", "但是有个问题，我们如何做到自动回复呢？", "那么就需要通过自己的服务器去通过微信端请求服务，完成这项工作。", "接入指引", "·", "小程序附上官网接入指南，这可是相当的简洁。", "First", "填写服务器配置的图：", "<!—more—>", "在这里填写的同时我们需要在后台写get请求验证。", "官方提供了一个非常简洁的一个php代码。。那是相当的坑爹啊。", "这里我是用express写得提供一个例子", "function", "checkSignature(params)", "{", "var", "key", "=", "[params.token,", "params.timestamp,", "params.nonce].sort().join('');", "var", "sha1", "=", "crypto.createHash('sha1');", "sha1.update(key);", "return", "sha1.digest('hex')", "===", "params.signature;", "}", "app.get('/wxlalalala',", "function(req,", "res,", "next)", "{", "let", "token", "=", "'xxxxx';", "//", "填写服务器配置上所填的token", "let", "isCheck", "=", "checkSignature({", "signature:", "req.query.signature,", "timestamp:", "req.query.timestamp,", "nonce:", "req.query.nonce,", "token:", "token,", "});", "req.body", "=", "req.query.echostr;", "res.send(req.body);", "return", "req.body;", "});", "然后我们就完成了最关键的一步。之后就可以去写，客户发了什么我们就自动回啥的逻辑。", "Second", "当我们去接受客户发的消息和事件，我们都需要去通过一个post去接受。", "当然第一我们需要先去拿access_token。没有这个我们啥事情都做不了。", "给上一个官方网站：", "接口调用凭证", "·", "小程序，但是毫无代码示例，算了还在自己撸吧。", "以下自己的code:", "let", "access_token", "=", "'';", "const", "getAccessToken", "=", "function()", "{", "if", "(access_token", "!==", "'')", "{", "return", "access_token;", "}", "let", "URL", "=", "'https://api.weixin.qq.com/cgi-bin/token?grant_type=", "client_credential&appid=xxxx&secret=sssss';", "//", "grant_type一定要填client_credential.", "let", "options", "=", "{", "method:", "'GET',", "url:", "URL,", "};", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "request(options,", "function(err,", "res,", "body)", "{", "if", "(res)", "{", "access_token", "=", "JSON.parse(body).access_token;", "let", "expires_in", "=", "parseInt(JSON.parse(body).expires_in)", "-", "10;", "setTimeout(()", "=>", "{", "access_token", "=", "'';", "//getAccessToken();", "},", "expires_in", "*", "1000);", "resolve(access_token);", "}", "else", "{", "reject(err);", "}", "});", "});", "};", "因为token有7200s的过期时间，所以就存在内存里了。", "Ok这个我们就有access_token能去做客服自动回复啦！", "Third", "再来一个官方客服发送消息的文档：", "发送客服消息", "·", "小程序，发现又是啥都没用。。。", "还是自己动手写一个吧。。毕竟那么精瘦的文档。。T", "T.那就写一个回复文本消息的吧！其他的类似自己扩展。", "const", "postJson", "=", "function(param)", "{", "var", "options", "=", "{", "url:", "param.url,", "method:", "'POST',", "body:", "param.body,", "json:", "true,", "};", "request(options,", "function", "callback(error,", "response,", "data)", "{", "if", "(!error", "&&", "response.statusCode", "==", "200)", "{", "param.success(response.errcode);", "}", "else", "{", "param.error(error);", "}", "});", "};", "async", "function", "sendTextMessage(content,", "data,", "access_token)", "{", "await", "postJson({", "url:", "'https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token='", "+", "access_token,", "body:", "{", "touser:", "data.FromUserName,", "msgtype:", "'text',", "text:", "{", "content:", "content,", "},", "},", "success:", "function(res)", "{", "console.log(res,", "'send", "successed!1');", "},", "error:", "function(err)", "{", "console.log(err);", "},", "});", "}", "Last", "回复的函数也写好了，来到最后根据客户发来的消息我们作为智能客服去回消息啦！不多说直接上code。文档。。。就算了只能看看参数啥的。。哎", "客服消息", "·", "小程序", "app.post('/wxlalallala',", "(req,", "res,", "next)", "=>", "{", "let", "token", "=", "'xxxxx';//", "填写服务器配置那的token", "let", "reqBody", "=", "req.body;", "let", "isCheck", "=", "checkSignature({", "signature:", "req.query.signature,", "timestamp:", "req.query.timestamp,", "nonce:", "req.query.nonce,", "token:", "token,", "});", "if", "(isCheck)", "{", "let", "welcome=", "'欢迎';", "switch", "(reqBody.MsgType)", "{", "case", "'text':", "{", "//文本消息", "sendTextMessage('您好，【'+reqBody.Content+'】是未知命令，已转发给人工处理。\\n'+welcomeTips,", "reqBody,", "getAccessToken());", "break;", "}", "case", "'image':", "{", "//用户在客服会话中发送图片消息", "sendImageMessage('xxxxxxx',", "reqBody,", "getAccessToken());", "break;", "}", "case", "'event':", "{", "sendTextMessage(welcome,", "reqBody,", "getAccessToken());", "break;", "}", "default:", "break;", "}", "}", "res.send('success');", "next();", "res.end();", "});", "完成啦愉快的使用自动客服回复！！"]}
{"author": "Rolan", "title": "微信小程序测试指南 ", "content": ["目录微信小程序本地部署测试方法微信小程序手机端测试方法微信小程序前端代码变更测试微信小程序本地部署测试方法下载微信开发者工具让小程序管理员将测试人员的微信号添加开发者权限本地设置hosts为测试环境hosts打开微信web开发者工具并扫码登录选择项目路径（事先在本地存放好小程序源代码，选择小程序所在路径，如果路径正确的话项目名会自动出现，无需手动填写）返回填写appId，确定后双击即可打开小程序本地调试小程序（我们可以在Network下面查看到网络请求，可以查看具体某个请求的请求参数以及返回结果等信息）回到顶部微信小程序手机端测试方法Fiddler代理服务器本地hosts设置为测试环境手机开启代理连到Fiddler微信开发者工具本地运行小程序，点击预览生成二维码手机微信扫描二维码在手机端进入小程序页面即可将前端项目代码git", "clone到本地前端开发push最新代码后pull变更到本地微信开发者工具删除原有项目重新选择微信小程序路径（本地下载的前端项目下指定小程序程序所在文件夹路径）返回填写appId并进入小程序调试代码变更后本地pull代码变更后小程序会自动重新编译：本地开发者平台需要清缓存重启项目手机端删除小程序重新扫预览码访问"]}
{"author": "Rolan", "title": "微信小程序根据金纬度规划路线 ", "content": ["效果图：1、wxml文件<view", "class=\"mapHeight\">", "<map", "id=\"map\"", "class=\"map\"", "polyline=\"{{polyline}}\"", "markers=\"{{markers}}\"", "include-points=\"{{markers}}\"", "></map>", "</view>2、", "js文件var", "coors;", "Page({", "data:", "{", "polyline:", "[],", "markers:", "[],", "},", "onReady:", "function()", "{", "this.mapContext", "=", "wx.createMapContext(\"map\",", "this);", "},", "onLoad:", "function(options)", "{", "//", "获取当前地图，设置经纬度，传递过来的坐标，用户下单的坐标地址。", "console.log(options);", "wx.getLocation({", "success:", "(res)", "=>", "{", "this.setData({", "latitude:", "options.latitude,", "longitude:", "options.longitude", "});", "this.getCenterLocation(res);", "wx.request({", "url:", "'https://apis.map.qq.com/ws/direction/v1/driving/?from='", "+", "this.data.markers[0].latitude", "+", "','", "+", "this.data.markers[0].longitude", "+", "'&to='", "+", "this.data.markers[1].latitude", "+", "','", "+", "this.data.markers[1].longitude", "+", "'&output=json&callback=cb&key=PD5BZ-K2VRO-CPEWZ-SOBAC-4KCDT-KAFLF',", "success:", "(res)", "=>", "{", "coors", "=", "res.data.result.routes[0].polyline", "for", "(var", "i", "=", "2;", "i", "<", "coors.length;", "i++)", "{", "coors[i]", "=", "coors[i", "-", "2]", "+", "coors[i]", "/", "1000000", "}", "console.log(coors)", "//划线", "var", "b", "=", "[];", "for", "(var", "i", "=", "0;", "i", "<", "coors.length;", "i", "=", "i", "+", "2)", "{", "b[i", "/", "2]", "=", "{", "latitude:", "coors[i],", "longitude:", "coors[i", "+", "1]", "};", "console.log(b[i", "/", "2])", "}", "this.setData({", "polyline:", "[{", "points:", "b,", "color:", "\"#00ae20\",", "width:", "4,", "dottedLine:", "false", "}],", "})", "}", "})", "}", "});", "},", "//", "两个坐标", "一个下单地址，一个工程师接单地址，然后不停的更新工程师的坐标位置。", "getCenterLocation:", "function(res)", "{", "this.setData({", "markers:", "[{", "iconPath:", "\"/resources/center.png\",", "id:", "0,", "latitude:", "res.latitude,", "longitude:", "res.longitude,", "width:", "30,", "height:", "30,", "alpha:", "0.8,", "callout:", "{", "content:", "\"", "我的位置", "\",", "color:", "\"#ffffff\",", "fontSize:", "10,", "borderRadius:", "10,", "bgColor:", "\"#6e707c\",", "padding:", "5,", "display:", "\"ALWAYS\"", "}", "},", "{", "iconPath:", "\"/resources/user.png\",", "id:", "1,", "latitude:", "res.latitude", "+", "0.1,", "longitude:", "res.longitude", "+", "0.1,", "width:", "30,", "height:", "30,", "alpha:", "0.8,", "callout:", "{", "content:", "\"", "工程师", "\",", "color:", "\"#ffffff\",", "fontSize:", "10,", "borderRadius:", "10,", "bgColor:", "\"#6e707c\",", "padding:", "5,", "display:", "\"ALWAYS\"", "}", "}", "],", "});", "},", "});3、wxss文件.mapHeight", "{", "display:", "flex;", "flex-direction:", "column;", "}", ".map", "{", "flex:", "1;", "height:", "100vh;", "width:", "100%;", "}"]}
{"author": "Rolan", "title": "微信小程序 wx.request 对于 JSON 含 \\u2028 处理异常 ", "content": ["问题描述最近在小程序的开发过程中，遇到一个神奇的问题。小程序用于发起网络请求的", "API", "wx.request", "默认会对为", "JSON", "格式的响应体进行解析，返回", "JS", "Object。wx.request({", "url:", "'test.php',", "//仅为示例，并非真实的接口地址", "data:", "{", "x:", "'',", "y:", "''", "},", "header:", "{", "'content-type':", "'application/json'", "//", "默认值", "},", "success:", "function(res)", "{", "console.log(res.data)", "}", "})其中", "res.data", "一般会是", "Object", "类型。但是，响应体的", "JSON", "数据包含了", "\\\\u2028", "的字符，就会解释失败，输出的", "res.data", "是响应体的字符串类型。样本测试样本：{“test”:”这里有一个特殊字符：", "\"}测试代码：wx.request({", "...", "success:", "(res)", "=>", "{", "console.log('APIFactory:run',", "'调试',", "{", "res", "});", "},", "});结果：在", "开发者工具", "中，能正常解析在", "真机（iOS", "和", "Android），都解析失败u2028该特殊字符就是", "\\u2028，解析为行分隔符。该字符，在", "JSON", "字符串中，是被兼容的，是能被", "JSON.parse", "正常解析的。但是", "JS", "代码中有这个字符串，就会导致运行出错。为什么真机和开发者工具表现不一致微信小程序运行在三端：iOS、Android", "和", "用于调试的开发者工具。三端的JS脚本执行环境是各不相同的：在", "iOS", "上，小程序的", "javascript", "代码是运行在", "JavaScriptCore", "中。在", "Android", "上，小程序的", "javascript", "代码是通过", "X5", "JSCore来解析。在", "开发工具上，", "小程序的", "javascript", "代码是运行在", "nwjs", "中。而小程序的逻辑层和视图层，都是通过「WeixinJsBridge」来调用", "Native", "API", "的。所以问题出在，wx.request", "对于响应体的数据处理，到底是在", "JS", "Engine", "处理的，还是", "Native", "处理的，在微信不公开小程序源码的情况下，不得而知。wx.request", "的处理对于我们来说，相当于黑盒，并且对于", "res.data", "的数据类型可能值是多种的，如果想在业务上提供更好的健壮性，还需要兼容", "res.data", "为", "Object/String", "类型时的判断和容错代码。参考微信小程序运行流程看这篇就够了"]}
{"author": "Rolan", "title": "React转微信小程序：从React类定义到Component调用 ", "content": ["这是本系列的第二篇，过去两周，已经有相当成果出来。本文介绍其中一部分可靠的思路，这个比京东的taro更具可靠性。如果觉得看不过瘾，可以看anu的源码，里面包含了miniapp的转换器。微信小程序是面向配置对象编程，不暴露Page,App,Component等核心对象的原型，只提供三个工厂方法，因此无法实现继承。App,Page,Component所在的JS的依赖处理也很弱智，你需要声明在同一目录下的json文件中。比如说Component({", "properties:", "{},", "data:", "{},", "onClick:", "function(){}", "})", "properties与data都是同一个东西，properties只是用来定义data中的数据的默认值与类型，相当于React的defaultProps与propTypes。如何转换呢？import", "{Component}", "form", "\"./wechat\"", "Class", "AAA", "extends", "Component{", "constructor(props){", "super(props);", "this.state", "=", "{}", "}", "static", "propTypes", "=", "{}", "static", "defaultProps", "=", "{}", "onClick(){}", "render(){}", "}", "export", "AAA;", "首先我们要提供一个wechat.js文件，里面提供Component,", "Page,", "App", "这几个基类，现在只是空实现，但已经足够了，保证它在调试不会出错。我们要的是`Class", "AAA", "extends", "Component`这个语句的内容。学了babel，对JS语法更加熟悉了。这个语句在babel6中称为ClassExpression，到babel7中又叫ClassDeclaration。babel有一个叫\"babel-traverse\"的包，可以将我们的代码的AST，然后根据语法的成分进行转换（详见这文章", "https://yq.aliyun.com/articles/62671）。ClassDeclaration的参数为一个叫path的对象，我们通过", "path.node.superClass.name", "就能拿到Component这个字样。如果我们的类定义是下面的这样，path.node.superClass.name", "则为App。Class", "AAA", "extends", "App{", "constructor(props){", "super(props);", "this.state", "=", "{}", "}", "}", "App,", "Page,", "Component对应的json差异很大，拿到这个可以方便我们区别对待。然后我们继续定义一个ImportDeclaration处理器，将import语句去掉。定义ExportDefaultDeclaration与ExportNamedDeclaration处理器，将export语句去掉。到这里我不得不展示一下我的转码器的全貌了。我是通过rollup得到所有模块的路径与文件内容，然后通过babel进行转译。babel转换是通过babel.transform。babel本来就有许多叫babel-plugin-transform-xxx的插件，它是专门处理那些es5无法识别的新语法。我们需要在这后面加上一个新插件叫miniappPlugin//", "https://github.com/RubyLouvre/anu/blob/master/packages/render/miniapp/translator/transform.js", "const", "syntaxClassProperties", "=", "require(\"babel-plugin-syntax-class-properties\")", "const", "babel", "=", "require('babel-core')", "const", "visitor", "=", "require(\"./visitor\");", "var", "result", "=", "babel.transform(code,", "{", "babelrc:", "false,", "plugins:", "[", "'syntax-jsx',", "//", "\"transform-react-jsx\",", "'transform-decorators-legacy',", "'transform-object-rest-spread',", "miniappPlugin,", "]", "})", "function", "miniappPlugin(api)", "{", "return", "{", "inherits:", "syntaxClassProperties,", "visitor:", "visitor", "};", "}", "miniappPlugin的结构异常简单，它继承一个叫syntaxClassProperties的插件，这插件原来用来解析es6", "class的属性的，因为我们的目标也是抽取React类中的defaultProps,", "propsTypes静态属性。visitor的结构很简单，就是各种JS语法的描述。const", "t", "=", "require(\"babel-types\");", "module.exports", "=", "{", "ClassDeclaration:", "抽取父类的名字与转换构造器,", "ClassExpression:", "抽取父类的名字与转换构造器,", "ImportDeclaration(path)", "{", "path.remove()", "//移除import语句，小程序会自动在外面包一层，变成AMD模块", "},", "ExportDefaultDeclaration(path){", "path.remove()", "//AMD不认识export语句，要删掉，或转换成module.exports", "},", "ExportNamedDeclaration(path){", "path.remove()", "//AMD不认识export语句，要删掉，或转换成module.exports", "}", "}", "我再介绍一下visitor的处理器是怎么用的，处理器其实会执行两次。我们的AST树每个节点会被执行两次，如果学过DFS的同学会明白，第一次访问后，做些处理，然后进行它内部的节点，处理后再访问一次。于是visitor也可以这样定义。ClassDeclaration:{", "enter(path){},", "exit(path){}", "}", "如果以函数形式定义，那么它只是作为enter来用。AST会从上到下执行，我们先拿到类名的名字与父类的名字，我们定义一个modules的对象，保存信息。enter(path)", "{", "let", "className", "=", "path.node.superClass", "?", "path.node.superClass.name", ":", "\"\";", "let", "match", "=", "className.match(/\\.?(App|Page|Component)/);", "if", "(match)", "{", "//获取类的组件类型与名字", "var", "componentType", "=", "match[1];", "if", "(componentType", "===", "\"Component\")", "{", "modules.componentName", "=", "path.node.id.name;", "}", "modules.componentType", "=", "componentType;", "}", "},", "我们在第二次访问这个类定义时，要将类定义转换为函数调用。即Class", "AAA", "extends", "Component", "--->", "Component({})", "实现如下，将原来的类删掉（因此才在exit时执行），然后新建一个函数调用语句。我们可以通过babel-types这个句实现。具体看这里。比如说：const", "call", "=", "t.expressionStatement(", "t.callExpression(t.identifier(\"Component\"),", "[", "t.objectExpression([])])", ");", "path.replaceWith(call);", "就能产生如下代码，将我们的类定义从原位置替换掉。Component({})", "但我们不能是一个空对象啊，因此我们需要收集它的方法。我们需要在visitors对象添加一个ClassMethod处理器，收集原来类的方法。类的方法与对象的方法不一样，对象的方法叫成员表达式，需要转换一下。我们首先弄一个数组，用来放东西。var", "methods", "=", "[]", "module.exports=", "{", "ClassMethod:", "{", "enter(path){", "var", "methodName", "=", "path.node.key.name", "var", "method", "=", "t.ObjectProperty(", "t.identifier(methodName),", "t.functionExpression(", "null,", "path.node.params,", "path.node.body,", "path.node.generator,", "path.node.async", ")", ");", "methods.push(method)", "}", "}", "然后我们在ClassDeclaration或ClassExpression的处理器的exit方法中改成：const", "call", "=", "t.expressionStatement(", "t.callExpression(t.identifier(\"Component\"),", "[", "t.objectExpression(methods)])", ");", "path.replaceWith(call);", "于是函数定义就变成Component({", "constructor:function(){},", "render:function(){},", "onClick:", "function(){}", "})", "到这里，我们开始另一个问题了。小程序虽然是抄React，但又想别出心裁，于是一些属性与方法是不一样的。比如说data对应state,", "setData对应setState，早期的版本还有forceUpdate之类的。data对应一个对象，你可以有千奇百怪的写法。this.state", "={", "a:", "1}", "this[\"state\"]", "=", "{b:", "1};", "this.state", "=", "{}", "this.state.aa", "=", "1", "你想hold住这么多奇怪的写法是很困难的，因此我们可以对constructor方法做些处理，然后其他方法做些约束，来减少转换的成本。什么处理constructor呢，我们可以定义一个onInit方法，专门劫持constructor方法，将this.state变成this.data。function", "onInit(config){", "if(config.hasOwnProperty(\"constructor\")){", "config.constructor.call(config);", "}", "config.data", "=", "config.state||", "{};", "delete", "config.state", "return", "config;", "}", "Component(onInit({", "constructor:function(){},", "render:function(){},", "onClick:", "function(){}", "}))", "具体实现参这里，本文就不贴上来了。RubyLouvre/anu那this.setState怎么转换成this.setData呢。这是一个函数调用，语法上称之为**CallExpression**。我们在visitors上定义同名的处理器。", "CallExpression(path)", "{", "var", "callee", "=", "path.node.callee", "||", "Object;", "if", "(", "modules.componentType", "===", "\"Component\"", ")", "{", "var", "property", "=", "callee.property;", "if", "(property", "&&", "property.name", "===", "\"setState\")", "{", "property.name", "=", "\"setData\";", "}", "}", "},", "至少，将React类定义转换成Component({})调用方式", "成功了。剩下就是将import语句处理一下，因为要小程序中，如果这个组件引用了其他组件，需要在其json中添加useComponens对象，将这些组件名及链接写上去。换言之，小程序太懒了，处处都要手动。有了React转码器，这些事可以省掉。其次是render方法的转换，怎么变成一个wxml文件呢，`{}单花括号的内容要转换成`\"{{}}\"`双引号＋双花括号", "，wx:if,", "wx:for的模拟等等，且听下回分解。"]}
{"author": "Rolan", "title": "微信小程序设置图片固定比例 ", "content": ["今天介绍一个让图片在任何容器都保持固定比例的方法。有时我们的图片并不是同一个比例，但是我们需要设置图片保持一个固定的比例，在小程序里面因为宽度固定为750rpx,所以我们如果需要设置宽高比为2", ":", "1的话直接设置图片css的宽为一个固定值，然后高为固定值一半就行了。这样在不同的屏幕下都能保持设定的比例。但是这样并不是很方便，比如我想封装一个自定义组件，作为列表的Cell（我是iOS开发来着。。。），我只要设置列表的宽度，Cell里面图片宽度和高度就定下来了。首先我百度到两种方法：一、调用js操作DOM在小程序内无法直接操作DOM，但是微信也是提供了接口的：wxml节点信息API1.没有封装组件时，我们可以在js文件中的onShow方法中使用：onShow:", "function()", "{", "var", "that", "=", "this", "var", "query", "=", "wx.createSelectorQuery()", "query.select(\"#image\").boundingClientRect(function(res)", "{", "console.log(res.width)", "that.setData({", "height:", "res.width", "*", "0.5", "+", "'px'", "})", "}).exec()}在css中设置图片的宽width:100%,在wxml中设置图片：<image", "class='image'", "id='image'", "src='{{imageUrl}}'", "mode='aspectFill'", "style='height:{{height}}'></image>此时，当我们设置图片父视图的宽为任意值，图片都会保持2：1的比例。2、在自定义组件中，我们需要在ready方法中使用：ready:function()", "{", "var", "that", "=", "this", "var", "query", "=", "wx.createSelectorQuery().in(this)", "//此处多了in(this)", "query.select(\"#image\").boundingClientRect(function(res)", "{", "console.log(res.width)", "that.setData({", "height:", "res.width", "*", "0.5", "+", "'px'", "})", "}).exec()}组件内CSS和WXML中设置和上方一样。这里有一个封装好的组件的简单DEMO：将封装好的组件放到scrollView内将封装好的组件放到列表页内只要设定好组件的样式，里面图片以及内容都能完美适配。二、使用padding-bottom，overflow结合，具体参考这篇博客.我照着做了，效果也出来了，但是当我放到scrollView中时，因为图片太高了（虽然看不出来），只是被隐藏了，所以导致scrollView被撑得非常高，只能设置scrollView的高度才能正常显示，但此时又显得不够动态了，所以我放弃了这种方式，推荐大家使用第一种。"]}
{"author": "Rolan", "title": "微信小程序 CSS filter（滤镜）的使用示例 ", "content": ["前言之前在看七月老师的视频的时候，看到了有一个样式是-webkit-filter，不知道是什么，于是查了一下，原来是滤镜吖。但是在微信小程序里使用的时候，下面一直飘红线，再仔细查了一下，原来是在Chrome,", "Safari,", "Opera中使用", "-webkit-filter，而微信小程序里使用的话，使用filter就可以了。一时间好奇了下，就多试了几个函数，以下是详细的笔记定义filter", "属性定义了元素(通常是)的可视效果(例如：模糊与饱和度)。分类none", "默认值，没有效果。blur()", "高斯模糊brightness()", "亮度contrast()", "对比度drop-shadow()", "阴影grayscale()", "灰度hue-rotate()", "色相旋转invert()", "反色opacity()", "透明度saturate()", "饱和度sepia()", "复古色url()", "SVG滤镜复合函数", "多个滤镜组合使用使用提示:滤镜通常使用百分比", "(如：75%),", "当然也可以使用小数来表示", "(如：0.75)。blur高斯模糊：blur(radius),给图像设置高斯模糊。\"radius\"一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，", "所以值越大越模糊；", "如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。filter:", "blur(18px);", "brightness亮度：给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。filter:", "brightness(70%);", "contrast对比度：调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。filter:", "contrast(50%);", "drop-shadow给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。", "函数接受(在CSS3背景中定义)类型的值，除了\"inset\"关键字是不允许的。该函数与已有的box-shadow", "box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。参数如下：(必须)", "这是设置阴影偏移量的两个", "值.", "设定水平方向距离.", "负值会使阴影出现在元素左边.", "设定垂直距离.负值会使阴影出现在元素上方。查看可能的单位.", "如果两个值都是0,", "则阴影出现在元素正后面", "(如果设置了", "and/or", "，会有模糊效果).", "(可选)", "这是第三个code>值.", "值越大，越模糊，则阴影会变得更大更淡.不允许负值", "若未设定，默认是0", "(则阴影的边界很锐利).", "(可选)", "这是第四个", "值.", "正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0", "(阴影会与元素一样大小).", "注意:", "Webkit,", "以及一些其他浏览器", "不支持第四个长度，如果加了也不会渲染。(可选)", "查看", "该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko", "(Firefox),", "Presto", "(Opera)和Trident", "(Internet", "Explorer)中，", "会应用colorcolor属性的值。另外,", "如果颜色值省略，WebKit中阴影是透明的。filter:", "drop-shadow(15rpx", "15rpx", "10rpx", "#999999);", "grayscalegrayscale(100%)为黑白色。灰度：将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；filter:", "grayscale(60%);", "hue-rotate色相：给图像应用色相旋转。\"angle\"一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。filter:", "hue-rotate(90deg);", "invert反相：反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。", "若值未设置，值默认是0。filter:", "invert(0.8);", "opacity透明度：转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。", "若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。filter:", "opacity(20%);", "saturate饱和度：转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。", "若值未设置，值默认是1。filter:", "saturate(0%);", "sepia褐色：复古色", "将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；filter:", "sepia(70%);", "url新建一个文本文件filter.txt，内容如下", "将文件后缀修改为.svg在代码中引用该svg文件", "style=\"filter:url('../../images/filters.svg#filter-primitives')\"", "复合函数复合函数中，多个滤镜使用空格分开。注意:", "顺序是非常重要的", "(例如使用", "grayscale()", "后再使用", "sepia()将产生一个完整的灰度图片)。filter:", "saturate(0%)", "drop-shadow(15rpx", "15rpx", "10rpx", "#999999);"]}
{"author": "Rolan", "title": "微信小程序如何获取地理位置和进行地图导航 ", "content": ["一.获取地理位置由于小程序只提供了我们一个获取地理位置、速度的api，并没有获取的相关地位位置的信息等，我们利用百度地图的api来获取地位位置。文档", "1.申请ak", "http://lbsyun.baidu.com/index.php?title=wxjsapi/guide/key2.下载百度地图的api", "，链接：http://download.csdn.net/detail/michael_ouyang/9754015", "解压后，里面有2个js文件，一个是常规没压缩的，另一个是压缩过的", "PS：由于小程序项目文件大小限制为1M，建议使用压缩版的js文件！用5kb那个js", "3.引入JS模块放在utils下", "4.在所需的js文件内导入js", "//", "引用百度地图，注意：require传入一个相对路径", "var", "bmap", "=", "require('../../utils/bmap-wx/bmap-wx.js');5.编辑代码", ".wxss代码为<view>", "<viwe>经度：{{longitude}}</viwe>", "<view>纬度：{{latitude}}</view>", "<view>地址：{{address}}</view>", "<view>城市：{{cityInfo.city}}</view>", "</view>", ".js代码为：var", "bmap", "=", "requir('../../utils/bmap-wx/bmap-wx.min.js');var", "wxMarkerData", "=", "[];", "//定位成功回调对象", "Page({", "data:", "{", "ak:", "\"FHG7utZtdyXN2\",", "//填写申请到的ak", "markers:", "[],", "longitude:", "'',", "//经度", "latitude:", "'',", "//纬度", "address:", "'',", "//地址", "cityInfo:", "{}", "//城市信息", "},", "onLoad:", "function", "(options)", "{", "var", "that", "=", "this;", "/*", "获取定位地理位置", "*/", "//", "新建bmap对象", "var", "BMap", "=", "new", "bmap.BMapWX({", "ak:", "that.data.ak", "});", "var", "fail", "=", "function", "(data)", "{", "console.log(data);", "};", "var", "success", "=", "function", "(data)", "{", "//返回数据内，已经包含经纬度", "console.log(data);", "//使用wxMarkerData获取数据", "wxMarkerData", "=", "data.wxMarkerData;", "//把所有数据放在初始化data内", "that.setData({", "markers:", "wxMarkerData,", "latitude:", "wxMarkerData[0].latitude,", "longitude:", "wxMarkerData[0].longitude,", "address:", "wxMarkerData[0].address,", "cityInfo:", "data.originalData.result.addressComponent", "});", "}", "//", "发起regeocoding检索请求", "BMap.regeocoding({", "fail:", "fail,", "success:", "success", "});", "}})", "6.运行", "注意：楼主的运行环境在模拟器上，在模拟器所获取到的定位是有一些误差的，如需测试真正的地理位置信息，还需要使用真机测试！！！结果二.进行地图导航微信小程序里面是不能导航的，原因是小程序的代码最多只能有1M，他的运行内存只能有10M，一个区域地图下载下来就不止1M了所以在应用内我们无法做到导航的，但是应用外呢！关于APP开发，一般如果导航这个功能不是很重要的话就会放到应用外来做这个功能，但是高德地图和腾讯地图都会有响应的SDK，可是小程序不同，我们该如何在小程序外调用导航功能呢？打开小程序中关于位置的API，", "1.wx.getLocation(OBJECT)", "获取当前的地理位置、速度。", "2.wx.chooseLocation(OBJECT)", "打开地图选择位置。", "3.wx.openLocation(OBJECT)", "​使用微信内置地图查看位置。查看长沙理工大学", "具体实现代码为：wx.getLocation({", "type:", "'gcj02',", "//返回可以用于wx.openLocation的经纬度", "success:", "function(res)", "{", "var", "latitude", "=", "res.latitude", "var", "longitude", "=", "res.longitude", "wx.openLocation({", "latitude:", "latitude,", "longitude:", "longitude,", "name:\"长沙理工大学\",", "scale:", "28", "})", "}})点击绿点出现如图：选择地图", "选择手机上的地图，然后就跳到了对应的地图APP上，实现了应用外调用导航功能。"]}
{"author": "Rolan", "title": "小程序生成图片库 ", "content": ["Painter由于我们无法将小程序直接分享到朋友圈，但分享到朋友圈的需求目前又很多，业界目前的做法是利用小程序的", "Canvas", "功能生成一张带有二维码的图片，然后引导用户下载图片到本地后再分享到朋友圈。而小程序", "Canvas", "功能是很难用的，往往为了绘制一张简单图片，就得写上一堆", "boilerplate", "code", "。如果此时一个小程序中包含多个绘图的需求，那绝壁要疯。另外", "Canvas", "上有很多绘图的坑，肯定会让你疯上加疯。这边说上几个小程序", "Canvas", "的坑：1，", "Canvas", "绘图是用的", "px，而在小程序中我们一般使用", "rpx", "进行相对布局。2，小程序的", "drawCanvas", "方法，在", "IDE", "中可以直接设置网络图片进行绘制，但在真机上设置网络图片无用。3，canvasContext.clip", "方法在", "iOS", "设备上", "微信", "6.6.6", "版本及以下有", "bug，会导致该", "clip", "下面使用的的", "restore", "方法失效。画家计划想到小程序中有如此大量的生成图片需求，而", "Canvas", "生成方法又是如此难用和坑爹。那我们就想到可不可以做一款可以很方便生成图片的库，而且还能屏蔽掉直接使用", "Canvas", "的那些坑呢。所以我们发起了", "“画家计划—", "通过", "json", "数据形式，来进行动态渲染并绘制出图片”。", "Painter", "库的整体架构如下：首先，我们定义了一套绘图", "JSON", "规范，开发者可以根据需求构建生成图片的", "Palette（调色板），然后在程序运行过程中把调色板传入给", "Painter（画家）。Painter", "会调用", "Pen（画笔），根据", "Palette", "内容绘制出对应的图片后返回。How", "To", "Use运行例子因该项目为", "submodule", "管理方式。首次", "clone", "代码时，需加上", "--recursive", "参数。git", "clone", "https://github.com/Kujiale-Mobile/Painter.git", "--recursive", "代码下载后，用小程序", "IDE", "打开后即可使用。使用", "Painter引入代码可以在主项目下执行以下命令，通过", "submodule", "的方式引入", "painter", "组件。建议是在", "components", "目录下。git", "submodule", "add", "https://github.com/Kujiale-Mobile/PainterCore.git", "painter", "作为自定义组件引入，注意目录为第一步引入的代码所在目录\"usingComponents\":{", "\"painter\":\"/components/painter/painter\"", "}", "组件接收", "palette", "字段作为画图数据的数据源,", "图案数据以json形式存在，推荐使用“皮肤模板”的方法进行传递，示例代码如下：", "数据传入后，则会自动进行绘图。绘图完成后，你可以通过绑定", "imgOK", "或", "onImgErr", "事件来获得成功后的图片", "或失败的原因。bind:imgOK=\"onImgOK\"", "bind:imgErr=\"onImgErr\"", "Palette", "规范如你使用", "wxss", "+", "wxml", "规范进行绘制一样，Painter", "需要根据一定的规范来进行图片绘制。当然", "Painter", "的绘制规范要比", "wxml", "简单很多。调色板属性一个调色板首先需要给予一些整体属性background:", "可以是颜色值，也可以为网络图片的链接，默认为白色", "width:", "宽度", "height:", "高度", "borderRadius:", "边框的圆角（该属性也同样适用于子", "view）", "views:", "里面承载子", "view", "子", "View", "属性当我们把整体的调色板属性构建起来后，里面就可以添加子", "View", "来进行绘制了。typecontentdescription自有cssimageurl表示图片资源的地址，本地或网络texttext文本的内容fontSize:", "文字大小，color:", "字体颜色（默认为黑色）rect无矩形color:", "颜色qrcodecontent画二维码background:", "背景颜色（默认为透明色），布局属性以上", "View", "，除去自己拥有的特别属性外，还有以下的通用布局属性属性意义rotate旋转，按照顺时针旋转的度数，默认不旋转borderRadius边界圆角程度，如果是正方形布局，该属性为一半宽或高时，则为圆形top、right、bottom、left如", "css", "中为", "absolute", "布局时的作用，默认", "top", "和", "left", "为", "0尺寸即其他1，目前", "Painter", "中支持两种尺寸单位，px", "和", "rpx，代表的意思和小程序中一致，此处就不多说。2，目前子", "view", "的", "css", "属性支持", "object", "或", "array。所以意味着，你可以把几个子", "view", "共用的", "css", "属性提取出来。做到让", "Palette", "更加简洁。3，因为我们的", "palette", "是以", "js", "承载的", "json，所以意味着你可以在每一个属性中很方便的加上自己的逻辑。也可以把某些属性单独提取出来，让多个", "palette", "共用，做到模块化。举个栗子{", "background:", "'#eee',", "width:", "'654rpx',", "height:", "'400rpx',", "borderRadius:", "'20rpx',", "views:", "[", "{", "type:", "'image',", "url:", "'https://qhyxpicoss.kujiale.com/r/2017/12/04/L3D123I45VHNYULVSAEYCV3P3X6888_3200x2400.jpg@!70q',", "css:", "{", "top:", "'48rpx',", "right:", "'48rpx',", "width:", "'192rpx',", "height:", "'192rpx',", "},", "}", "],", "}", "绘制效果如下LicenseCopyright", "(c)", "2018", "Kujiale", "Licensed", "under", "the", "Apache", "License,", "Version", "2.0", "(the", "\"License\");", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License.", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at", "http://www.apache.org/licenses/LICENSE-2.0", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing,", "software", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "\"AS", "IS\"", "BASIS,", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND,", "either", "express", "or", "implied.", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and", "limitations", "under", "the", "License."]}
{"author": "Rolan", "title": "Taro实践 - TOPLIFE小程序 开发体验 ", "content": ["前阵子，来自我们凹凸实验室的遵循React", "语法规范的", "多端开发方案", "-", "Taro", "终于对外开源了，欢迎围观", "star", "（先打波广告）。作为第一批使用了", "Taro", "开发的TOPLIFE小程序的开发人员之一，自然是走了不少弯路，躺了不少坑，也帮忙找过不少bug。现在项目总算是上线了，那么，也是时候给大家总结分享下了。与WePY比较当初开发TOPLIFE第一期的时候，用的其实是", "WePY", "（那时Taro还没有开发完成），然后在第二期才全面转换为用", "Taro", "开发。作为两个小程序开发框架都使用过，并应用在生产环境里的人，自然是要比较一下两者的异同点。相同点组件化开发npm包支持ES6+特性支持，Promise，", "Async", "Functions", "等CSS预编译器支持，Sass/Stylus/PostCSS等支持使用Redux进行状态管理…..相同的地方也不用多说什么，都2018年了，这些特性的支持都是为了让小程序开发变得更现代，更工程化，重点是区别之处。不同点开发风格实现原理WePY支持slot，Taro暂不支持直接渲染children开发风格最大的不同之处，自然就是开发风格上的差异，", "WePY", "使用的是类Vue开发风格，", "Taro", "使用的是类React", "开发风格，可以说开发体验上还是会有较大的区别。贴一下官方的demo简单阐述下。WePY", "demo<style", "lang=\"less\">", "@color:", "#4D926F;", ".userinfo", "{", "color:", "@color;", "}", "</style>", "<template", "lang=\"pug\">", "view(class='container')", "view(class='userinfo'", "@tap='tap')", "mycom(:prop.sync='myprop'", "@fn.user='myevent')", "text", "{{now}}", "</template>", "<script>", "import", "wepy", "from", "'wepy';", "import", "mycom", "from", "'../components/mycom';", "export", "default", "class", "Index", "extends", "wepy.page", "{", "components", "=", "{", "mycom", "};", "data", "=", "{", "myprop:", "{}", "};", "computed", "=", "{", "now", "()", "{", "return", "new", "Date().getTime();", "}", "};", "async", "onLoad()", "{", "await", "sleep(3);", "console.log('Hello", "World');", "}", "sleep(time)", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "setTimeout(resolve,", "time", "*", "1000));", "}", "}", "</script>Taro", "demoimport", "Taro,", "{", "Component", "}", "from", "'@tarojs/taro'", "import", "{", "View,", "Button", "}", "from", "'@tarojs/components'", "export", "default", "class", "Index", "extends", "Component", "{", "constructor", "()", "{", "super(...arguments)", "this.state", "=", "{", "title:", "'首页',", "list:", "[1,", "2,", "3]", "}", "}", "componentWillMount", "()", "{}", "componentDidMount", "()", "{}", "componentWillUpdate", "(nextProps,", "nextState)", "{}", "componentDidUpdate", "(prevProps,", "prevState)", "{}", "shouldComponentUpdate", "(nextProps,", "nextState)", "{", "return", "true", "}", "add", "=", "(e)", "=>", "{", "//", "dosth", "}", "render", "()", "{", "return", "(", "<View", "className='index'>", "<View", "className='title'>{this.state.title}</View>", "<View", "className='content'>", "{this.state.list.map(item", "=>", "{", "return", "(", "<View", "className='item'>{item}</View>", ")", "})}", "<Button", "className='add'", "onClick={this.add}>添加</Button>", "</View>", "</View>", ")", "}", "}可以见到在", "WePY", "里，", "css", "、", "template", "、", "script", "都放在一个wpy文件里，", "template", "还支持多种模板引擎语法，然后支持", "computed", "、", "watcher", "等属性，这些都是典型的Vue风格。而在", "Taro", "里，就是彻头彻尾的", "React", "风格，包括", "constructor", "，", "componentWillMount", "、", "componentDidMount", "等各种", "React", "的生命周期函数，还有", "return", "里返回的", "jsx", "，熟悉", "React", "的人上手起来可以说是非常快了。除此之外还有一些细微的差异之处：WePY", "里的模板，或者说是", "wxml", "，用的都是小程序里原生的组件，就是小程序文档里的各种组件；而Taro里使用的每个组件，都需要从", "@tarojs/components", "里引入，包括", "View", "，", "Text", "等基础组件（这种做其实是为了转换多端做准备）事件处理上Taro", "中，是用", "click", "事件代替", "tap", "事件WePY使用的是简写的写法@+事件；而Taro则是on+事件名称阻止冒泡上WePY用的是@+事件.stop；而Taro则是要显式地使用", "e.stopPropagation()来阻止冒泡事件传参WePY可以直接在函数后面传参，如", "@tap=\"click({{index}})\"", "；而Taro则是使用", "bind", "传参，如", "onClick={this.handleClick.bind(null,", "params)}WePY使用的是小程序原生的生命周期，并且组件有", "page", "和", "component", "的区分；Taro", "则是自己实现了类似React", "的生命周期，而且没有", "page", "和", "component", "的区分，都是", "component总的来说，毕竟是两种不同的开发风格，自然还是会有许多大大小小的差异。在这里与当前很流行的小程序开发框架之一", "WePY", "进行简单对比，主要还是为了方便大家更快速地了解", "Taro", "，从而选择更适合自己的开发方式。实践体验Taro", "官方提供的demo", "是很简单的，主要是为了让大家快速上手，入门。那么，当我们要开发偏大型的项目时，应该如何使用", "Taro", "使得开发体验更好，开发效率更高？作为深度参与TOPLIFE小程序开发的人员之一，谈一谈我的一些实践体验及心得如何组织代码使用taro-cli生成模板是这样的├──", "dist", "编译结果目录", "├──", "config", "配置目录", "|", "├──", "dev.js", "开发时配置", "|", "├──", "index.js", "默认配置", "|", "└──", "prod.js", "打包时配置", "├──", "src", "源码目录", "|", "├──", "pages", "页面文件目录", "|", "|", "├──", "index", "index页面目录", "|", "|", "|", "├──", "index.js", "index页面逻辑", "|", "|", "|", "└──", "index.css", "index页面样式", "|", "├──", "app.css", "项目总通用样式", "|", "└──", "app.js", "项目入口文件", "└──", "package.json假如引入了redux，例如我们的项目，目录是这样的├──", "dist", "编译结果目录", "├──", "config", "配置目录", "|", "├──", "dev.js", "开发时配置", "|", "├──", "index.js", "默认配置", "|", "└──", "prod.js", "打包时配置", "├──", "src", "源码目录", "|", "├──", "actions", "redux里的actions", "|", "├──", "asset", "图片等静态资源", "|", "├──", "components", "组件文件目录", "|", "├──", "constants", "存放常量的地方，例如api、一些配置项", "|", "├──", "reducers", "redux里的reducers", "|", "├──", "store", "redux里的store", "|", "├──", "utils", "存放工具类函数", "|", "├──", "pages", "页面文件目录", "|", "|", "├──", "index", "index页面目录", "|", "|", "|", "├──", "index.js", "index页面逻辑", "|", "|", "|", "└──", "index.css", "index页面样式", "|", "├──", "app.css", "项目总通用样式", "|", "└──", "app.js", "项目入口文件", "└──", "package.jsonTOPLIFE小程序整个项目大概3万行代码，数十个页面，就是按上述目录的方式组织代码的。比较重要的文件夹主要是", "pages", "、", "components", "和", "actions", "。pages里面是各个页面的入口文件，简单的页面就直接一个入口文件可以了，倘若页面比较复杂那么入口文件就会作为组件的聚合文件，", "redux", "的绑定一般也是在这里进行。组件都放在", "components", "里面。里面的目录是这样的，假如有个", "coupon", "优惠券页面，在", "pages", "自然先有个", "coupon", "，作为页面入口，然后它的组件就会存放在", "components/coupon", "里面，就是", "components", "里面也会按照页面分模块，公共的组件可以建一个", "components/public", "文件夹，进行复用。这样的好处是页面之间", "互相独立", "，", "互不影响", "。所以我们几个开发人员，也是按照页面的维度来进行分工，互不干扰，大大提高了我们的开发效率。actions这个文件夹也是比较重要，这里处理的是拉取数据，数据再处理的逻辑。可以说，数据处理得好，流动清晰，整个项目就成功了一半，具体可以看下面***更好地使用redux***的部分。如上，假如是", "coupon", "页面的", "actions", "，那么就会放在", "actions/coupon", "里面，可以再一次见到，所有的模块都是以页面的维度来区分的。除此之外，", "asset", "文件用来存放的静态资源，如一些icon类的图片，但建议不要存放太多，毕竟程序包有限制。而", "constants", "则是一些存放常量的地方，例如", "api", "域名，配置等等。只要按照上述或类似的代码组织方式，遵循规范和约定，开发大型项目时不说能提高多少效率，至少顺手了很多。更好地使用reduxredux大家应该都不陌生，一种状态管理的库，通常会搭配一些中间件使用。我们的项目主要是用了", "redux-thunk", "和", "redux-logger", "中间件，一个用于处理异步请求，一个用于调试，追踪", "actions", "。数据预处理相信大家都遇到过这种时候，接口返回的数据和页面显示的数据并不是完全对应的，往往需要再做一层预处理。那么这个业务逻辑应该在哪里管理，是组件内部，还是", "redux", "的流程里？举个例子：例如上图的购物车模块，接口返回的数据是{", "code:", "0,", "data:", "{", "shopMap:", "{...},", "//", "存放购物车里商品的店铺信息的map", "goods:", "{...},", "//", "购物车里的商品信息", "...", "}", "...", "}对的，购车里的商品店铺和商品是放在两个对象里面的，但视图要求它们要显示在一起。这时候，如果直接将返回的数据存到", "store", "，然后在组件内部", "render", "的时候东拼西凑，将两者信息匹配，再做显示的话，会显得组件内部的逻辑十分的混乱，不够纯粹。所以，我个人比较推荐的做法是，在接口返回数据之后，直接将其处理为与页面显示对应的数据，然后再", "dispatch", "处理后的数据，相当于做了一层拦截，像下面这样：const", "data", "=", "result.data", "//", "result为接口返回的数据", "const", "cartData", "=", "handleCartData(data)", "//", "handleCartData为处理数据的函数", "dispatch({type:", "'RECEIVE_CART',", "payload:", "cartData})", "//", "dispatch处理过后的函数", "...", "//", "handleCartData处理后的数据", "{", "commoditys:", "[{", "shop:", "{...},", "//", "商品店铺的信息", "goods:", "{...},", "//", "对应商品信息", "},", "...]", "}可以见到，处理数据的流程在render前被拦截处理了，将对应的商品店铺和商品放在了一个对象了.这样做有几个好处一个是组件的渲染", "更纯粹", "，在组件内部不用再关心如何将数据修修改改而满足视图要求，", "只需关心组件本身的逻辑", "，例如点击事件，用户交互等二是数据的流动", "更可控", "，假如后续后台返回的数据有变动，我们要做的只是改变", "handleCartData", "函数里面的逻辑，不用改动组件内部的逻辑。后台数据——>拦截处理——>期望的数据结构——>组件实际上，不只是后台数据返回的时候，其它数据结构需要变动的时候都可以做一层数据拦截，拦截的时机也可以根据业务逻辑调整，重点是要让组件内部本身不关心", "数据与视图是否对应，只专注于内部交互的逻辑", "，这也很符合", "React", "本身的初衷，数据驱动视图。connect可以做更多的事情connect", "大家都知道是用来连接", "store", "、", "actions", "和组件的，很多时候就只是根据样板代码复制一下，改改组件各自的", "store", "、", "actions", "。实际上，我们还可以做一些别的处理，例如：export", "default", "connect(({", "cart,", "})", "=>", "({", "couponData:", "cart.couponData,", "commoditys:", "cart.commoditys,", "editSkuData:", "cart.editSkuData", "}),", "(dispatch)", "=>", "({", "//", "...actions绑定", "}))(Cart)", "//", "组件里", "render", "()", "{", "const", "isShowCoupon", "=", "this.props.couponData.length", "!==", "0", "return", "isShowCoupon", "&&", "<Coupon", "/>", "}", "上面是很普通的一种", "connect", "写法，然后", "render", "函数根据", "couponData", "里是否数据来渲染。这时候，我们可以把", "this.props.couponData.length", "!==", "0", "这个判断丢到", "connect", "里，达成一种", "computed", "的效果，如下：export", "default", "connect(({", "cart,", "})", "=>", "{", "const", "{", "couponData,", "commoditys,", "editSkuData", "}", "=", "cart", "const", "isShowCoupon", "=", "couponData.length", "!==", "0", "return", "{", "isShowCoupon,", "couponData,", "commoditys,", "editSkuData", "}},", "(dispatch)", "=>", "({", "//", "...actions绑定", "}))(Cart)", "//", "组件里", "render", "()", "{", "return", "this.props.isShowCoupon", "&&", "<Coupon", "/>", "}", "可以见到，在", "connect", "里定义了", "isShowCoupon", "变量，实现了根据", "couponData", "来进行", "computed", "的效果。实际上，这也是一种数据拦截处理。除了", "computed", "，还可以实现其它的功能，具体就由各位看官自由发挥了。项目感受要说最大的感受，就是在开发的过程中，", "有时会忘记了自己在写小程序，还以为是在写React页面", "。是的，有次我想给页面绑定一个滚动事件，才醒悟根本就没有", "doucment.body.addEventListener", "这种东西。在使用", "WePY", "过程中，那些奇奇怪怪的语法还是时常提醒着我这是小程序，不是h5页面，而在用", "Taro", "的时候，这个差异化已经被消磨得很少了。尽管还是有一定的限制，但我基本上就是用开发React的习惯来使用", "Taro", "，可以说极大地提高了我的开发体验。一些需要注意的地方那", "Taro", "，或者是小程序开发，有没有什么要注意的地方？当然有，走过的弯路可以说是非常多了。页面栈只有10层估计是每个页面的数据在小程序内部都有缓存，所以做了10层的限制。带来的问题就是假如页面存在循环跳转，即A页面可以跳到B页面，B页面也可以跳到A页面，然后用户从A进入了B，想返回A的时候，往往是直接在B页面里点击跳转到A，", "而不是点返回", "回到A，如此一来，10层很快就突破了。所以我们自己对", "navigateTo", "函数做了一层封装，防止溢出。页面内容有缓存上面说到，页面内容有缓存。所以假如某个页面是根据不同的数据渲染视图，新渲染时会有上一次渲染的缓存，导致页面看起来有个闪烁的变化，用户体验非常不好。其实解决的办法也很简单，每次在", "componentWillUnmount", "生命周期中清理一下当前页面的数据就好了。小程序说到底不是h5，不会说每次进入页面就会刷新，也不会离开就销毁，刷新"]}
{"author": "Rolan", "title": "微信小程序 CSS 选择器::after和::before的简单使用 ", "content": ["前言前两天看文档看到选择器那块儿的时候，前面4个基本都能理解：.class，#id，element，element,", "element，但后面两个::after和::before（文档中说，分别表示在view", "组件的后面和前面插入内容），表示有点没有理解。于是上网仔细查了下。以下是笔记image基本概念::before", "用法：view::before，表示在该view组件的前面加入内容", "::after", "用法：view::after，表示在该view组件的后面加入内容", "这里是双冒号，不是单冒号。单冒号是CSS2的内容，双冒号是CSS3的内容。当然微信小程序也是兼容CSS2的写法的", "这种在组件的前面和后面加入内容，其实有点类似Android中的给TextView四周加图片的做法，setCompoundDrawables(Drawable", "left,", "Drawable", "top,", "Drawable", "right,", "Drawable", "bottom)（原谅我这里有点强行建立联系的奇怪思路）用法wxml<view", "class=\"container\">", "<view", "class=\"price\">{{price}}</view></view>wxss.container", "{", "width:", "auto;", "margin:", "30rpx;", "background-color:", "#fff;", "text-align:", "center;}.price", "{", "position:", "relative;", "display:", "inline-block;", "font-size:", "78rpx;", "color:", "red;}.price::before", "{", "content:", "\"金额：¥\";", "position:", "absolute;", "font-size:", "40rpx;", "top:", "30rpx;", "left:", "-160rpx;", "color:", "black;}.price::after", "{", "content:", "\".00", "元\";", "font-size:", "30rpx;", "top:", "40rpx;", "position:", "absolute;", "right:", "-90rpx;", "color:", "black;}jsPage({", "onLoad:", "function()", "{", "this.setData({", "price:", "100", "})", "}})效果image其他其实，after和before可以添加的不仅仅是像上面这种字符串，以下是可以添加的常用的内容String", "静态字符串attr", "动态内容url/uri", "用于引用媒体文件counter", "计数器，可以实现序号功能"]}
{"author": "Rolan", "title": "百度智能小程序介绍 ", "content": ["手百智能小程序介绍智能小程序是一种新的开放能力，开发者可以快速地开发一个智能小程序。通过搜索，用户可以在手百", "App", "内被便捷地获取和传播。框架概述SWAN", "App", "基本开发思路类似于前端开发，并增强调用大量端能力，性能体验优于普通", "Web", "。上层架构基于", "JS", "开发，可以辅助开发者进行良好得开发。SWAN", "App", "为开发者提供了", "MVVM", "的开发方式。JS", "状态的变更引起视图的变化，视图的变更也可以回馈到逻辑层的状态中，开发者开发更加方便。目录结构工程的工作目录中包含以下文件：|____app.css|____app.json|____project.swan.json|____pages|", "|____detail|", "|", "|____detail.css|", "|", "|____detail.swan|", "|", "|____detail.js|", "|____index|", "|", "|____index.js|", "|", "|____index.swan|", "|", "|____index.css|____app.js我们看到以下几类的文件：1、", ".json", "为后缀的", "JSON", "配置文件，这个文件配置了", "SWAN", "智能小程序所有页面的路径和界面展现样式等；2、", ".swan", "结尾的", "SWAN", "模板文件，这个文件是用来描述当前这个页面的文件结构，类似于网页网页中的", "HTML", "文件；3、", ".css", "结尾的", "CSS", "样式文件，描述页面样式；4、", ".js", "结尾的", "JS", "文件，处理这个页面和用户的交互。"]}
{"author": "天下雪", "title": "微信小程序架构分析《一》调试技巧，模块构成，理念分析 ", "content": ["本文分为以下几个部分：小程序调试技巧小程序主要模块构成小程序模块间通信设计理念分析小程序调试技巧微信开发者工具默认禁用了右键打开调试面板功能，我们可以修改开发者工具部分代码移除该限制。找到", "app.nw", "项目根目录，Mac", "下为/Applications/wechatwebdevtools.app/Contents/Resources/app.nw使用", "js-beautify", "对代码批量格式化：cd", "/Applications/wechatwebdevtools.app/Contents/Resources/app.nw", "find", ".", "-type", "f", "-name", "'*.js'", "-not", "-path", "\"./node_modules/*\"", "-not", "-path", "\"./modified_modules/*\"", "-exec", "js-beautify", "-r", "-s", "2", "-p", "-f", "'{}'", "\\;", "注释掉文件", "app/dist/app.js", "44", "行和app/dist/components/simulator/webviewbody.js", "149", "行preventDefault", "调用。101100", "版本还需要修改", "package.json", "文件，去掉", "--disable-devtools。执行完以上操作就可以右键打开页面的调试面板了，需要特别注意的是，使用", "view", "页面的面板后会导致", "wxml", "面板不可用，touch", "事件无法响应等种种问题，请慎重使用。通过代码可以发现，在配置目录下添加", "config.json", "文件，然后加入{isDev:true}", "可以启用开发者工具所谓的调试模式，", "但是我在配置后程序无法正常启动，只好暂时先放弃这种方式。小程序主要模块构成小程序自身分为两个主要部分独立运行：view", "模块和", "service", "模块。在开发者工具中，它们独立运行于不同的", "webivew", "tag", "中。view", "模块负责", "UI", "显示，它由开发者编写的", "wxml", "和", "wxss", "转换后代码以及微信提供相关辅助模块组成。", "一个", "view", "模块对应一个", "webview", "组件（也就是我们常规理解的一个页面）,", "小程序支持同时多个", "view", "存在。view", "模块通过", "WeixinJSBridge", "对象来跟后台通信。service", "模块负责应用的后台逻辑，它由小程序的", "js", "代码以及微信提供的相关辅助模块组成。", "一个应用只有一个", "service", "进程，它同样也是一个页面（至少在开发者工具内如此，上线后可能运行于", "WeixinJSCore", "之内），与", "view", "模块不同的是，它在程序生命周期内后台运行，service", "模块通过与", "view", "模块实现不同但接口格式一样的", "WeixinJSBridge", "对象跟后台通信。小程序模块间通信(开发者工具内各模块通信图)做过微信开发相关的开发者会对", "WeixinJSBridge", "这个对象有所了解，它就是负责", "UI", "与后台", "进行交互的一个中间层。应用号的", "WeixinJSBridge", "相比与之前的微信", "webview", "多出", "publish", "和", "subscribe", "两个公共方法来发布和订阅事件，从而进行双向通信。service", "模块的", "WeixinJSBridge", "对象在文件app/dist/weapp/appservice/asdebug.js", "中定义，", "view", "层的", "WeixinJSBridge", "在文件", "app/dist/inject/jweixindebug.js", "中定义。", "尽管两者都使用一样的接口以及使用", "postMessage", "方法与后台通信，但是其内部所做的事情确是完全不同的，", "例如", "service", "模块可以直接通过", "prompt", "方法来通过", "prompt调起底层组件，而", "view", "层的", "WeixinJSBridge", "只能发送消息", "(参考", "H5与Native交互之JSBridge技术)。我们来看一个典型的交互流程：用户点击界面触发事件对应", "view", "模块接收事件后将事件封装成所需格式后调用", "publish", "方法发送:WeixinJSBridge.publish('PAGE_EVENT',", "data)", "data", "参数举例：{", "\"data\":", "{", "\"eventName\":", "\"onhidetap\",", "\"data\":", "{", "\"target\":", "{", "...", "},", "\"currentTarget\":", "{", "...", "},", "\"type\":", "\"tap\",", "\"timeStamp\":", "11457,", "\"touches\":", "[", "...", "],", "\"detail\":", "{", "...", "}", "}", "},", "\"options\":", "{", "\"timestamp\":", "1475445858336", "}", "}", "后台(开发者工具内为", "nwjs", "运行环境)将数据处理后发送给", "service", "模块，数据形如：{", "\"to\":", "\"appservice\",", "\"msg\":", "{", "\"eventName\":", "\"PAGE_EVENT\",", "\"data\":", "{", "\"data\":", "{", "\"eventName\":", "\"onhidetap\",", "\"data\":", "{", "\"target\":", "{", "...", "},", "\"currentTarget\":", "{", "...", "},", "\"type\":", "\"tap\",", "\"timeStamp\":", "75329,", "\"touches\":", "[", "...", "],", "\"detail\":", "{", "...", "}", "}", "},", "\"options\":", "{", "\"timestamp\":", "1475445858336", "}", "},", "\"webviewID\":", "0", "},", "\"command\":", "\"MSG_FROM_WEBVIEW\"", "}", "service", "模块的", "WeixinJSBridge", "内回调函数依据传来数据找到对应", "view", "的", "page", "模块后执行", "对应名为", "eventName", "指向的函数回调函数调用", "this.setData({hidden:", "true})", "改变", "data，serivce", "层计算该页面", "data", "后向后台发送", "send_app_data", "和", "appdataChange", "事件，具体数据格式如下：{", "\"appData\":", "{", "\"page/index\":", "{", "...", "}", "},", "\"sdkName\":", "\"send_app_data\",", "\"to\":", "\"backgroundjs\",", "\"comefrom\":", "\"webframe\",", "\"command\":", "\"COMMAND_FROM_ASJS\",", "\"appid\":", "\"touristappid\",", "\"appname\":", "\"chat\",", "\"apphash\":", "70475629,", "\"webviewID\":", "100000", "}", "{", "\"eventName\":", "\"appDataChange\",", "\"data\":", "{", "\"data\":", "{", "\"data\":", "{", "\"hidden\":", "true", "}", "},", "\"options\":", "{", "\"timestamp\":", "1475528706311", "}", "},", "\"sdkName\":", "\"publish\",", "\"webviewIds\":", "[", "0", "],", "\"to\":", "\"backgroundjs\",", "\"comefrom\":", "\"webframe\",", "\"command\":", "\"COMMAND_FROM_ASJS\",", "\"appid\":", "\"touristappid\",", "\"appname\":", "\"chat\",", "\"apphash\":", "70475629,", "\"webviewID\":", "100000", "}", "后台(文件", "dist/components/simulator/webviewbody.js)", "接收到appDataChange", "事件数据后再将数据进行简单封装，", "最后转发给到", "view", "层。", "具体数据格式为：{", "\"to\":", "\"webframe\",", "\"msg\":", "{", "\"eventName\":", "\"appDataChange\",", "\"data\":", "{", "\"data\":", "{", "\"data\":", "{", "\"hidden\":", "true", "}", "},", "\"options\":", "{", "\"timestamp\":", "1475528706311", "}", "},", "\"sdkName\":", "\"publish\",", "\"webviewIds\":", "[", "0", "],", "\"to\":", "\"backgroundjs\",", "\"comefrom\":", "\"webframe\",", "\"command\":", "\"COMMAND_FROM_ASJS\",", "\"appid\":", "\"touristappid\",", "\"appname\":", "\"chat\",", "\"apphash\":", "70475629,", "\"webviewID\":", "100000,", "\"act\":", "\"sendMsgFromAppService\"", "},", "\"command\":", "\"MSG_FROM_APPSERVICE\",", "\"webviewID\":", "0,", "\"id\":", "0.10577065353216675", "}", "view", "层的", "WeixinJSBridge", "接收到后台的数据，如果", "webviewID", "匹配则将", "data", "与现有页面", "data", "合并，", "然后就是", "virtual", "dom", "模块进行", "diff", "和", "apply", "操作改变", "dom。小程序模块间消息传递除了界面事件和应用数据还包括触发原生方法、握手以及生命周期等类型，", "尽管处理对象和处理方式不同，大体流程跟上面是一样的。view", "模块和", "service", "模块的", "WeixinJSBridge", "都使用了", "postMessage", "接口", "(参考MDN", "文档)", "与后台通信，但是由于该接口无法直接与", "nwjs", "后台进程通信，所以开发者工具会将", "app/dist/contentscript/contentScript.js", "文件做为contentScript", "注入到", "view", "模块和", "service", "模块所在页面，contentScript.js", "的代码提供了", "message", "消息到", "chrome.runtime通信接口的转换。微信开发者工具扩展了", "devtools", "提供了", "AppData", "面板，开发者可以修改里面数据然后直接看到", "view", "界面的变化效果。这里修改数据后", "nwjs", "会将消息发送给", "service", "层，之后发生的事就跟上面", "4", "5", "6", "步一样：service", "传递消息给", "nwjs，最后到", "view", "层。设计理念分析小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作，", "同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制，", "另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的", "js", "代码里面是不能直接使用浏览器提供的", "DOM", "和", "BOM", "接口的，这一方面是因为", "js", "代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作", "DOM", "和", "BOM", "接口，它们对应的", "也是", "service", "模块页面，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图", "API", "被设计成生成一个最终对象而不是一步一步执行的样子，", "原因就是", "json", "格式的数据传递和解析相比与原生", "API", "都是损耗不菲的，如果频繁调用很可能损耗", "过多性能，进而影响用户体验。理解了以上机制，再对", "view", "模块和", "service", "模块的", "WeixinJSBridge", "加以改造，我们便不难做到让", "小程序跑在自己的环境下，这样就可以做些手机调试以及单页面测试等操作。"]}
{"author": "天下雪", "title": "微信小程序架构分析《二》：view 模块和 service 模块的构成 ", "content": ["你可以在app.nw/app/dist/weapp/tpl/pageFrameTpl.js", "和app.nw/app/dist/weapp/tpl/appserviceTpl.js", "文件内找到页面的模板。打开微信", "web", "开发者工具，然后输入", "openVendor()", "便会打开", "WeappVendor这个目录，这里包含了", "view", "模块和", "service", "模块使用的几个核心文件：wcc", "可执行程序，用于将", "wxml", "转为", "view", "模块使用的", "js", "代码，使用方式为wcc", "xxx.wxmlwcsc", "可执行程序，用于将", "wxss", "转为", "view", "模块使用的", "css", "代码，使用方式为", "wcsc", "xxx.wxssWAService.js", "提供", "service", "模块大部分功能，下面会有详细介绍WAWebview.js", "提供", "view", "模块大部分功能，下面会有详细介绍view", "页面详解view", "页面的", "template", "如下：<!DOCTYPE", "html>", "<html", "lang=\"zh-CN\">", "<head>", "<link", "href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\"", "rel=\"Shortcut", "Icon\">", "<meta", "charset=\"UTF-8\"", "/>", "<meta", "name=\"viewport\"", "content=\"width=device-width,", "user-scalable=no,", "initial-scale=1.0,", "maximum-scale=1.0,", "minimum-scale=1.0\"", "/>", "<script>", "var", "__webviewId__;", "</script>", "<!--", "percodes", "-->", "<!--{{WAWebview}}-->", "<!--{{reportSDK}}-->", "<!--{{webviewSDK}}-->", "<!--{{exparser}}-->", "<!--{{components_js}}-->", "<!--{{virtual_dom}}-->", "<!--{{components_css}}-->", "<!--{{allWXML}}-->", "<!--{{eruda}}-->", "<!--{{style}}-->", "<!--{{currentstyle}}-->", "<!--{{generateFunc}}-->", "</head>", "<body>", "<div></div>", "</body>", "</html>", "其中", "<!--", "percodes", "-->", "会在", "dev", "模式开启后被替换为一个时间锚点，例如：<script>var", "pageFrameStartTime", "=", "new", "Date();</script>", "<!--{{WAWebview}}-->", "会被", "WAWebview.js", "内代码替换<!--{{WAWebview}}-->", "到", "<!--{{generateFunc}}-->", "之间暂时没有被使用到<!--{{generateFunc}}-->", "会被", "wcc", "命令生成后的", "js", "代码替换除了上面这些，页面上还会被插入页面和应用的", "style", "标签，如：<link", "rel=\"stylesheet\"", "type=\"text/css\"", "href=\"index.wxss\">", "这里的", "wxss", "文件包含的是原始", "wxss", "文件转换后的", "css以及生成", "DOM", "的启动脚本：<script>", "document.dispatchEvent(new", "CustomEvent(\"generateFuncReady\",", "{", "detail:", "{", "generateFunc:", "$gwx('./page/index.wxml')", "}", "}))", "</script>", "WAWebview.js", "文件中的各个模块(行号为", "jsbeautify", "之后代码行号，开发者工具版本：092300)：1-77", "行：", "WeixinJSBridge", "对象兼容层，这个大概只会在调试时用到，因为开发时和运行时页面都会被后台以注入的方式添加", "WeixinJSBridge", "这个对象。我们可以通过这段代码看到它暴露的方法：", "invoke", "invokeCallbackHandleron", "publish", "subscribe", "subscribe", "subscribeHandler。78-235", "行：Reporter", "对象，它的作用就是发送错误和性能统计数据给后台236-596", "行：wx", "对象，页面的核心之一，一方面封装", "WeixinJSBridge", "的", "invokeMethod", "方位为易于调用的形式（例如", "redirectTo,", "navigateTo等），另一方面封装", "WeixinJSBridge", "回调方法，调用者可以使用wx.onAppDataChange(callback)", "添加数据变更的回调函数，最后提供wx.publishPageEvent", "发送页面事件到后台607-1267", "行：wxparser", "对象，提供", "dom", "到", "wx", "element", "对象之间的映射操作，提供元素操作管理和事件管理功能1268-1285", "行：转发", "window", "上的", "animation", "和", "transition", "相关的动画事件到", "exparser1286-1313", "行：订阅并转发", "WeixinJSBridge", "提供的全局事件到", "exparser1324-1345", "行：转发", "window", "上的", "error", "以及各种表单事件到", "exparser1347-3744", "行：使用", "exparser.registerBehavior", "和exparser.registerElement", "方法注册各种以", "wx-", "做为标签开头的元素到", "exparser3744-4498", "行：virtual", "dom", "渲染算法实现，提供", "diff", "apply", "render", "等方法，该模块接口基本与", "virtual-dom", "一致，这里特别的地方在于它所", "diff", "和生成的并不是原生", "DOM，而是各种模拟了", "DOM", "接口的", "wx", "element", "对象4599-4510", "行：插入默认样式到页面从页面", "data", "到", "dom", "的主要流程如下：var", "vtree", "var", "rootNode", "document.addEventListener(\"generateFuncReady\",", "function(e)", "{", "var", "generateFunc", "=", "e.detail.generateFunc;", "wx.onAppDataChange(function(obj)", "{", "//", "合并", "data", "到现有", "data", "DataStore.setData(obj.data)", "//", "生成", "virtual", "dom", "的", "javascript", "plain", "object", "var", "props", "=", "generateFunc(DataStore.getData())", "//", "第一次渲染", "if", "(obj.options.firstRender)", "{", "vtree", "=", "createVirtualTree(props,", "true)", "rootNode", "=", "vtree.render()", "rootNode.replaceDocumentElement(document.body)", "wx.initReady()", "}", "else", "{", "var", "other_vtree", "=", "createVirtualTree(props,", "false)", "var", "patches", "=", "vtree.diff(other_vtree)", "patches.apply(rootNode)", "vtree", "=", "other_vtree", "document.dispatchEvent(new", "CustomEvent(\"pageReRender\",", "{}));", "}", "})", "})", "上面的", "DataStore", "对象提供合并和获取当前页面", "data", "对象的功能，其实现如下：var", "DataStore", "=", "(function()", "{", "var", "data", "=", "{}", "return", "{", "getData:", "function()", "{", "return", "data", "},", "setData:", "function(e)", "{", "for", "(var", "t", "in", "e)", "{", "for", "(var", "n", "=", "(0,", "parsePath)(t),", "o", "=", "data,", "a", "=", "void", "0,", "s", "=", "void", "0,", "c", "=", "0;", "c", "<", "n.length;", "c++)", "Number(n[c])", "===", "n[c]", "&&", "Number(n[c])", "%", "1", "===", "0", "?", "Array.isArray(o)", "||", "(a[s]", "=", "[],", "o", "=", "a[s])", ":", "\"[object", "Object]\"", "!==", "Object.prototype.toString.call(o)", "&&", "(a[s]", "=", "{},", "o", "=", "a[s]),", "s", "=", "n[c],", "a", "=", "o,", "o", "=", "o[n[c]];", "a", "&&", "(a[s]", "=", "e[t])", "}", "}", "}", "})()", "//", "解析", "key", "为", "data", "内对象的路径字符串", "function", "parsePath(e)", "{", "for", "(var", "t", "=", "e.length,", "n", "=", "[],", "i", "=", "\"\",", "r", "=", "0,", "o", "=", "!1,", "a", "=", "!1,", "s", "=", "0;", "s", "<", "t;", "s++)", "{", "var", "c", "=", "e[s];", "if", "(\"\\\\\"", "===", "c)", "s", "+", "1", "<", "t", "&&", "(\".\"", "===", "e[s", "+", "1]", "||", "\"[\"", "===", "e[s", "+", "1]", "||", "\"]\"", "===", "e[s", "+", "1])", "?", "(i", "+=", "e[s", "+", "1],", "s++)", ":", "i", "+=", "\"\\\\\";", "else", "if", "(\".\"", "===", "c)", "i", "&&", "(n.push(i),", "i", "=", "\"\");", "else", "if", "(\"[\"", "===", "c)", "{", "if", "(i", "&&", "(n.push(i),", "i", "=", "\"\"),", "0", "===", "n.length)", "throw", "new", "Error(\"path", "can", "not", "start", "with", "[]:", "\"", "+", "e);", "a", "=", "!0,", "o", "=", "!1", "}", "else", "if", "(\"]\"", "===", "c)", "{", "if", "(!o)", "throw", "new", "Error(\"must", "have", "number", "in", "[]:", "\"", "+", "e);", "a", "=", "!1,", "n.push(r),", "r", "=", "0", "}", "else", "if", "(a)", "{", "if", "(c", "<", "\"0\"", "||", "c", ">", "\"9\")", "throw", "new", "Error(\"only", "number", "0-9", "could", "inside", "[]:", "\"", "+", "e);", "o", "=", "!0,", "r", "=", "10", "*", "r", "+", "c.charCodeAt(0)", "-", "48", "}", "else", "i", "+=", "c", "}", "if", "(i", "&&", "n.push(i),", "0", "===", "n.length)", "throw", "new", "Error(\"path", "can", "not", "be", "empty\");", "return", "n", "}", "可以看到，每次", "data", "变化之后，小程序就会开始整个页面的", "diff", "patch", "过程。对于原生实现的组件，", "exparser", "会在监视到数据变化后发送对应事件到", "WeixinJSBridge。service", "页面详解service", "页面会被被拼接为以下的样子：<!DOCTYPE", "html>", "<html>", "<head>", "<meta", "http-equiv=\"Content-Type\"", "content=\"text/html;", "charset=utf-8\"", "/>", "<link", "href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\"", "rel=\"Shortcut", "Icon\">", "<script>", "var", "__wxAppData", "=", "{}", "var", "__wxRoute", "var", "__wxRouteBegin", "</script>", "<script>var", "__wxConfig", "=", "{\"pages\":[\"page/index\"],", "//", "app", "相关各种配置", "}</script>", "<script", "src=\"http://70475629.appservice.open.weixin.qq.com/asdebug.js\"></script>", "<script", "src=\"http://70475629.appservice.open.weixin.qq.com/WAService.js\"></script>", "<script", "src=\"http://70475629.appservice.open.weixin.qq.com/app.js\"></script>", "<script>", "__wxRoute", "=", "'page/index';", "__wxRouteBegin", "=", "true", "</script>", "<script", "src=\"http://70475629.appservice.open.weixin.qq.com/page/index.js\"></script>", "</head>", "<body>", "<script>", "window._____sendMsgToNW({", "sdkName:", "'APP_SERVICE_COMPLETE'", "})", "</script>", "</body>", "</html>", "除了配置和开发者编写的页面、app.js，页面还在加载了", "asdebug.js", "和", "WAService.js", "两个文件。asdebug.js", "文件位于", "nwjs", "项目目录下，路径为app/dist/weapp/appservice/asdebug.js。", "它包含了两个部分，一个是", "WeixinJSBridge", "针对", "service", "模块的实现，另一块是一些方便命令使用的接口，", "例如：help()", "会告诉你一些可用的函数：该文件只会在开发者工具内被引入，如果小程序在微信内运行，应该会由微信底层提供", "WeixinJSBridge。WAService", "负责", "service", "模块的一些核心逻辑，它包含以下部分", "(行号为", "jsbeautify", "之后代码行号，开发者工具版本：092300)：1-78", "行：", "跟", "WAWebview.js", "一样的", "WeixinJSBridge", "兼容模块79-245", "行：", "跟", "WAWebview.js", "一样的", "Reporter", "模块246-1664", "行：比", "WAWebview.js", "中", "wx", "功能更为丰富", "wx", "接口模块1665-2304", "行：appServiceEngine", "模块，提供", "Page，App，GetApp", "接口2305-2360", "行：", "为", "window", "对象添加", "AMD", "接口", "require", "define现在的", "WAService", "还有有很多地方依赖", "window", "对象，所以很有可能它在微信中和开发者工具内一样，依然运行于", "webview", "标签之内。"]}
{"author": "天下雪", "title": "微信小程序架构分析《三》：实现过程以及实时更新 ", "content": ["小程序实时运行工具", "wept", "的开发已经基本完成了，", "你可以通过我的代码对小程序的", "web", "环境实现有更全面的认识。下面我将介绍它的实现过程以及实时更新的原理。小程序", "web", "服务实现我在", "wept", "的开发中使用", "koa", "提供", "web", "服务，以及", "et-improve", "提供模板渲染。第一步：", "准备页面模板我们需要三个页面，一个做为控制层", "index.html，一个做为", "service", "层service.html，还有一个做为", "view", "层的", "view.htmlindex.html:<div", "class=\"head\">", "</div>", "<div", "class=\"scrollable\">", "</div>", "<div", "class=\"tabbar-root\">", "</div>", "<script>", "var", "__wxConfig__", "=", "{{=", "_.config}}", "var", "__root__", "=", "'{{=", "_.root}}'", "</script>", "<script", "src=\"/script/build.js\"></script>", "service.html:<head>", "<meta", "http-equiv=\"Content-Type\"", "content=\"text/html;", "charset=utf-8\"", "/>", "<link", "href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\"", "rel=\"Shortcut", "Icon\">", "<script>", "var", "__wxAppData", "=", "{}", "var", "__wxRoute", "var", "__wxRouteBegin", "global", "=", "{}", "var", "__wxConfig", "=", "{{=", "_.config}}", "</script>", "<script", "src=\"/script/bridge.js\"", "type=\"text/javascript\"></script>", "<script", "src=\"/script/service.js\"", "type=\"text/javascript\"></script>", "{{each", "_.utils", "as", "util}}", "<script", "src=\"/app/{{=", "util}}\"", "type=\"text/javascript\"></script>", "{{/}}", "<script", "src=\"/app/app.js\"", "type=\"text/javascript\"></script>", "{{each", "_.routes", "as", "route}}", "<script>", "var", "__wxRoute", "=", "'{{=", "route", "|", "noext}}',", "__wxRouteBegin", "=", "true;</script>", "<script", "src=\"/app/{{=", "route}}\"", "type=\"text/javascript\"></script>", "{{/}}", "</head>", "<body>", "<script>", "window._____sendMsgToNW({", "sdkName:", "'APP_SERVICE_COMPLETE'", "})", "</script>", "</body>", "view.html:<head>", "<link", "href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\"", "rel=\"Shortcut", "Icon\">", "<meta", "charset=\"UTF-8\"", "/>", "<meta", "name=\"viewport\"", "content=\"width=device-width,", "user-scalable=no,", "initial-scale=1.0,", "maximum-scale=1.0,", "minimum-scale=1.0\"", "/>", "<link", "rel=\"stylesheet\"", "type=\"text/css\"", "href=\"/css/default.css\">", "<link", "rel=\"stylesheet\"", "type=\"text/css\"", "href=\"/app/app.wxss\">", "<link", "rel=\"stylesheet\"", "type=\"text/css\"", "href=\"/app/{{=", "_.path}}.wxss\">", "<script>", "var", "__path__", "=", "'{{=", "_.path}}'</script>", "<script", "src=\"/script/ViewBridge.js\"", "async", "type=\"text/javascript\"></script>", "<script", "src=\"/script/view.js\"", "type=\"text/javascript\"></script>", "<script>", "{{=", "_.inject_js}}", "</script>", "<script>", "document.dispatchEvent(new", "CustomEvent(\"generateFuncReady\",", "{", "detail:", "{", "generateFunc:", "$gwx('./{{=", "_.path}}.wxml')", "}", "}))", "</script>", "</head>", "<body>", "<div></div>", "</body>", "第二步：", "实现", "http", "服务用", "koa", "实现的代码逻辑非常简单：server.js//", "日志中间件", "app.use(logger())", "//", "gzip", "app.use(compress({", "threshold:", "2048,", "flush:", "require('zlib').Z_SYNC_FLUSH", "}))", "//", "错误提醒中间件", "app.use(notifyError)", "//", "使用当前目录下文件处理", "404", "请求", "app.use(staticFallback)", "//", "各种", "route", "实现", "app.use(router.routes())", "app.use(router.allowedMethods())", "//", "对于", "public", "目录启用静态文件服务", "app.use(require('koa-static')(path.resolve(__dirname,", "'../public')))", "//", "创建启动服务", "let", "server", "=", "http.createServer(app.callback())", "server.listen(3000)", "router.jsrouter.get('/',", "function", "*()", "{", "//", "加载", "index.html", "模板和数据，输出", "index", "页面", "})", "router.get('/appservice',", "function", "*()", "{", "//", "加载", "service.html", "模板和数据，输出", "service", "页面", "})", "//", "让", "`/app/**`", "加载小程序所在目录文件", "router.get('/app/(.*)',", "function*", "()", "{", "if", "(/\\.(wxss|js)$/.test(file))", "{", "//", "动态编译为", "css", "和相应", "js", "}", "else", "if", "(/\\.wxml/.test(file))", "{", "//", "动态编译为", "html", "}", "else", "{", "//", "查找其它类型文件,", "存在则返回", "let", "exists", "=", "util.exists(file)", "if", "(exists)", "{", "yield", "send(this,", "file)", "}", "else", "{", "this.status", "=", "404", "throw", "new", "Error(`File:", "${file}", "not", "found`)", "}", "}", "})", "第三步：实现控制层功能实现完上面两步，就可以访问", "view", "页面了，但是你会发现它只能渲染，并不会有任何功能，因为", "view", "层功能依赖于控制层进行的通讯，", "如果控制层收不到消息，它不会响应任何事件。控制层是整个实现过程中最复杂的一块，因为官方工具的代码与", "nwjs", "以及", "react", "等第三方组件耦合过高，所以无法拿来直接使用。", "你可以在", "wept", "项目的", "src", "目录下找到控制层逻辑的所有代码，总体上控制层要负责以下几个功能：实现", "service", "层，view", "层以及控制层之间的通讯逻辑依据路由指令动态创建", "view", "（wept", "使用", "iframe", "实现）根据当前页面动态渲染", "header", "和", "tabbar实现原生", "API", "调用，返回结果给", "service", "层wept", "里面", "iframe", "之间的通讯是通过", "message.js", "模块实现的，控制页面（index.html）代码如下：window.addEventListener('message',", "function", "(e)", "{", "let", "data", "=", "e.data", "let", "cmd", "=", "data.command", "let", "msg", "=", "data.msg", "//", "没有跟", "contentscript", "握手阶段，不需要处理", "if", "(data.to", "==", "'contentscript')", "return", "//", "这是个遗留方法，基本废弃掉了", "if", "(data.command", "==", "'EXEC_JSSDK')", "{", "sdk(data)", "//", "直接转发", "view", "层消息到", "service，主要是各种事件通知", "}", "else", "if", "(cmd", "==", "'TO_APP_SERVICE')", "{", "toAppService(data)", "//", "除了", "publish", "发送消息给", "view", "层以及控制层可以处理的逻辑（例如设置标题），", "//", "其它全部转发", "service", "处理，所有控制层的处理结果统一先返回", "service", "}", "else", "if", "(cmd", "==", "'COMMAND_FROM_ASJS')", "{", "let", "sdkName", "=", "data.sdkName", "if", "(command.hasOwnProperty(sdkName))", "{", "command[sdkName](data)", "}", "else", "{", "console.warn(`Method", "${sdkName}", "not", "implemented", "for", "command!`)", "}", "}", "else", "{", "console.warn(`Command", "${cmd}", "not", "recognized!`)", "}", "})", "具体实现逻辑可以查看", "src/command.js", "src/service.jssrc/sdk/*.js。对于", "view/service", "页面只需把原来", "bridge.js", "的window.postMessage", "改为", "window.top.postMessage", "即可。view", "层的控制逻辑由", "src/view.js", "以及", "src/viewManage.js", "实现，viewManage", "实现了", "navigateTo，", "redirectTo", "以及", "navigateBack", "来响应", "service", "层通过名为", "publish", "的", "command", "传来的对应页面路由事件。header.js", "和", "tabbar.js", "包含了基于", "react", "实现的", "header", "和", "tabbar", "模块（原计划是使用", "vue，但是没找到与原生", "js", "模块通讯的", "API）sdk", "目录下包含了", "storage，录音，罗盘模块，其它比较简单一些的原生底层调用我直接写在", "command.js", "里面了。以上就是实现运行小程序所需", "webserver", "的全部逻辑了，其实现并不复杂，主要困难在与理解微信这一整套通讯方式。实现小程序实时更新第一步：", "监视文件变化并通知前端wept", "使用了", "chokidar", "模块监视文件变化，变化后使用", "WebSocket", "告知所有客户端进行更新操作。", "具体实现位于", "lib/watcher.js", "和", "lib/socket.js,", "发送内容是", "json", "格式的字符串。前端控制层收到", "WebSocket", "消息后再通过", "postMessage", "接口转发消息给", "view/service", "层：view.postMessage({", "msg:", "{", "data:", "{", "data:", "{", "path", "}", "},", "eventName:", "'reload'", "},", "command:", "'CUSTOM'", "})", "view/service", "层监听", "reload", "事件：WeixinJSBridge.subscribe('reload',", "function(data)", "{", "//", "data", "即为上面的", "msg.data", "})", "第二步：", "前端响应不同文件变化前端需要对", "4", "种（wxml", "wxss", "json", "javascript）不同类型文件进行", "4", "种不同的热更新处理，其中", "wxss", "和", "json", "相对简单。wxss", "文件变化后前端控制层通知（postMessage", "接口）对应页面（如果是", "app.wxss", "则是所有", "view", "页面）进行刷新，view", "层收到消息后只需要更改对应", "css", "文件的时间戳就可以了，代码如下：o.subscribe('reload',", "function(data)", "{", "if", "(/\\.wxss$/.test(data.path))", "{", "var", "p", "=", "'/app/'", "+", "data.path", "var", "els", "=", "document.getElementsByTagName('link')", ";[].slice.call(els).forEach(function(el)", "{", "var", "href", "=", "el.getAttribute('href').replace(/\\?(.*)$/,", "'')", "if", "(p", "==", "href)", "{", "console.info('Reload:", "'", "+", "data.path)", "el.setAttribute('href',", "href", "+", "'?id='", "+", "Date.now())", "}", "})", "}", "})", "json", "文件变化首先需要判断，如果是", "app.json", "我们无法热更新，所以目前做法是刷新页面，对于页面的", "json，", "我们只需要在控制层上对", "header", "设置相应状态就可以了", "(渲染工作由", "react", "帮我们处理)：socket.onmessage", "=", "function", "(e)", "{", "let", "data", "=", "JSON.parse(e.data)", "let", "p", "=", "data.path", "if", "(data.type", "==", "'reload'){", "if", "(p", "==", "'app.json')", "{", "redirectToHome()", "}", "else", "if", "(/\\.json$/.test(p))", "{", "let", "win", "=", "window.__wxConfig__['window']", "win.pages[p.replace(/\\.json$/,", "'')]", "=", "data.content", "//", "header", "通过全局", "__wxConfig__", "获取", "state", "进行渲染", "header.reset()", "console.info(`Reset", "header", "for", "${p.replace(/\\.json$/,", "'')}`)", "}", "}", "}", "wxml", "使用", "VirtualDom", "API", "提供的", "diff", "apply", "进行处理。首先需要一个接口获取新的", "generateFunc", "函数（用于生成", "VirtualDom），", "添加", "koa", "的", "router：router.get('/generateFunc',", "function*", "()", "{", "this.body", "=", "yield", "loadFile(this.query.path", "+", "'.wxml')", "this.type", "=", "'text'", "})", "function", "loadFile(p,", "throwErr", "=", "true)", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "fs.stat(`./${p}`,", "(err,", "stats)", "=>", "{", "if", "(err)", "{", "if", "(throwErr)", "return", "reject(new", "Error(`file", "${p}", "not", "found`))", "//", "文件不存在有可能是文件被删除，所以不能使用", "reject", "return", "resolve('')", "}", "if", "(stats", "&&", "stats.isFile())", "{", "//", "parer", "函数调用", "exec", "命令执行", "wcsc", "文件生成", "wxml", "对应的", "javascript", "代码", "return", "parser(`${p}`).then(resolve,", "reject)", "}", "else", "{", "return", "resolve('')", "}", "})", "})", "}", "有了接口就可以请求接口，然后执行返回函数进行", "diff", "apply：//", "curr", "为当前的", "VirtualDom", "树", "if", "(!curr)", "return", "var", "xhr", "=", "new", "XMLHttpRequest()", "xhr.onreadystatechange", "=", "function()", "{", "if", "(xhr.readyState", "===", "4)", "{", "if", "(xhr.status", "===", "200)", "{", "var", "text", "=", "xhr.responseText", "var", "func", "=", "new", "Function(text", "+", "'\\n", "return", "$gwx(\"./'", "+__path__+", "'.wxml\")')", "window.__generateFunc__", "=", "func()", "var", "oldTree", "=", "curr", "//", "获取当前", "data", "生成新的树", "var", "o", "=", "m(p.default.getData(),", "false),", "//", "进行", "diff", "apply", "a", "=", "oldTree.diff(o);", "a.apply(x);", "document.dispatchEvent(new", "CustomEvent(\"pageReRender\",", "{}));", "console.info('Hot", "apply:", "'", "+", "__path__", "+", "'.wxml')", "}", "}", "}", "xhr.open('GET',", "'/generateFunc?path='", "+", "encodeURIComponent(__path__))", "xhr.send()", "javascript", "更新逻辑相对复杂一些,", "首先依然是一个接口来获取新的", "javascript", "代码：router.get('/generateJavascript',", "function*", "()", "{", "this.body", "=", "yield", "loadFile(this.query.path)", "this.type", "=", "'text'", "})", "然后我们在", "window", "对象上加入", "Reload", "函数执行具体的更换逻辑：window.Reload", "=", "function", "(e)", "{", "var", "pages", "=", "__wxConfig.pages;", "if", "(pages.indexOf(window.__wxRoute)", "==", "-1)", "return", "//", "替换原来的构造函数", "f[window.__wxRoute]", "=", "e", "var", "keys", "=", "Object.keys(p)", "//", "判定是否当前使用中页面", "var", "isCurr", "=", "s.route", "==", "window.__wxRoute", "keys.forEach(function", "(key)", "{", "var", "o", "=", "p[key];", "key", "=", "Number(key)", "var", "query", "=", "o.__query__", "var", "page", "=", "o.page", "var", "route", "=", "o.route", "//", "页面已经被创建", "if", "(route", "==", "window.__wxRoute)", "{", "//", "执行封装后的", "onHide", "和", "onUnload", "isCurr", "&&", "page.onHide()", "page.onUnload()", "//", "创建新", "page", "对象", "var", "newPage", "=", "new", "a.default(e,", "key,", "route)", "newPage.__query__", "=", "query", "//", "重新绑定当前页面", "if", "(isCurr)", "s.page", "=", "newPage", "o.page", "=", "newPage", "//", "执行", "onLoad", "和", "onShow", "newPage.onLoad()", "if", "(isCurr)", "newPage.onShow()", "//", "更新", "data", "数据", "window.__wxAppData[route]", "=", "newPage.data", "window.__wxAppData[route].__webviewId__", "=", "key", "//", "发送更新事件,", "通知", "view", "层", "u.publish(c.UPDATE_APP_DATA)", "u.info(\"Update", "view", "with", "init", "data\")", "u.info(newPage.data)", "//", "发送", "appDataChange", "事件", "u.publish(\"appDataChange\",", "{", "data:", "{", "data:", "newPage.data", "},", "option:", "{", "timestamp:", "Date.now()", "}", "})", "newPage.__webviewReady__", "=", "true", "}", "})", "u.info(\"Reload", "page:", "\"", "+", "window.__wxRoute)", "}", "以上代码需要添加到", "t.pageHolder", "函数后才可运行最后在", "view", "层初始化后把", "Page", "函数切换到", "Reload", "函数(当然你也可以在请求返回", "javascript", "前把", "Page", "重命名为", "Reload)", "。<body>", "<script>", "window._____sendMsgToNW({", "sdkName:", "'APP_SERVICE_COMPLETE'", "})", "</script>", "</body>", "总算是把这个坑填上了。希望通过这一系列的分析带给前端开发者更多思路。"]}
{"author": "天下雪", "title": "微信小程序开发教程：Flex布局 ", "content": ["微信小程序页面布局方式采用的是Flex布局。Flex布局，是W3c在2009年提出的一种新的方案，可以简便，完整，响应式的实现各种页面布局。Flex布局提供了元素在容器中的对齐，方向以及顺序，甚至他们可以是动态的或者不确定的大小的。Flex布局的主要特征是能够调整其子元素在不同的屏幕大小中能够用最适合的方法填充合适的空间。Flex布局的特点:任意方向的伸缩，向左，向右，向下，向上在样式层可以调换和重排顺序主轴和侧轴方便配置子元素的空间拉伸和填充沿着容器对齐微信小程序实现了Flex布局,简单介绍下Flex布局在微信小程序中的使用。伸缩容器设有display:flex或者display:block的元素就是一个flex", "container(伸缩容器)，里面的子元素称为flex", "item(伸缩项目)，flex", "container中子元素都是使用Flex布局排版。display:block", "指定为块内容器模式，总是使用新行开始显示，微信小程序的视图容器(view,scroll-view和swiper)默认都是dispaly:block。display:flex:指定为行内容器模式，在一行内显示子元素，可以使用flex-wrap属性指定其是否换行，flex-wrap有三个值:nowrap(不换行),wrap(换行),wrap-reverse(换行第一行在下面)使用display:block(默认值)的代码:", "<view", "class=\"flex-row\"", "style=\"display:", "block;\">", "<view", "class=\"flex-view-item\">1</view>", "<view", "class=\"flex-view-item\">2</view>", "<view", "class=\"flex-view-item\">3</view>", "</view>显示效果:改换成display:flex的显示效果:可以从效果图看到block和flex的区别，子元素view是在换行显示(block)还是行内显示(flex)。主轴和侧轴Flex布局的伸缩容器可以使用任何方向进行布局。容器默认有两个轴：主轴(main", "axis)和侧轴(cross", "axis)。主轴的开始位置为主轴起点(main", "start)，主轴的结束位置为主轴终点(main", "end),而主轴的长度为主轴长度(main", "size)。同理侧轴的起点为侧轴起点(cross", "start),结束位置为侧轴终点(cross", "end),长度为侧轴长度(cross", "size)。详情见下图:注意，主轴并不是一定是从左到右的，同理侧轴也不一定是从上到下，主轴的方向使用flex-direction属性控制,它有4个可选值:row", ":从左到右的水平方向为主轴row-reverse：从右到左的水平方向为主轴column:从上到下的垂直方向为主轴column-reverse从下到上的垂直方向为主轴如果水平方向为主轴，那个垂直方向就是侧轴，反之亦然。四种主轴方向设置的效果图:图中的实例展示了使用了不同的flex-direction值排列方向的区别。实例代码:<view", ">", "<view", "class=\"flex-row\"", "style=\"display:", "flex;flex-direction:", "row;\">", "<view", "class=\"flex-view-item\">1</view>", "<view", "class=\"flex-view-item\">2</view>", "<view", "class=\"flex-view-item\">3</view>", "</view>", "<view", "class=\"flex-column\"", "style=\"display:flex;flex-direction:", "column;\"", ">", "<view", "class=\"flex-view-item\">c1</view>", "<view", "class=\"flex-view-item\">c2</view>", "<view", "class=\"flex-view-item\">c3</view>", "</view></view>运行效果：对齐方式子元素有两种对齐方式：justify-conent", "定义子元素在主轴上面的对齐方式align-items", "定义子元素在侧轴上对齐的方式jstify-content有5个可选的对齐方式:flex-start", "主轴起点对齐(默认值)flex-end", "主轴结束点对齐center", "在主轴中居中对齐space-between", "两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等space-around", "每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同。justify-content的对齐方式和主轴的方向有关，下图以flex-direction为row，主轴方式是从左到右,描述jstify-content5个值的显示效果:align-items表示侧轴上的对齐方式:stretch", "填充整个容器(默认值)flex-start", "侧轴的起点对齐flex-end", "侧轴的终点对齐center", "在侧轴中居中对齐baseline", "以子元素的第一行文字对齐align-tiems设置的对齐方式，和侧轴的方向有关，下图以flex-direction为row,侧轴方向是从上到下,描述align-items的5个值显示效果:有了主轴和侧轴的方向再加上设置他们的对齐方式，就可以实现大部分的页面布局了。案例地址：https://github.com/jjz/weixin-mina/blob/master/pages/flex/flex.wxml"]}
{"author": "天下雪", "title": "微信小程序技术教程：集成 Redux ", "content": ["示例Redux是什么Redux", "是", "JavaScript", "状态容器，提供可预测化的状态管理。Redux官方文档为什么要使用Redux小程序俨然是一个类似Hybrid", "App的东西，前面是SPA，小程序提供一些原生功能的接口。现在前端程序规模都比较大，页面状态，数据缓存，需要管理的东西太多。引入Redux可以方便的管理这些状态。并且Redux丰富的周边工具也是很有吸引力的。集成Redux小程序的模块化微信的文档并没有指出如何使用第三方库，所以只能从微信小程序的模块化入手。文档中提到，模块化的关键是：module.exports", "=", "function(){}同时，如果我们去观察小程序开发环境的network面板，点击任何一个js，我们可以发现：项目目录中的所有js文件都会自动被加载，无论我们是否在代码中require所以的模块都会被套上下面的代码：define(\"reducers/visibilityFilter.js\",", "function(require,", "module){var", "window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;/*******************//******你写的代码******/", "/********************/})这实际上是类似AMD的加载方式，但是跟标准的AMD又有些不同，缺少了依赖部分的声明。function(require,", "module){}:", "这个函数包裹的是模块的实现，也就是我们自己写的代码，小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去：module.exports", "=", "function(){}所以只要需要让第三方库的代码使用这种形式的export就可以了。构建Redux的微信小程序包这里主要目标是打一个Redux包，让它可以兼容微信小城的加载方式下载Redux的代码到本地：git", "clone", "https://github.com/reactjs/redux.git安装依赖：npm", "install打包：npm", "run", "build:umd", "&&", "npm", "run", "build:umd这些命令的详细内容可以到redux项目的package.json中查看。这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到。带min.js后缀的是minify过的。", "4.微调加载方式：用编辑器打开dist目录下的redux.js文件(function", "webpackUniversalModuleDefinition(root,", "factory)", "{", "if(typeof", "exports", "===", "'object'", "&&", "typeof", "module", "===", "'object')", "module.exports", "=", "factory();", "else", "if(typeof", "define", "===", "'function'", "&&", "define.amd)", "define([],", "factory);", "else", "if(typeof", "exports", "===", "'object')", "exports[\"Redux\"]", "=", "factory();", "else", "root[\"Redux\"]", "=", "factory();})(this,", "function()", "{...", "})这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来。将第二行代码：if(typeof", "exports", "===", "'object'", "&&", "typeof", "module", "===", "'object')", "修改成：if(typeof", "module", "===", "'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入了拷贝进工程目录例如，我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了：var", "redux", "=", "require('./libs/redux.js')通过这里的示例，其实我们发现，我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了。使用Redux我们可以使用Redux的微信小程序绑定库来简化一些代码：wechat-weapp-redux，详细的安装和使用说明可以参照wechat-weapp-redux的README集成Redux-devtools如果没有redux-devtools那么使用redux的效果可能是要减半的。因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件。这里使用remote-redux-devtools，remotedev-server安装remote-redux-devtools原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现。修改好的包在这里：remote-redux-devtools把代码下载到工程目录里面就可以用了。安装和启动remotedev-servernpm", "install", "-g", "remotedev-serverremotedev", "--hostname=localhost", "--port=5678", "因为没办法用npm安装到本地（开头提到的，微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678。", "3.", "集成devtoolconst", "{createStore,", "compose}", "=", "require('./libs/redux.js');const", "devTools", "=", "require('./libs/remote-redux-devtools.js').default;const", "reducer", "=", "require('./reducers/index.js')function", "configureStore()", "{", "return", "createStore(reducer,", "compose(devTools({", "hostname:", "'localhost',", "port:", "5678,", "secure:", "false", "})));}module.exports", "=", "configureStore;把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了", "4.", "打开监视器", "可以在浏览器中访问localhost:5678，这是remotedev-server自带的监视器，正常打开的话是这样的：", "左边有一个@@INIT说明小程序的redux连接成功了。但是这里这个自带的监视器可能打不开，因为它的一些js包是存在国外的cdn上的，偶尔访问不到。这个时候可以使用http://remotedev.io/local/，点击下面的setting，设置使用本地的server。保存之后刷新页面，应该跟上面显示的结果一样。示例详细的代码示例，可以参照：wechat-weapp-redux-todos"]}
{"author": "天下雪", "title": "梁兴臣:微信小程序开发三宗罪和解决方案 ", "content": ["在微信公布小程序的文档和开发工具后，脉冲软件在第一时间进行了学习和体验，我们发现微信小程序的技术架构和开发体验让我们非常失望。由于微信小程序的运行环境并不是一个标准的浏览器环境，而且微信的封装工作并不完善，所以我们以往开发中的很多经验并不适用。这并非简单的开发习惯不适应，更重要的是我们的开发流程、规范将不适用。微信小程序开发第一宗罪:", "无法调用NPM包虽然微信小程序开发工具打包时实现了require函数加载依赖，但并不是完整的CommonJS依赖管理。因为require函数仅仅能够加载项目中的JS文件，而且必须严格定义JS文件路径，路径不支持CommonJS的路径风格。例如如下加载方式都将出错：require('lodash');require('lodash/map');require('./foo');在微信小程序开发工具中，我们必须对应写为如下格式：require('node_modules/lodash/lodash.js');require('node_modules/lodash/map.js');require('./foo.js');虽然我们可以像上面代码一样加载node_modules目录中的库，但是实际运行时却发生了：在调试工具的Network选项卡中，我们看到运行时加载了1000多个文件，总数据量1.8MB，而我们仅仅是在代码中加载了一个lodash库而已！这是因为微信小程序开发工具会将所有项目下的js文件视为项目文件，并进行打包。而实际开发中，我们需要安装很多的NPM扩展库，而这些扩展库中有大量的不需要打包的文件，例如lodash中有上千文件，而我们只需要用到其中的非常少的一部分。另外，在开发中，我们往往需要安装babal、eslient、webpack、grunt等待开发工具，微信小程序开发工具会一视同仁将这些工具的源码也进行打包......实测开发者工具将崩溃！开发者将崩溃！我崩溃！所以不支持NPM包的原因，是微信开发者工具不支持CommonJS标准，不支持CommonJS标准的原因，是微信开发者工具想当然地认为项目目录下的js文件一定是项目文件，所以只实现了简单的require函数，想当然的原因是。。。微信小程序开发第二宗罪:", "无法使用Babel转码无法使用Babel转码的原因其实仍然归结于无法加载NPM库。但是后果将十分严重。因为你将不能再安全使用ES6/7特性，你将无法使用async/await函数，你将和无尽的callback做斗争，你该怎样描述自己？回调地狱中的苦逼程序员？如果你看到这里不明白Babel为何物，那么祝贺你，因为不曾见过天堂就不知何为地狱，你无须为不支持ES6/7而烦恼。但一旦你的大脑支持了ES6/7，用过了Babel，你就回不去了，像我一样，无Babel不编码。微信小程序开发第三宗罪:", "无法重用组件其实微信小程序开发是并非完全不能重用组件，比如WXML语法中支持import和", "include。但是那仅仅是视图模板可重用，并非组件可重用，因为我们认为组件在应当包含视图和逻辑。WXML其实是基于可重用的组件，但是不允许我们自定义组件。如果你有React经验，你就会明白我的意思。例如，你的小程序是个电商APP，项目中有两个页面中同时包含了商品列表组件，比如某分类下商品列表和搜索结果列表，我们知道这两个列表其实仅仅是参数不同而已。但是在小程序开发中，你只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。我们的实践只吐槽、管杀不管埋是不道德的，既然发现了微信小程序开发中的各种弊端，我们脉冲软件在开发之中总结出了一套流程和工具，专为解决上述三个问题，并免费发布到了开源社区，这就是Labrador。接下来我们一起来尝试一下我们脉冲软件的开发体验。安装Labrador通过命令", "npm", "install", "-g", "labrador-cli", "全局安装Labrador控制行工具。初始化项目通过如下命令新建一个Labrador项目：mkdir", "democd", "demonpm", "initlabrador", "init项目初始化完成后，该目录是这个样子的：图中的src是我们的源码目录，node_modules是NPM包目录，dist是目标输出目录。请在开发者工具中新建一个项目，并设置路径到dist目录，请勿设置为demo目录！使用WebStorm或Sublime打开demo目录，开发过程中，我们使用WebStorm或Sublime修改src目录下的源码，请勿直接修改dist目录中的文件，因为dist目录是通过labrador命令生成的。在demo目录中运行", "labrador", "build", "命令编译项目，该命令会将src目录下的文件一一处理并生成dist目录下对应的文件。我们也可以运行", "labrador", "watch", "命令监控src目录下的文件变化，这样就不用每次修改后手动运行编译命令。加载NPM包我们以lodash包为例，在src/app.js中键入代码", "const", "_", "=", "require('lodash');", "编译后，我们看到dist目录下的文件是这样的：我们看到dist目录下有一个npm/lodash目录，该目录下只有一个lodash.js文件，那么在微信web开发者工具中打包预览，lodash的库将只有这个文件被加载。这一切是怎么发生的？我们看一下dist/app.js的源码，发现源码中const", "_", "=", "require('lodash');", "被编译为", "var", "_", "=", "require('./npm/lodash/lodash.js');", "然后labrador命令将node_modules/lodash/lodash.js", "文件复制到了dist/npm/lodash/lodash.js", "。这就是通过labrador可以调用NPM包的原理。重要的是，只有真正用到的js文件才被labrador命令加入到项目目录中。这样一个小小的改进象征着我们的小程序可以便捷调用NPM仓库中海量的扩展库！Babel转码在初始化的示例代码src/app.js中的内容是这样的：图中timer和getUserInfo属性都为async函数，函数体内使用await调用异步操作。labrador", "库对微信API进行了封装，使用", "const", "wx", "=", "require('labrador');", "覆盖默认的全局变量wx;", "封装后的wx对象提供的异步方法返回的都是Promise异步对象，结合async/await函数彻底终结callback，将异步代码同步写，轻松逃离回调地狱！但目前async/await函数是不被浏览器支持的，我们需要使用babel对其转码，labrador编译命令已经内置了babel转码，转码后的代码可以查看dist/app.js，内容过长，不再张贴。重用组件重用组件最需要解决的问题是组件的逻辑代码怎样重用。在实例代码中有一个src/components目录，用来存放项目内的可重用组件，其结构是这样的：子目录src/components/list中存放着一个可重用的组件。list.js", "/", "list.less", "/", "list.xml", "分别对应微信小程序的", "js", "/", "wxss", "/", "wxml", "文件。JS为控件的逻辑层，其代码如下：文件导出一个List类，这个组件类拥有像Page一样的生命周期函数onLoad,", "onReady,", "onShow,", "onHide,", "onUnload", "以及setData函数。LESS文件对应微信的WXSS文件，因为微信小程序实现的限制，LESS中无法使用连级选择语法，但是可以定义变量，方便开发。XML文件对应微信的WXML文件，是组件视图描述文件，list.xml内容为：文件中导出一个名为list的template。组件不但可以存放在src/components目录内，还可以单独做成NPM包，这样就可以轻松做到跨项目间的组件共享。组件定义完成后，接下来是在页面中调用，在", "src/pages/index/index.js", "中有如下代码：代码中首先引入了labrador库替换全局的默认wx对象，并使用labrador.createPage方法代替全局的Page函数声明页面。然后加载List组件类，在页面声明配置中，增加了components属性，并将List组件类实例化传入。labrador.createPage方法是对Page方法的一层封装，目的是在页面初始化时和组件对象进行关联。在", "src/pages/index/index.less", "中加入代码", "@import", "'list'", "即可调用list组件的样式，如果在src/components/list中找不到list.less，那么编译命令将在NPM包中寻找", "node_modules/list/index.less", "。在", "src/pages/index/index.xml", "中加入代码", "<component", "key=\"list\"/>", "即可调用list组件的模板文件，component", "是Labrador自定义的组件，编译后对应生成", "import", "和", "template。如果在src/components/list中找不到list.xml，那么编译命令将在NPM包中寻找", "node_modules/list/index.xml"]}
{"author": "天下雪", "title": "新手入门福音：微信小程序试水体验过程 ", "content": ["1.", "https://mp.weixin.qq.com注册一个公众号，成为开发者，拿到一个appId。2.", "下载微信开发者工具，https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1476197489869。3.", "使用微信扫码登录4.", "添加一个项目，把注册公众号获得到的appId复制到appId，名称目录填写好后，点击添加项目，显示小程序还处于内测阶段，没有被邀请的用户获取的appId无法使用，尝试认证，但个人用户无法认证（有说关注大于500的可以，一时难以凑齐，弃之），因2013年以后公众号无法升级为服务号，于是又开始注册服务号，因为不是企业，没有各种相关信息，又弃之，最后只能选择无appId进行项目添加，虽少些功能，但也大体可以使用。往一个空的文件夹中添加项目，会自动创建一个获取信息和登录日志的小demo，结构非常清晰（加了几个接口和一个文件夹detail图）.js", "=>", ".js", ".wxml", "=>", ".html", ".wxss", "=>", ".css", ".json", "=>", ".json", "点击调试可以看到效果，头像，昵称，和helloword（因为是扫码登录，开发者工具绑定了开发者信息，所以可以拿到个人信息）。点击左侧编辑可对代码进行编辑，编辑完后保存、编译就可查看新效果。"]}
{"author": "天下雪", "title": "微信小程序试水教程：参数传递 ", "content": ["教程一：参数传递这里我找到两种小程序上的参数传递方式，为了方便，我单独拿出来和大家分享下.一、通过事件进行参数传递先来看眼小程序对事件的定义：#什么是事件?", "这里是列表文本事件是视图层到逻辑层的通讯方式。", "这里是列表文本事件可以将用户的行为反馈到逻辑层进行处理。", "这里是列表文本事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。", "这里是列表文本", "事件对象可以携带额外信息，如id,", "dataset,", "touches。", "很明确的指出了是视图层【wxml】到逻辑层【js】的通信方式，时间对象可以携带额外信息，用这个事件来传递参数肯定没错了，接下来我们就来实际看下例子：视图.wxml", "<view", "id=\"tapTest\"", "data-hi=\"MINA\"", "bindtap=\"tapName\">", "Click", "me!", "</view>", "逻辑.jsPage({", "tapName:", "function(event)", "{", "console.log(event.target)", "}", "})", "log打印可以看到", "dataset", "里面就是我们设置的data-hi=\"MINA\"的值了。现在我们来看下刚刚我们写的，", "首先", "bindtap,以bind开头的就是要给他绑定个事件，这个事件的名字就是“=”号后面的数值就是绑定的事件名称，需要在", "逻辑【js】层定义上。", "然后就是传值了，注意到的朋友可以看到", "我们这里写了data-hi", "和我们平时写js的传值是同一个定义方法。这个data-*就对应事件的属性target里的dataset", "值。这里我们需要调用的话就是event.target.dataset.hi就能取到data-hi所对应的值。这里需要注意下", "data的定义名称：", "书写方式：", "以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在", "event.target.dataset", "中会将连字符转成驼峰elementType。官方示例：<view", "data-alpha-beta=\"1\"", "data-alphaBeta=\"2\"", "bindtap=\"bindViewTap\">", "DataSet", "Test", "</view>", "Page({", "bindViewTap:function(event){", "event.target.dataset.alphaBeta", "==", "1", "//", "-", "会转为驼峰写法", "event.target.dataset.alphabeta", "==", "2", "//", "大写会转为小写", "}", "})", "二、navigator", "跳转url传参*.wxml<view", "class=\"btn-area\">", "<navigator", "url=\"navigate?title=navigate\"", "hover-class=\"navigator-hover\">跳转到新页面</navigator>", "<navigator", "url=\"redirect?title=redirect\"", "redirect", "hover-class=\"other-navigator-hover\">在当前页打开</navigator>", "</view>", "*.js", "跳到新页面之后在onload里面直接接收参数，接收方法也就是", "options.[参数值]Page({", "onLoad:", "function(options)", "{", "this.setData({", "title:", "options.title", "})", "}", "})", "好啦，今天就写到这里，我顺便把文档链接写上，上面写的文档里都有。我只是把它们搬出来了，用我的话说了一遍。", "…(⊙＿⊙；)…什么是事件navigator"]}
{"author": "天下雪", "title": "微信小程序试水教程：富文本转文本 ", "content": ["最近小程序这么火，我也来搞搞。发现了一个恶心的问题。小程序没有组件能支持富文本内容的，改接口又不太合适，于是有了这问，没技术含量纯粹记录首先我们看眼没有被格式的富文本显示：*.wxml内代码。content是富文本内容", "<view>", "<text>{{content}}</text>", "</view>", "显示结果：由以上图片看到，小程序无法解析html文件我们需要处理html富文本内容，让其显示好看点下面直接上代码了，主要功能就是利用js的replace", "对富文本经行处理，大家可以看一下。一起优化，方便对富文本更好的处理。convertHtmlToText:", "function", "convertHtmlToText(inputText)", "{", "var", "returnText", "=", "\"\"", "+", "inputText;", "returnText", "=", "returnText.replace(/<\\/div>/ig,", "'\\r\\n');", "returnText", "=", "returnText.replace(/<\\/li>/ig,", "'\\r\\n');", "returnText", "=", "returnText.replace(/<li>/ig,", "'", "*", "');", "returnText", "=", "returnText.replace(/<\\/ul>/ig,", "'\\r\\n');", "//--", "remove", "BR", "tags", "and", "replace", "them", "with", "line", "break", "returnText", "=", "returnText.replace(/<br\\s*[\\/]?>/gi,", "\"\\r\\n\");", "//--", "remove", "P", "and", "A", "tags", "but", "preserve", "what's", "inside", "of", "them", "returnText=returnText.replace(/<p.*?>/gi,", "\"\\r\\n\");", "returnText=returnText.replace(/<a.*href=\"(.*?)\".*>(.*?)<\\/a>/gi,", "\"", "$2", "($1)\");", "//--", "remove", "all", "inside", "SCRIPT", "and", "STYLE", "tags", "returnText=returnText.replace(/<script.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/script>/gi,", "\"\");", "returnText=returnText.replace(/<style.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/style>/gi,", "\"\");", "//--", "remove", "all", "else", "returnText=returnText.replace(/<(?:.|\\s)*?>/g,", "\"\");", "//--", "get", "rid", "of", "more", "than", "2", "multiple", "line", "breaks:", "returnText=returnText.replace(/(?:(?:\\r\\n|\\r|\\n)\\s*){2,}/gim,", "\"\\r\\n\\r\\n\");", "//--", "get", "rid", "of", "more", "than", "2", "spaces:", "returnText", "=", "returnText.replace(/", "+(?=", ")/g,'');", "//--", "get", "rid", "of", "html-encoded", "characters:", "returnText=returnText.replace(/&nbsp;/gi,\"", "\");", "returnText=returnText.replace(/&amp;/gi,\"&\");", "returnText=returnText.replace(/&quot;/gi,'\"');", "returnText=returnText.replace(/&lt;/gi,'<');", "returnText=returnText.replace(/&gt;/gi,'>');", "return", "returnText;", "}", "将上面代码放入任意适合的小程序js文件中，", "然后在需要处理数据的js文件里，引入文件，下面给出放入app.js文件中的调用示例：var", "app", "=", "getApp()//获取app小程序实例", "onLoad:", "function", "(options)", "{", "wx.request({", "url:", "'http://example.com/api'", "+", "options.id+'.json',", "headers:", "{", "'Content-Type':", "'application/json'", "},", "success:", "function", "(res)", "{", "res.data.content", "=", "app.convertHtmlToText(res.data.content", ")", "that.setData({", "art:", "res.data.content", "})", "console.log(res.data)", "}", "})", "｝", "然后编译刷新下，可以看到结果了：这里可以继续调整下css，使显示得更好看点。"]}
{"author": "天下雪", "title": "前端之巅：在Chrome浏览器上运行微信小程序 ", "content": ["微信小程序的开发框架体验起来，还不错——自带了UI框架。但是问题是它的IDE，表现起来相当的糟糕——其实主要是因为，我当时买WebStorm", "License买了好多年。所以，我觉得他的IDE真不如我这个付费好用。而且，作为一个拥护自由和开源的“GitHub", "中国区首席Markdown程序员”。微信在微信小程序引导着Web开向封闭，我们再也不能愉快地分享我们的代码了。如果我们放任下去，未来的Web世界令人堪忧。好了，废话说完了，本文只是一个Demo的介绍。文章太长不想看，可以直接看Demo哈哈：GitHub:", "https://github.com/phodal/weapp-webdemo", "预览：http://weapp.phodal.com/真实世界下的MINA三基本元素微信小程序的背后运行的是一个名为MINA框架。在之前的几篇文章里，我们介绍得差不多了。现在让我们来作介绍pipeline：Transform", "WXML和WXSS当我们修改完WXML、WXSS的时候，我们需要重新编译项目才能在浏览器上看到效果。这时候后台就会执行一些transform动作：", "WCC来转换WXML为一个genrateFun，执行这个方法将会得到一个Virtual", "DomWXSS就会转换WXSS为CSS——这一点有待商榷。WCC和WXSS，可以从vendor目录下获取到，在“微信Web开发者工具”下敲入help，你就会得到下面的东东：运行openVendor()，你就会得到上面的WCSS、WXSS、WAService.js、WAWebview.js四个文件了。Transform", "js文件对于JS文件来说，则是一个拼装的过程，如下是我们的app.js文件：它在转换后会变成：我假装你已经知道这是什么了，反正我也不想、也不会解释了~~。同理于：至于它是如何replace或者apend到HTML中，我就不作解释了。MINA如何运行？为了运行一个Page，我们需要有一个Virtual", "Dom，即用WCC转换后的函数，如：然后在我们的HTML中加一个script，如就会凑发这个事件了。我简单的拆分了WXWebview.js得到了几个功能组件：define.js，这里就是定义AMD模块化的地方exparser.js，用于转换WXML标签到HTML标签exparser-behvaior.js，定义不同标签的一些行为mobile.js，应该是一个事件库，好像我并不关心。page.js，核心代码，即Page、App的定义所在。report.js，你所说的一切都能够用作为你的呈堂证供。virtual_dom.js，一个virtual", "dom实现结合wcc使用，里面应该还有component.css，也可能是叫weuiwa-wx.js，定义微信各种API以及WebView和Native的地方，和下面的WX有冲突。wx.js，同上，但是略有不同。wxJSBridge.js，Weixin", "JS", "Bridge于是，我就用上面的组件来定义不同的位置好了。当我们触发自定义的generateFuncReady事件时，将由virtual_dom.js来接管这次Render：因此，这里就是负责DOM初始化的地方了，这里得到的Dom结果是这样的：而我们写的WXML是这样的：很明显view会被转换为wx-view，text会被转换为wx-text等等，以此类推。这个转换是在virtual", "dom.js中调用的，调用的方法就是exparser。遗憾的是我现在困在", "data", "初始化上面了~~，这里面有两套不同的事件系统，有一些困扰。其中有一个是：WeixinJSBridge、还有一个是app", "engine中的事件系统，两个好像不能互调。使用WebStorm开发在浏览器上运行之前，我们需要简单的mock一些方法，如：", "window.webkit.messageHandlers.invokeHandler.postMessagewindow.webkit.messageHandlers.publishHandler.postMessageWeixinJSCore.publishHandlerWeixinJSCore..invokeHandler然后把", "config.json中的一些内容变成__wxConfig，如：", "如这里我们的appname是哈哈哈哈哈哈哈——我家在福建。然后在我们的HTML中引入各个JS文件，啦啦。我们还需要一个自动化的glup脚本来watch", "wxml和wxss的修改，然后编译，如：说了这么多，你还不如去看代码好了：GitHub:", "https://github.com/phodal/weapp-webdemo", "预览：http://weapp.phodal.com/"]}
{"author": "天下雪", "title": "微信小程序canvas篇，实现全过程展示含demo ", "content": ["Demo效果图如下：", "一、Demo思路来源之所以写了这样一个Demo，是因为很久之前在慕课网看到了一个很好玩很酷炫利用canvas绘制的时钟，于是想着这样炫酷好玩的东西在小程序当中是否也能够得以实现呢？答案肯定是可以的。接下来我将把这个Demo的思路一步一步分享给大家。二、Demo实现1.微信小程序开发环境搭建", "http://www.helloxcx.com/jc/devtools/download.html，如果这个地址无法下载，请使用官方地址下载；2.开发环境搭建后利用开发工具创建自己的Demo项目", "1）创建项目", "2）添加核心代码countdown.js", "，digit.js到index目录下3.核心代码实现(代码中有详细的开发注释)", "1）digit.js（这里实现倒计时数字的排列，是一个3维数组）//", "数字排列var", "digit", "=", "[", "[", "[0,0,1,1,1,0,0],", "[0,1,1,0,1,1,0],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,0,1,1,0],", "[0,0,1,1,1,0,0]", "],//0", "[", "[0,0,0,1,1,0,0],", "[0,1,1,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[1,1,1,1,1,1,1]", "],//1", "[", "[0,1,1,1,1,1,0],", "[1,1,0,0,0,1,1],", "[0,0,0,0,0,1,1],", "[0,0,0,0,1,1,0],", "[0,0,0,1,1,0,0],", "[0,0,1,1,0,0,0],", "[0,1,1,0,0,0,0],", "[1,1,0,0,0,0,0],", "[1,1,0,0,0,1,1],", "[1,1,1,1,1,1,1]", "],//2", "[", "[1,1,1,1,1,1,1],", "[0,0,0,0,0,1,1],", "[0,0,0,0,1,1,0],", "[0,0,0,1,1,0,0],", "[0,0,1,1,1,0,0],", "[0,0,0,0,1,1,0],", "[0,0,0,0,0,1,1],", "[0,0,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,1,1,1,0]", "],//3", "[", "[0,0,0,0,1,1,0],", "[0,0,0,1,1,1,0],", "[0,0,1,1,1,1,0],", "[0,1,1,0,1,1,0],", "[1,1,0,0,1,1,0],", "[1,1,1,1,1,1,1],", "[0,0,0,0,1,1,0],", "[0,0,0,0,1,1,0],", "[0,0,0,0,1,1,0],", "[0,0,0,1,1,1,1]", "],//4", "[", "[1,1,1,1,1,1,1],", "[1,1,0,0,0,0,0],", "[1,1,0,0,0,0,0],", "[1,1,1,1,1,1,0],", "[0,0,0,0,0,1,1],", "[0,0,0,0,0,1,1],", "[0,0,0,0,0,1,1],", "[0,0,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,1,1,1,0]", "],//5", "[", "[0,0,0,0,1,1,0],", "[0,0,1,1,0,0,0],", "[0,1,1,0,0,0,0],", "[1,1,0,0,0,0,0],", "[1,1,0,1,1,1,0],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,1,1,1,0]", "],//6", "[", "[1,1,1,1,1,1,1],", "[1,1,0,0,0,1,1],", "[0,0,0,0,1,1,0],", "[0,0,0,0,1,1,0],", "[0,0,0,1,1,0,0],", "[0,0,0,1,1,0,0],", "[0,0,1,1,0,0,0],", "[0,0,1,1,0,0,0],", "[0,0,1,1,0,0,0],", "[0,0,1,1,0,0,0]", "],//7", "[", "[0,1,1,1,1,1,0],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,1,1,1,0],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,1,1,1,0]", "],//8", "[", "[0,1,1,1,1,1,0],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[1,1,0,0,0,1,1],", "[0,1,1,1,0,1,1],", "[0,0,0,0,0,1,1],", "[0,0,0,0,0,1,1],", "[0,0,0,0,1,1,0],", "[0,0,0,1,1,0,0],", "[0,1,1,0,0,0,0]", "]//9];module.exports", "=", "{", "digit", ":", "digit}", "2）countdown.js（这里实现倒计时数字的绘图以及倒计时）var", "sort", "=", "require(\"./digit.js\")", ",", "digit", "=", "sort.digit;", "//", "接收数字排列数组var", "CANVAS_WIDTH", "=", "375", "//", "canvas宽度", ",", "CANVAS_HEIGHT", "=", "500", "//", "canvas高度", ",", "RADIUS", "=", "8", "//", "小球半径", ",", "MARGIN_TOP", "=", "60", "//", "图例距离右边距离", ",", "MARGIN_LEFT", "=", "60;", "//", "图例距离左边距离/**", "*", "[render", "数字渲染]", "*", "@param", "{[type]}", "time", "[倒计时时间]", "*", "@param", "{[type]}", "cxt", "[绘制对象]", "*/function", "render(time,cxt){", "cxt.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);", "renderDigit(MARGIN_LEFT", ",", "MARGIN_TOP", ",", "parseInt(time/10)", ",", "cxt", ");", "renderDigit(MARGIN_LEFT", "+", "15*(RADIUS+1)", ",", "MARGIN_TOP", ",", "parseInt(time%10)", ",", "cxt", ");}/**", "*", "[renderDigit", "单独小球的绘制]", "*", "@param", "{[type]}", "x", "[每个小球x轴距离]", "*", "@param", "{[type]}", "y", "[每个小球y轴距离]", "*", "@param", "{[type]}", "num", "[需要绘制出来的数字]", "*", "@param", "{[type]}", "cxt", "[绘制对象]", "*/function", "renderDigit(x,y,num,cxt){", "for(var", "i=0;i<digit[num].length;i++){", "for(var", "j=0;j<digit[num][i].length;j++){", "if", "(digit[num][i][j]){", "cxt.beginPath();", "cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1)", ",", "y+i*2*(RADIUS+1)+(RADIUS+1)", ",", "RADIUS", ",", "0", ",2*Math.PI);", "cxt.closePath();", "cxt.fill();", "}", "}", "}}/**", "*", "[loopTime", "倒计时绘图]", "*", "@param", "{[type]}", "time", "[倒计时需要绘制的数字]", "*", "@param", "{[type]}", "cxt", "[绘制对象]", "*/function", "loopTime(time,cxt){", "render(time,cxt);", "//", "获取当前context上存储的绘图动作", "wx.drawCanvas({", "canvasId:\"canvas\",", "actions:cxt.getActions()", "});}/**", "*", "[init", "倒计时实现]", "*", "@param", "{[type]}", "time", "[倒计时需要绘制的数字]", "*", "@param", "{[type]}", "cxt", "[绘制对象]", "*/function", "init(time,cxt){", "loopTime(time,cxt)", "var", "loop", "=", "setInterval(function(){", "time--;", "(time", "<", "1", ")", "&&", "(", "clearInterval(loop)", ")", "loopTime(time,cxt)", "},1000);}//", "将init方法暴露出去module.exports", "=", "{", "render:render,", "init:init}3）index.js三、Demo源码源码已托管github，地址为：https://github.com/xuqiang521/Wechat"]}
{"author": "天下雪", "title": "Runlin微信小程序系列教程一：从零开始写一个demo《上》 ", "content": ["本文已获得原作者授权微信小程序内测至今也有20天左右，也有很多人作出了很多不错的DEMO并发布到github了。前几日看见了豆瓣电影这个demo，感觉很不错，也跟着做了一个，作为复习巩固文档API用。废话不多说，直接进入正题：第一节只写一个首页的展示，数据用的是自己写的虚拟的数据", "新建一个demo，不要使用微信自带的DEMO，直接从零开始写起：首先创建3个文件：app.jsonapp.jsapps.wxss", "app.json", ":", "主要写配置项：内容如下，具体的每个key值对应的意思，这里就不再细说了，可以看我之前的配置指南，{\"pages\":[\"pages/index/index\",\"pages/rank/rank\",],\"window\":{\"enablePullDownRefresh\":true,\"backgroundColor\":\"#eee\",\"navigationBarTitleText\":", "\"上导航标题文字\",\"navigationBarTextStyle\":\"white\"", "},\"tabBar\":", "{\"color\":", "\"#d7ced5\",\"selectedColor\":", "\"#535f71\",\"borderStyle\":", "\"white\",", "\"backgroundColor\":", "\"#f9f9f9\",\"list\":", "[", "{\"pagePath\":", "\"pages/index/index\",", "\"text\":", "\"推荐电影\",", "\"iconPath\":", "\"images/board.png\",", "\"selectedIconPath\":", "\"images/board-actived.png\"", "},{\"pagePath\":", "\"pages/rank/rank\",\"text\":", "\"北美票房\",\"iconPath\":", "\"images/note.png\",\"selectedIconPath\":", "\"images/note-actived.png\"}]},\"networkTimeout\":", "{\"request\":", "10000,\"downloadFile\":", "9000,\"uploadFile\":8000,\"connectSocket\":7000},\"debug\":", "true}", "app.js", ":", "主要用来注册一个小程序的实例", "App({onLaunch:", "function", "()", "{},onShow:", "function", "()", "{},onHide:", "function", "()", "{},globalData:", "'I", "am", "global", "data'});", "app.wxss", ":", "公用样式，基本等同于CSS，暂时不需要写内容。", "创建好3个文件后，就可以开始写页面的内容了：新创建2个文件夹images和pages，一个放图片一，个放页面。目前只pages下面再创建2个文件夹index和rank，每个文件下分别创建json,js,wxml,wxss文件，此时目录如下：虽然不一定4个文件类型都需要用到，但为了之后方便，建议还是先创建好，需要用到的时候就比较方便了，不用再去创建。首先写index.js:", "(为了模拟循环数组，data下面的moivelist还需要多复制几份，这里只写了一份出来，imgsrc路径要写好)", "Page({", "data:{", "moivelist:[{", "imgsrc:", "\"../../images/AN2.jpg\",", "title:", "\"肖申克的救赎\",", "introduce:", "\"The", "shrakwos", "RedenpeTion(1994)\",", "author:", "\"弗兰克*德拉立邦\",", "rank:", "\"9.6\"}]},onLoad:", "function(options)", "{console.log(1);},onReady:", "function()", "{//", "Do", "something", "when", "page", "ready.},onShow:", "function()", "{//", "Do", "something", "when", "page", "show.},onHide:", "function()", "{//", "Do", "something", "when", "page", "hide.},onUnload:", "function()", "{//", "Do", "something", "when", "page", "close.},onPullDownRefresh:", "function()", "{//", "Do", "something", "when", "pull", "down},//", "Event", "handler.viewTap:", "function()", "{this.setData({text:", "'Set", "some", "data", "for", "updating", "view.'})}})这里出现了很多on函数事件，对应页面的生命周期每个过程对应的事件，这里暂时先关注data对象小程序是以数据驱动的，页面进来的时候通过动态获取数据，通过{{xxx}}将数据绑定，并将数据渲染到视图层，这里先以一个虚拟的data数据模拟", "然后写index.wxml文件：从上面显示的首页的图片来看，主要是1个标题，以及下面一个列表，列表用过循环来渲染出所有的数据标题:", "标题比较简单，主要是写css<view", "class=\"head-title\"><text>豆瓣电影top250</text></view>这里主要讲下面的列表循环，可以发现我们只要写好列表中的第一个就可以了，其他的通过循环来展示列表主要分为左中右三块，分别为图片，内容，以及评分3块<block", "wx:for=\"{{moivelist}}\">", "//循环渲染，wx:for=\"{{", "xxx", "}}\"", "代表循环js文件里面的data数据中的xxx<view>//微信循环时会给出每个项目的内容以及每个项目的下标，默认为item和index，item.imgsrc意为对象的（imgsrc）", "key值图片：<image", "class=\"moive-img\"", "style=\"\"", "mode=\"\"", "src=\"{{item.imgsrc}}\"", "binderror=\"\"", "bindload=\"\"></image>内容：<view", "class=\"moive-content\">", "<view", "class=\"content-titile\">", "<text", ">{{item.title}}</text>", "</view>", "<view", "class=\"content-introduce\">", "<text", ">{{item.introduce}}</text>", "</view>", "<view", "class=\"content-author\">", "<", "text", ">{{item.author}}</text>", "</view>", "</view>评分：<text", "class=\"content-rank\">{{item.rank}}</text></view></block>", "基本都这里wxml就结束了，样式主要通过wxss来操作，样式比较简单，就不写了，主要讲一下左中右这三块通过将左中右这三块的父级设置为display:flex;左边和右边都设置为固定rpx，中间设置为flex:1。这样写代表中间这一块的内容占满：左边和右边布局后生下来的空间", "，即左右布局好后，剩多少，flex：1就等于多少。", "第一节项目代码见：demo1https://github.com/linrunzheng/wx-samll-demo"]}
{"author": "天下雪", "title": "Runlin微信小程序系列教程一：从零开始写一个demo《中》 ", "content": ["上一节写了一个首页列表的展示，现在我们需要一个效果：点击每个列表项，能后看到更多的细节和大图。在本页面展示或者加个弹窗是基本不可能的了。下面我们就创建一个新的页面来展示更多细节（我们之前已经创建了2个页面，其中rank页面还是空的，这里故意先不写，后面自然会补在）在pages下创建新的文件夹：detail，同时创建4个detail文件js,json,wxml,wxss对于每一个页面都需要写到app.json的pages中，因此要将我们新增的\"pages/detail/detail\"添加到“pages”数组中去。如果新增的页面是底部tabBar栏中的一项，还需要添加到tabBar中的List数组，我们这里是列表点击时的新页面，所以不需要写到list中。我们希望的效果大概是这样的：现在有一个问题时：我如何在点击的时候获取到对应的每一项的数据，并且在新的页面展示出来呢？这里要解决2个问题：###导航；参数的传递；导航", ":实现导航的方法有2种，一种是直接利用navigator组件,", "另一种是利用导航api，通过给列表添加点击事件，实现wx.navigateTo（保留当前页面，有左上角返回）或者wx.redirectTo（关闭当前页面，没有右上角返回按钮）。为了方便我们这里直接采用组件来写<block", "wx:for=\"{{moivelist}}\">", "//在这之后插入导航标签", "<navigator", "url=\"../detail/detail\">", "//url对应文件的路径，不需要写后缀wxml", "xxxxx还是原来的配方xxxxxxxx", "</navigator></block>然后我们就可以实现点击跳转的效果了，但是这时候detail.wxml还是空白的。下面开始写detail.wxml<view", "class=\"container\">", "<image", "class=\"imgs\"", "style=\"\"", "mode=\"\"", "src=\"{{item.images.large}}\"", "binderror=\"\"", "bindload=\"\"></image>", "<text>", "{{item.title}}", "</text>", "<text>", "{{\"评分\"+item.original_title}}", "</text>", "<text>", "{{\"导演\"+item.directors[0].name}}", "</text>", "<text>", "{{\"主演\"+item.rating.average}}", "</text>", "</view><view>", "{{item.summary}}</view>跟之前index一样，我们这里的数据也是从js拿过来，不过这里是从detail.js拿的，但是这个时候detail.js中的data是没有数据的，因为我们希望数据是从index列表的每一项点击时传过来的，而不是我们直接写到detail.js里面的，这个时候就需要用到生命周期函数的onload函数了也就是说，每个页面在Onload时，都可以获取上一个页面传递给你的参数（假如有的话），那么现在要解决2个问题：1是上一个页面如何传给我，2是我如何接收数据。旧页面传递参数：我们刚才在index里面加了一个导航并且", "url=\"../detail/detail\"", "，需要传递参数时，仅需要在url后面：+?+数据例如：url=\"../detail/detail?id=test\"例如：https://i.cnblogs.com/EditPosts.aspx?opt=1可以发现格式其实就是get提交数据时的格式，写过html表单form的一定很熟悉了，需要提交多个参数时，需要在后面加", "&", "符号例如：", "url=\"../detail/detail?id=test1&name=test2&age=12345\"新页面接受数据", "(注意只有在Onload时才可以接受传过来的数据)在新页面js中", "onLoad:", "function(options)", "{console.log(options)}", "即可打印出传过来的数据，你会发现这是一个对象，我们需要将这个对象,通过this.setData转化为新页面的数据，//我们这里为什么要用item是因为我们上面的数据绑定用的是{{item.xxx}},", "需要对应好，如果一个发生变动，另一个也要跟着改变//detai.js代码如下：Page({", "data:{", "title:\"加载中\",", "item:{},", "loading:false", "},", "onLoad:function(options){", "this.setData({", "item:options", "})", "},", "onReady:function(){", "},", "onShow:function(){", "},", "onHide:function(){", "},", "onUnload:function(){", "}})detail.js就算写完了，CSS方面就不写了，比较无脑，没什么好讲的，简单设置一下样式不要太丑即可，整个detail的文件都搞定了。目前我们前面的第二个导航rank还空着呢，从表象上看，rank的格式跟index是一样，仅仅是数据不同，那么我们只要把index的文件复制一份过来就可以了，把模拟的数据改一下即可。虽然可以，但是代码很多重复，下面我们就引进一个新的东西叫模板", "template", "。定义一个name为test的模板<template", "name=\"test\">", "<view>hhahahha我是模板{{item}}</view></template>使用时，需要先引入所写的模板所在的位置<template", "is=\"test\"", "data={{item:\"你好模板\"}}></template>因此，同样的我们再创建一个文件夹template放模板，同时创建.js和.wxml文件这2个即可。", "template.js并不需要数据，只是用来注册一下页面（不注册控制台有报错提示你page.js", "xxx什么的），将其他页面的.js复制过来，并将data里面的数据和其他的事件都出掉，保留最基本的空数据和空函数。template.wxml内容如下：<template", "name=\"try\"", ">", "<navigator", "url=\"../detail/detail?imgsrc={{item.imgsrc}}&title={{item.title}}&author={{item.author}}&introduce={{item.introduce}}&rank={{item.rank}}\">", "<view", "class=\"moive-item\">", "<image", "class=\"moive-img\"", "style=\"\"", "mode=\"\"", "src=\"{{item.imgsrc}}\"", "binderror=\"\"", "bindload=\"\"></image>", "<view", "class=\"moive-content\">", "<view", "class=\"content-titile\">", "<text>{{item.title}}</text>", "</view>", "<view", "class=\"content-introduce\">", "<text>{{item.introduce}}</text>", "</view>", "<view", "class=\"content-author\">", "<text>{{item.author}}</text>", "</view>", "</view>", "<text", "class=\"content-rank\">{{item.rank}}</text>", "</view>", "</navigator></template>定义好模板好，将rank.wxml内容写为：<view", "class=\"head-title\"", "\">", "<text>电影top20</text></view><scroll-view", "class=\"main\"", "scroll-y=\"true\"", "bindscrolltoupper=\"\"", "bindscrolltolower=\"\"", "bindscroll=\"\"", "scroll-into-view=\"\"", "scroll-top=\"\">", "<import", "src=\"../temple/temple.wxml\"></import>", "//引入模板", "<block", "wx:for=\"{{moivelistB}}\">", "<template", "is=\"try\"", "data=\"{{item}}\"></template>", "//使用模板，并通过wx:for将数据循环展示出来", "</block>", "</scroll-view>将index.wxss和index.js文件复制一份到rank.js，同时将rank.js中data的数据稍微修改一下，不要让数据都跟index的一样.同时将我们的index.wxml中列表也修改为使用上面的模板，至此就基本完成了。回顾一下我们主要的知识点：导航写法，如何传递参数，声明周期函数，如何获取传递过来参数，如何定义和使用模板及使用参数。到此我们使用的都是虚拟的数据，下一篇我们将调用豆瓣提供的接口来调用数据，模拟跟后台的交互。demo2源文件见", "https://github.com/linrunzheng/wx-samll-demo"]}
{"author": "天下雪", "title": "Runlin微信小程序系列教程一：从零开始写一个demo《下》 ", "content": ["上一节实现了循环列表数据渲染到视图，并给列表每一项添加了路由导航到新页面查看更多细节，但是目前我们的数据都是虚拟的，现在我们就开始利用微信的request请求来接收豆瓣电影接口提供的数据。API:", "wx.request(OBJECT)参数有7个，这里主要讲一下几个重要的：url", ":", "请求的地址data:", "携带的数据method", ":", "请求方式，默认为getsuccess:", "请求成功的回调函数了解了网路请求的方法后，我们就不需要我们原来模拟的那些数据了，把所有的假数据统统干掉，留一个空的数据用来放数据即可。data:{", "moivelist:[],", "loading:false", "}", "现在页面进来的时候只展示了一个标题，因为数据为空了循环不出来了，现在需要我们在页面进来的时候发送一个请求来接受数据。豆瓣提供的API：[Title]https://developers.douban.com/wiki/?title=movie_v2#search具体参数和接口请自行查阅，使用方法：https://api.douban.com", "+", "对应的接口", "+", "参数(如果需要的话)例子：https://api.douban.com/v2/movie/top250我们以请求", "排行250", "这个接口为例：onLoad:", "function()", "{", "var", "url=https://api.douban.com/v2/movie/top250;", "var", "that", "=", "this;//确保回调函数this的指向正确,后面会以es6的箭头函数代替", "wx.request({", "url：url,", "//KEY和KEY值相同可简写为url", "data:", "{},", "//不要求数据", "header:", "{", "'Content-Type':", "'application/json'", "},", "//成功时的回调，res为返回值，需要储存到我们的data数据里面", "success:", "function(res)", "{", "that.setData({", "moivelist:", "res.data.subjects,", "loading:", "true", "})", "}", "})", "}写完后，页面进来的时候就会发送请求，并将数据保存到moiveList,并通过循环把数据展示出来，但是如果网络差的话，会有一段真空期是没有数据的，我们需要给用户一个提示。给页面添加一个loading<loading", "hidden=\"{{loading}}\">", "加载中....</loading>###我们让这个loading一开始就是显示的，当数据加载成功后，才让他消失。我们通过将hidden绑定到{{loading}}上，更改{{loading}}的布尔值来实现这个效果。一开始{{loading}}的值是false的，也就是不隐藏；success后将他设置为true，从而实现这个效果。###这样我们这个页面就做好了，另一个页面同理，改变一下接口就行了，我们主要看一下detail这个文件。###我们现在可以实现网络请求了，在之前我们detail的数据都是外面从列表传过来的，我们是这么写的。<navigator", "url=\"../detail/detail?imgsrc={{item.imgsrc}}&title={{item.title}}&author={{item.author}}&introduce={{item.introduce}}&rank={{item.rank}}\">我靠这么长一段代码，真的需要吗？我们现在就可以简写了，我们只需要传一个参数就可以了。把template模板里面wxml里面上述代码改成下面的<navigator", "url=\"../detail/detail?id={{item.id}}\">我们只需要一个这个电影的ID就行了，我们可以根据这个ID自己请求数据//在detail.js的Onload函数中获取到页面传过来的ID", "onLoad:", "function(options)", "{", "var", "that", "=", "this;", "var", "address", "=", "'https://api.douban.com/v2/movie/subject/';", "wx.request({", "url:", "address", "+", "options.id,", "data:", "{},", "header:", "{", "'Content-Type':", "'application/json'", "},", "success:", "function(res)", "{", "that.setData({", "item:", "res.data,", "loading:", "true", "})", "}", "})", "}这样就完成了，现在我们在tabBar新增一个搜索页面。记住新页面都要添加到app.json中，这里就不再阐述了，页面大概这个样子<import", "src=\"../temple/temple.wxml\"></import><loading", "hidden=\"{{loading}}\">", "加载中....</loading><view", "class=\"searchWrap\">", "<view", "class=\"inputWrap\">", "<icon", "type=\"search\"", "size=\"20\"/>", "<input", "placeholder=\"请输入搜索内容\"", "value=\"{{content}}\"", "type=\"text\"", "placeholder-style=\"custom-placeholder-style\"", "placeholder-class=\"custom-placeholder-class\"", "bindinput=\"inputing\"", "bindblur=\"quick\"/>", "</view>", "<view", "class=\"cancel\"", "bindtap=\"searching\">{{cancel}}</view></view><scroll-view", "class=\"main\"", "scroll-y=\"true\"", "bindscrolltoupper=\"\"", "bindscrolltolower=\"\"", "bindscroll=\"\"", "scroll-into-view=\"\"", "scroll-top=\"\">", "<block", "wx:for=\"{{moivelist}}\">", "<template", "is=\"try\"", "data=\"{{item}}\"></template>", "</block></scroll-view>", "下面的列表跟前面一样，就多个了Input和按钮而已，同样的wxss样式我们就不管了，只看js。主要代码如下：data:", "{", "moivelist:", "[],", "loading:", "true,", "cancel:", "\"取消\",", "search:", "\"\"", "}", ",", "inputing:", "function(event)", "{", "if", "(event.detail.value)", "{", "this.setData({", "cancel:", "\"搜索\"", "})", "}", "else", "{", "this.setData({", "cancel:", "\"取消\"", "})", "}", "},", "//失去焦点事件", "quick:", "function(event)", "{", "if", "(!event.detail.value)", "{", "this.setData({", "cancel:", "\"取消\"", "})", "}", "else", "{", "this.setData({", "search:", "event.detail.value", "})", "}", "},", "//点击搜索事件", "searching:", "function()", "{", "if", "(this.data.cancel", "===", "\"取消\")", "{", "wx.hideKeyboard()", "}", "else", "{", "this.setData({", "loading:", "false", "})", "wx.request({", "url:", "url", "+", "this.data.search,", "data:", "{},", "header:", "{", "'Content-Type':", "'application/json'", "},", "success:", "function(res)", "{", "that.setData({", "moivelist:", "res.data.subjects,", "loading:", "true", "})", "}", "})", "}", "}看起来写了很多，其实就2件事：*", "判断Input的值，如果为空，则让按钮的值为“取消”；不为空则为“搜索”。*", "根据按钮的值绑定点击事件，为取消则让键盘下去(手机才行）为“搜索”则发送网络请求，并将接收的数据保存以便循环展示出来。到此，几个文件就都写好了，现在来对代码优化一下。1.", "wxml：我们已经创建了一个通用的模板了，好像没得优化了。2.", "css", ":", "可以发现我们几个列表都用了一个模板，因此对应的CSS代码也是一样的，我们可以把这部分CSS代码放到app.wxss公共样式里面，其他页面对应的WXSS那部分都可以删除了。3.", "js:wx.request时用到了基本相同的东西，可以放到一个单独的js里面。创建一个util文件夹，在里面创建一个util.js文件，用来放我们的方法。function", "getData(address,datas,cb){", "wx.request({", "url:", "address,", "data:datas,", "header:", "{", "'Content-Type':", "'application/json'", "},", "success:", "cb", "})}module.exports", "=", "{", "getData:", "getData}我们定义了一个方法，并通过module.exports将他导出，其他页面需要使用方法时，需要先导入var", "util", "=", "require(\"../../utils/utils.js\")使用时：util.getData(参数1，参数2，参数3)如：onLoad:", "function()", "{", "util.getData(url,{},(res)=>{", "this.setData({", "moivelist:", "res.data.subjects,", "loading:", "true", "})", "})", "}到此我们整个APP就算基本完成了，后续如果还有补充则再继续添加。代码参见demo4", "，", "网址为：https://github.com/linrunzheng/wx-samll-demo"]}
{"author": "天下雪", "title": "Code4Android：微信小程序体验历程：我遇到的问题及解决方法 ", "content": ["因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以以QQ练手，做一个高仿QQ的微信小程序，由于本人是Android开发者，平时很少接触前端的一些东西，水平有限，所以代码很多地方是不规范的，做的过程也就是一个学习的过程，一个提高的过程。", "这篇文章主要写我在SmallAppForQQ这个项目进展的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰，欢迎star项目。", "SmallAppForQQ源码", "开发工具", "官方demo", "项目结构", "文章开头，先简单介绍下项目结构，若没有安装开发工具，可去GitHub:https://github.com/xiehui999/SmallAppForQQ下载。微信小程序项目结构主要有四个文件类型,如下", "WXML（WeiXin", "Markup", "Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。", "WXSS(WeiXin", "Style", "Sheets)是一套样式语言，用于描述", "WXML", "的组件样式，", "js", "逻辑处理，网络请求", "json", "小程序设置，如页面注册，页面标题及tabBar。", "注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。", "在根目录下用app来命名的这四中类型的文件，就是程序入口文件。", "app.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。", "app.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行", "什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。", "app.wxss全局配置的样式文件，项目非必须。", "知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。", "常见问题", "rpx（responsive", "pixel）", "微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在", "iPhone6", "上，屏幕宽度为375px，共有750个物理像素，则750rpx", "=", "375px", "=", "750物理像素，1rpx", "=", "0.5px", "=", "1物理像素。", "这里写图片描述", "这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图", "这里写图片描述", "看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。", "40013错误", "这里写图片描述", "在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。", "这里写图片描述", "-4058错误", "微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。", "这里写图片描述", "我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。", "Page注册错误", "这里写图片描述", "这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.", "Page", "route错误", "这里写图片描述", "字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用<navigator", "/>组件，一种是调用wx.navigateTo。如下代码：", "wxml文件：", "<navigator", "url=\"search/search\">", "<view", "class=\"serach_view_show\"", "bindtap=\"bindtap\">", "搜索</view>", "</navigator>", "js文件事件处理函数：", "bindtap:function(event){", "wx.navigateTo({", "url:", "\"search/search\"", "})", "}", "如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除<navigator", "/>组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码", "<navigator", "url=\"search/search\">", "<navigator", "url=\"search/search\">", "<view", "class=\"serach_view_show\"", "bindtap=\"bindtap\">", "搜索</view>", "</navigator>", "</navigator>", "这种也是不允许的，也就是说<navigator/>组件内部不能再嵌套<navigator/>组件。它只能是单层存在的。", "Do", "not", "have", "*", "handler", "in", "current", "page.", "这里写图片描述", "大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。", "bindtap:function(event){", "wx.navigateTo({", "url:", "\"search/search\"", "})", "},", "tabBar设置不显示", "对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种", "注册页面即将页面写到app.json的pages字段中，如", "\"pages\":[", "\"pages/message/message\",", "\"pages/contact/contact\",", "\"pages/dynamic/dynamic\",", "\"pages/dynamic/music/music\",", "\"pages/index/index\",", "\"pages/logs/logs\"", "]", "tabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。", "tabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册", "tabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是\"pages\"中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。", "tabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。", "navigationBarTitle显示问题", "这里写图片描述", "通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。", "若你不了解生命周期，可以点击查看", "Page({", "data:{", "//", "text:\"这是一个页面\"", "},", "onLoad:function(options){", "//", "页面初始化", "options为页面跳转所带来的参数", "},", "onReady:function(){", "//", "页面渲染完成", "//NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏", "wx.setNavigationBarTitle({", "title:", "'音乐'", "})", "},", "onShow:function(){", "//", "页面显示", "},", "onHide:function(){", "//", "页面隐藏", "},", "onUnload:function(){", "//", "页面关闭", "}", "})", "通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。", "{", "\"navigationBarTitleText\":", "\"音乐\"", "}", "wx.navigateTo无法打开页面", "一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo", "本地资源无法通过", "css", "获取", "background-image：可以使用网络图片，或者", "base64，或者使用<image/>标签", "页面间数据传递", "微信小程序路由（页面跳转）是通过API", "wx.navigateTo或者wxml中<navigator/>组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在\"?\"后面，多个参数直接用\"&\"符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。", "<navigator", "url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">", "<view", "class=\"item\"", ">", "<view", "class=\"item-left\">", "<image", "src=\"{{item.url}}\"", "class=\"image\"/>", "</view>", "<view", "class=\"item-middle\">", "<view>", "<text", "class=\"title\">{{item.title}}</text>", "</view>", "<view>", "<text", "class=\"message\">{{item.message}}</text>", "</view>", "</view>", "<view", "class=\"item_right\">", "<view><text", "class=\"time\">{{item.time}}</text></view>", "<view", "class=\"mark\"", "wx:if=\"{{item.count>0}}\"><text", "class=\"text\">{{item.count}}</text></view>", "</view>", "</view>", "<view", "class=\"line\"></view>", "</navigator>", "而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下", "Page({", "data:{", "//", "text:\"这是一个页面\"", "isHiddenToast:true", "}", "onLoad:function(options){", "//", "页面初始化", "options为页面跳转所带来的参数", "console.log(options.title)", "console.log(options.message)", "},", "onReady:function(){", "//", "页面渲染完成", "},", "onShow:function(){", "//", "页面显示", "},", "onHide:function(){", "//", "页面隐藏", "},", "onUnload:function(){", "//", "页面关闭", "},", "bindtap:function(event){", "wx.navigateTo({", "url:", "\"/pages/message/search/search\"", "})", "},", "})", "这样就实现了页面间数据传递功能。", "好了，今天就写到这了后期若遇到微信小程序其它一些问题，我会追加到此文，若你在开发过程中遇到比较坑的问题已经解决方案，可在本文评论，方便大家。谢谢支持。"]}
{"author": "Rolan", "title": "如何获得你的第一个智能小程序 ", "content": ["第一个智能小程序申请帐号使用百度帐号（没有百度帐号会自动创建）登录", "智能小程序开发者后台。登录成功后，选择类型、填写信息并提交相应的资料。提交完资料，等待审核。审核通过后，就可以拥有自己的智能小程序帐号。审核通过后，登录", "智能小程序开发者后台", "。", "打开“智能小程序首页”-“设置”-“开发设置”，", "查看智能小程序的", "AppID", "。安装百度开发者工具下载百度开发者工具。", "Windows", "内测下载地址", "|", "Mac", "内测下载地址。你的第一个智能小程序成功安装百度开发者工具后，打开后出现以下界面。用户可以新建项目或者打开现有智能小程序项目。新建项目需要开发者填写项目的名称、项目开发路径和", "AppID", "。信息校验无误后脚手架会自动生成智能小程序的初始化文件。如果开发者尚没有", "AppID", "可以点击", "“注册”，注册", "AppID", "或者点击", "“智能小程序”", "选择体验模式，但体验模式下部分", "API", "可能无法正常调用。编译点击百度开发者工具上的编译按钮，可以在百度开发者工具的左侧模拟器界面看到这个智能小程序的表现，也可以点击预览按钮，通过百度APP的扫一扫在手机上体验你的第一个智能小程序。"]}
{"author": "Rolan", "title": "2个方面总结：小程序的产品设计 ", "content": ["每个人都有自己的方法，来分析需求，了解市场情况，探索用户价值，只是在探索的过程中有没有扣中需求的本质。小程序的点比较特殊", "，因为在移动互联网的流量如此之贵的情况下", "，突然能够拥抱微信10个亿的月活用户数，至少对于电商和游戏都乐开怀了，电商本质是订单，所以他才不管你在哪个平台上面，而游戏的道具付费也是一样的道理", "。小程序几个最核心的要点：微信社交关系链，这是最核心的价值，你玩游戏", "，你会想让好友家人知道你有多利害，所以比APP更容易去让周围的人参与进来，这个流程可以促发更多的可能。小程序不需要安装，即点即用，用完即走：一是用户使用没有心里负担；二是省了", "APP下载的漏斗转化的核心问题，要知道一个从广告展示到下载安装激活的漏斗路径，很多时候是惨不忍赌的，而且后面还有一堆在刷机的产业链。一开始的流量足够便宜，让很多小团队可以发挥出来余地，所以这就是时间窗口期的问题", "，流量只会越来越贵，大厂陆陆续续都进来了，只会把整个流量市场炒得越来越高。所以小程序要解决2大问题：是用户为什么打开？是用户为什么要分享？两件事情能够很好的想清楚，", "这就相对比较好去撸产品了，", "所以我们称之为「场景化设计", "」，前几个给赞大哥有分享过相关的内容", "，就不具体展开了。一、用户为什么点开？这个就是需求设计的一个最本质的点，有很多的形式让用户点开，网上会有很多关于描述色情、暴力、美食、隐私、名人、偷窥欲什么的让用户点开的可能。但是这个并不是我们要讨论的东西，而是回到本质问题，就是用户care什么，就是在他们当下所处的环境下，我们解决了他们什么问题", "，提供了什么价值给他们。我简单从2个点来切好了：1.1", "哪个领域是人类社会活动最频繁的？第一个就是去看数据，哪些数据是人类最频繁的行为，他们有什么特点。围绕着人类历史，永远离不开食色性也，还有吃喝玩乐，这一块永远是巨大的市场，还有人们生活中日常关注最多的教育问题、养老问题、工作问题、生育问题。我们要解决的问题找到领域本身，问问自己新的产品还能不能再节省成本？能不能提高效率？还能不能满足用户的情感诉求？关于如何找，可以利用好搜索引擎，需求往往藏在搜索引擎里。找关键词，找到相关的问题，找到近义词，类似相同的场景，然后人们一般怎么解决这些问题的，其实搜索引擎基本上可以把大概的东西简单摸了个底。anyway，用搜索和数据来了解场景，哪些是人们care的，哪些又是用户基本上不care的，再一一过滤。尊重数据是一件很难的事情，人是有很强的主观意识的，还有不少人会觉得他要创新，就是要与众不同。其实很多时间只是你的一厢情愿，或者是个人喜好，这就是搜索引擎的价值，数据的价值，需求就在那里，而不是拍脑袋做决定", "，或者是意淫。1.2", "关于用户切身相关的一些日常心理属性有哪些？这个就是人们日常生活的一些基本的心理需求，人们需要社交，需要新鲜感，天然对萌的东西无有抵抗力。人们会有偷窥欲，会喜欢色情、暴力、美食、游戏、无聊，想表达自己与众不同或者什么的，或者会念旧什么，whatever，就也是需求所有。曾经APP火过的玩法，在微信小程序依然会引爆，而且可能更快，因为那是被证实过的事实，我们要尊重事实。只是都挺难展开说明的，只能说去琢磨好了，越俗的东西则越说明人的共性，只是共性后面的本质是什么，仁者见仁，智者见智了。二、用户为什么自己转发？传播的2个基本要点：情感需求和利益诱导。从用户情感需求相关的东西炫耀、装逼、搞笑，他很容易就会转发，比如：P了自己的美照，玩了自己感兴趣的游戏达到新成就，用户发自内心可以激起身体多巴胺的分泌，那你引导他分享的价值就很大了，因为容易形成话题的可能。从利益诱导出发，让利、免费、便宜，我给你目标引导用户去完成。游戏规则", "「拼多多」你必须完成3个邀请才让你拼团什么的，这个更多是对人性和对任务完成难易度的把握。好了，扯了这么多，就到具体的产品设计上了。几个问题一定要自己想清楚了，就是关于用户选择新产品的问题", "：为什么用户要选择它？为什么用户会喜欢它？为什么它比传统的方式更好？用户不会平白无故的用上你的产品，要么你有大厂做靠山，产品只是最初的一个环节，如何运营整个产品才是核心所在，功能只是一小部分。用户怎么接触到这个产品，凭什么会选择它？为什么他要选择放弃原来用得好好的产品，需要你给他价值，所以价值是什么？多琢磨一下。接下来就是关于产品的设计的几个要点，", "这个是从贝佐斯分享过的产品方法，只是我在具体的产品设计中把它当成checklist在使用。谁在使用这个产品？新产品会带来什么价值？它创作价值的方式是怎样的？为什么要开发这个产品？就是要明确你的目标用户群体是谁，他们有什么特点，他们有什么需求，是否有付费的意愿和可能？然后，产品创作价值的方式是怎么样的", "？用户如何使用你的产品？用户的需求或痛点如何得到满足？最后再返过来问一下自己，为什么要开发这个产品？想清楚了就可以再最后总结一下，利用李想的产品的方法；产品提供了什么价值", "？产品对用户有什么优越感？产品是否要考虑用户安全感？衡量用户价值就二个点「时间和金钱」，用户愿意花时间在你的产品上才有价值，或者用户愿意花钱在你的产品上面。优越感会变成你的品牌向外传播的口碑，安全感决定了用户是不是用你或买你。我们的产品探索中，在团队也是讲究我们要解决的问题设定一个目标，这个目标必须清晰、可衡量和我们做产品时只谈价值，不谈用户体验，当然这都很难去实践。好了，首次分享，就到这里，请大佬点评。", "本文由", "@搞趣阿达", "原创发布于人人都是产品经理。未经许可，禁止转载题图来自网络"]}
{"author": "Rolan", "title": "微信小程序——获取绑定事件元素的ID ", "content": ["小程序list数据带值跳转，一般直接通过设置item的id来标识或者通过设置键值data-xxxx的方式标识。如下图所示：", "解析出来的结果如下图：", "我们看到它在元素上绑定了一个checkSchoolLogin事件，触发这个事件时需要获取该元素的id值，我们如何获取呢？先不急着知道方法，我们先用下面的方法看它点击的时候返回了一些什么数据：", "如下图所示，点击之后发现e里面带有这些属性，我们可以看到", "currentTarget下面有个id,", "dataset", "下面也有个id,这不正是我们需要获取的数据吗？到了这里，聪明的你肯定知道该怎么获取到值了吧~", "1.通过", "e.currentTarget.id", "即可获取该元素id。2.通过e.currentTarget.dataset.id", "即可获取你自己设置的data-id里面值。", "解决问题，不仅需要知其然，还需要知其所以然，这样，才会有进步的哟~~"]}
{"author": "Rolan", "title": "小程序之保存图片到相册的几种方法 ", "content": ["保存图片到本地有两种方法，其一是网络图片保存到相册，其二本地图片保存到相册。官方文档保存图片前需要授权，因此我们先授权，代码如下：//获取相册授权wx.getSetting({success(res)", "{if", "(!res.authSetting['scope.writePhotosAlbum'])", "{wx.authorize({scope:'scope.writePhotosAlbum',success()", "{console.log('授权成功')}})}}})//此方法可以写在app.js中，也可以写在调用保存按钮时。获取授权第一种方法，网络图片保存：var", "imgSrc", "=", "\"http://yijiao.oss-cn-qingdao.aliyuncs.com/images/http://tmp/wx1b4e5e756cd48af1.o6zAJsws4grEQvYrWTjBigy-6QaU.0llhudiKSF2V955a1c48350d9328ef064b4d36d12746.jpg\"", "wx.downloadFile({", "url:", "imgSrc,", "success:", "function", "(res)", "{", "console.log(res);", "//图片保存到本地", "wx.saveImageToPhotosAlbum({", "filePath:", "res.tempFilePath,", "success:", "function", "(data)", "{", "wx.showToast({", "title:", "'保存成功',", "icon:", "'success',", "duration:", "2000", "})", "},", "fail:", "function", "(err)", "{", "console.log(err);", "if", "(err.errMsg", "===", "\"saveImageToPhotosAlbum:fail", "auth", "deny\")", "{", "console.log(\"当初用户拒绝，再次发起授权\")", "wx.openSetting({", "success(settingdata)", "{", "console.log(settingdata)", "if", "(settingdata.authSetting['scope.writePhotosAlbum'])", "{", "console.log('获取权限成功，给出再次点击图片保存到相册的提示。')", "}", "else", "{", "console.log('获取权限失败，给出不给权限就无法正常使用的提示')", "}", "}", "})", "}", "},", "complete(res){", "console.log(res);", "}", "})", "}", "})第二种方法：选择相册图片存入本地wx.chooseImage({count:1,//", "默认9sizeType:", "['original','compressed'],//", "可以指定是原图还是压缩图，默认二者都有sourceType:", "['album','camera'],//", "可以指定来源是相册还是相机，默认二者都有success:function", "(res)", "{//", "返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片console.log(\"choose", "image\")console.log(res)var", "tempFilePath", "=", "res.tempFilePaths[0]wx.getImageInfo({src:", "tempFilePath,success:function", "(res)", "{console.log(\"get", "image", "info\")console.log(res)wx.saveImageToPhotosAlbum({filePath:", "res.path,success(res)", "{console.log(\"保存图片成功\")console.log(res)wx.showToast({title:'保存成功',icon:'success',duration:2000})},fail(err)", "{console.log('失败')console.log(err)if", "(err.errMsg", "==", "\"saveImageToPhotosAlbum:fail", "cancel\"){wx.openSetting({success(settingdata)", "{console.log(settingdata)if", "(settingdata.authSetting[\"scope.writePhotosAlbum\"])", "{console.log('获取权限成功，给出再次点击图片保存到相册的提示。')}else", "{console.log('获取权限失败，给出不给权限就无法正常使用的提示')}}})}}})}})}})如有疑问，请简信。"]}
{"author": "Rolan", "title": "微信小程序带图片弹窗简单实现 ", "content": ["怎样实现一个带图片显示的模态视图弹窗呢？有时候我们的确有这个需求，自己实现？不不不，哪有官方的方便！下面我来介绍一种使用官方组件就能实现的方法：首先找到官方文档：​显示模态弹窗的API", "wx.showModal(OBJECT)", "wx.showModal参数介绍发现并没有设置图片的参数，但是这是一个API，但是组件呢？我并没有在官方文档中找到，但是经过尝试发现是可以显示一个模态弹窗的，即：wx.showModal({", "title:", "'提示',", "content:", "'这是一个模态弹窗',", "success:", "function(res)", "{", "if", "(res.confirm)", "{", "console.log('用户点击确定')", "}", "else", "if", "(res.cancel)", "{", "console.log('用户点击取消')", "}", "}})可以改写为：<modal", "title='提示'", "hidden=\"{{modalHidden}}\"", "bindcancel='modalCancel'", "bindConfirm='modalConfirm'>", "这是一个模态弹窗</modal>但是是否隐藏，确认以及取消的回调都需要自己手动绑定至js进行控制，效果还是一样的普通模态弹窗", "下面我们给他加上图片：//wxml:", "代码如下<view", "class='container'>", "<button", "class='button'", "bindtap='buttonTap'", "type='primary'>显示弹窗</button>", "<modal", "title=\"我是标题\"", "hidden=\"{{modalHidden}}\"", "bindconfirm=\"modalConfirm\"", "bindcancel=\"modalCandel\">", "<view>", "<image", "class=\"image\"", "src=\"../images/image.jpg\"", "mode='aspectFill'></image>", "</view>", "//需要换行的话直接添加view标签", "<view>You", "say", "that", "you", "love", "rain,</view>", "<view>but", "you", "open", "your", "umbrella", "when", "it", "rains...</view>", "You", "say", "that", "you", "love", "the", "sun,", "but", "you", "find", "a", "shadow", "spot", "when", "the", "sun", "shines...", "You", "say", "that", "you", "love", "the", "wind,", "But", "you", "close", "your", "windows", "when", "wind", "blows...", "This", "is", "why", "I", "am", "afraid;", "You", "say", "that", "you", "love", "me", "too...", "</modal></view>//js:", "代码如下Page({", "/**", "*", "页面的初始数据", "*/", "data:", "{", "modalHidden:", "true", "},", "/**", "*", "显示弹窗", "*/", "buttonTap:", "function()", "{", "this.setData({", "modalHidden:", "false", "})", "},", "/**", "*", "点击取消", "*/", "modalCandel:", "function()", "{", "//", "do", "something", "this.setData({", "modalHidden:", "true", "})", "},", "/**", "*", "点击确认", "*/", "modalConfirm:", "function()", "{", "//", "do", "something", "this.setData({", "modalHidden:", "true", "})", "}})效果图如下：带图片模态弹窗", "我们还可以定制图片大小：wxss:", "代码.image", "{", "width:", "150rpx;", "height:", "120rpx;", "margin:", "10rpx", "20rpx", "0rpx", "0rpx;", "float:", "left;}这样子的话其实大家就明白了，只是一个容器，大家可以尽情的发挥想象去定制，既不用完全自己去实现一个自定义模态弹窗视图，又可以摆脱官方wx.showModal的简陋效果图如下：小伙伴们可以随意定制了", "图片和诗句我在这抄的", "那些高逼格又好玩的诗，赌你没见过."]}
{"author": "Rolan", "title": "原型故事之「蜂巢群聊」小程序 ", "content": ["这是开篇的第一个原型故事，与你分享~专题故事背景最近在做产品设计的过程中发现了一个现象，在一个产品原型投入到开发之前，会有无数个想法成为陪跑者。这些想法有的因为资源不够而搁置，有的因为商业节奏不对调整了优先级，也有的因为过于异想天开而一笑了之，更有的因为在讨论会中被怒怼到直接流产。但是不可否认的是，每一个点子和原型都是对新世界的一种假设，夹着无数的可能性。这些可能性既然在自己手里无法实现，那就拿到市场上去摆摊儿上赏识者免费领走！这也就是这个专题的初心。这些点子未来会成为什么样子？这些原型未来会成为什么样子？谁也不知道！但是谁也不能否认，它具有改变世界的可能性！原型故事-蜂巢群聊1.", "对骂群的诞生哲学这是开篇的第一个原型故事，起源于前一段时间爆火的对骂群。我也是一个对骂群的运营者。群因我而起，我传播群二维码的渠道只有朋友圈和我几个混的比较熟和一点也不熟悉的群聊。有意思的点就在这里出现了，开启骂战的时候，我发现基本全是我的同事再和我的前同事或者我的前前同事对骂，作为他们的一级人脉我是无法出口的，为了继续保持我端庄的形象只能端庄的坐着冷静的观察。不过这一瞬间的火爆，是微信这个庞大帝国刻意隐藏的冲突，这个冲突背后蕴藏的无尽的力量，虽然抵不过微信的一道圣旨。这个力量源于-熟人社交。微信月活10亿，日活9亿，抢夺了用户大量的时间精力，不少用户也因此被彻底捆绑而放弃其他陌生人社交的产品。这样，积攒已久的问题就出现了，每天可交流的永远是固定几类群体，同事，朋友，同学及家人。我看个NBA比赛也只能在体育频道自嗨，随口在弹幕里喷两句，虽然满屏参与者，但是对于你一个单独个体来说，依然孤独。想找一群一起和我讨论詹姆斯下赛季去向的问题都没有，但是", "实际上与你有相同个性和爱好需求的群体散布在这个世界上，你无法通过极简的方式去触碰", "。当突然间有一个对骂群正好是自己感兴趣的话题，又有对这个话题做了充分准备的一大波群体，按耐已经的情绪终于要得到释放，自己又要重新做起了这个领域的意见领袖，不燃才怪！！因为对骂本身就是一种目的性极强的社交行为，所以在对骂群诞生拜把子兄弟，甚至找到终身伴侣都不稀奇。2.", "蜂巢群聊-性格社交的诞生基于以上的分析，我的原型设计想解决的问题就变的非常容易理解。“打破熟人社交，让更多具有相同兴趣爱好的群体可以直接对话”。我用一种群聊共享的方式去实现我的想法。简单描述就是，所有人都可以在平台上上传群聊并添加群聊介绍，提交后，需要平台进行审核，通过后会展示在相应的分类当中。用户根据自己的需求去申请添加相应的群。问题来了，什么场景下才会有这样的需求呢？如果只像我上述对骂群那样的场景倒是没有什么社会价值！当然不仅如此！场景=时间+地点+以下内容：想找到一起支持巴西队的粉丝群体，想找到一起支持王菊的粉丝群体想找到京东优惠卷的分发的群，可以得到专属渠道优惠想找到附近的户外爱好者一起出去穿越想找到高中学生家长群，可以分享优质的学习资源想找到英语爱好者的用户群想找到区块链课程分享群想找到PM招聘群，直接微信找人想找到小程序“跳一跳”的玩家群，一起玩接力·······有人说了，你这个跟微博还有好多设计类APP有功能上的重合啊！还是那句话，", "基于10亿用户的社交软件内做小程序，将用户和应用之间的耗能降低到极致，极简的社交方式是微信群聊的核心优势。3.", "初版原型（1）蜂巢群聊小程序-首页热门的群聊分类+今日热点话题的“阅后即焚”的玩法，阅后即焚的玩法延续了对骂群的特质，但是每一个话题都新增倒计时，让讨论者在有限的时间集中讨论，并毫无顾虑，时间一到，群聊自动解散。（2）我的用户每进一个群都需要消耗一个鸡腿（虚拟货币），增加进群门槛并以此控制同一个人加群的数量并通过做人任务的形式去实现用户增长。（3）加群先阅读群资料，再决定是否入群，做到兴趣匹配。当然，加入群聊是个双向匹配的过程，群主也需要审核申请者的资料。（4）分类明细逐渐提供更加细分的品类可供选择。4.", "简版分析（1）解决的问题①", "对于需求方：信息不对称，用户无法快速找到微信群并辨别其质量，例：我作为一个家长想找一个高考资料共享群去哪里找？难精准找到共同兴趣话题讨论的社群②", "对于供给方虽然基于10亿用户的微信建立用户群，但是很难脱离自己的二级人脉直接寻找毫无关联的用户得以直接营销，例：新上一个小程序，去哪找首批粉丝群体？（2）用户群体①", "商家/企业及对商家提供的服务有需求的用户：以拉新为目的例：区块链媒体、教育类APP、新上的小程序、等所有企业②", "兴趣话题爱好者：具有共同兴趣爱好的的小团体例：音乐、户外、交友、粉丝、招聘（3）市场规模微信日活用户：9.02亿微信月活用户：10.4亿微信小程序上线：58万微信小程序日活：1.7亿（4）谁给赋能小程序本身，基于10亿用户的轻量级应用市场。（5）场景见上文（6）切入点保证群聊高质量的前提下，也要提高用户群体的质量，为了易于早期传播选择当前最火的几个主题进行切入：区块链、小程序、优质热门话题，之后再逐渐丰富。①", "区块链区块链的火热带动诞生了无数个企业，媒体、交易所、项目方等等等，所以大V粉丝社群、交易所企业社群、项目方社群有极大的流量需求等等，那么对于大多韭菜来说，信息的不对称也让每一个韭菜对进入优质信息群及其渴望②", "小程序游戏群其实这是我感觉最有价值也是可能爆发的版块，对于微信平台来说，在微信APP中是没有小程序商城的，也不允许小程序商城类的小程序上架，所以小程序玩家群入手则是更好的选择，不仅可以体验小程序，还可以在社群中把小程序的社群属性发挥到极致，如果提高认知仔细思考，这个版块是小程序商店的升级版③", "优质话题群实时热点的高质量讨论组，近期的对骂群的诞生已经反映出用户对陌生人间无压力沟通的渴望和快感，“世界杯彩票包养群”“菊外人粉丝群”“崔永元事件实时跟进群”等等，热点每天都有，给用户提供一个发泄的地方（7）小程序矩阵群空间群活动群投票找校友群通知好友位置等等其实衍生出来的设计还有好多，等我一一把原型故事写出来！希望各位杠精在评论区进行提问，跟老司机讨论可行性！万一实现了呢！！作者：郎诗文（公众号：Geek未来实验室），葡萄学院产品经理，曾混迹于趣店、银客等金融领域，现负责在线教育公司的前后端产品设计。本文由", "@郎诗文", "原创发布于人人都是产品经理。未经许可，禁止转载。题图由作者提供"]}
{"author": "Rolan", "title": "记一次小程序项目的开发心得 ", "content": ["只是展示用，建议使用template，组件中涉及到较多的逻辑，建议使用component。", "因为template没有自己的js文件，所以在列表中涉及到列表子项独立的操作，建议将列表子项写成component。示例代码：", "page文件<!--Wxml-->", "<!--引用-->", "<import", "src=\"goodlist.wxml\"/>", "<!--使用", "goodList为page传入的数据-->", "<template", "is=\"statement-goodlist\"", "data=\"{{goodList}}\"/>2.wxs文件的使用Wxs更多的是作为一个过滤器使用，.wxs", "文件可以被其他的", ".wxs", "文件", "或", "WXML", "中的", "标签引用。", ".wxs模块中引用其他", "wxs", "文件模块，可以使用", "require", "函数。示例代码", "page文件--类似过滤器效果<!--wxml-->", "<!--引用-->", "<wxs", "src=\"../../assets/wxs/phonenum.wxs\"", "module=\"phone\"", "/>", "<!--使用-->", "<text", "class='statement-adress-cellphone'>{{phone.phone(AddressInfo.phone)}}</text>3.生命周期/**", "*", "生命周期函数--监听页面隐藏", "*/", "onHide:", "function", "()", "{", "//", "前进-跳转到其他页面的时候", "},", "/**", "*", "生命周期函数--监听页面卸载", "*/", "onUnload:", "function", "()", "{", "//", "后退-点击当前页面返回的时候", "}利用这两个生命周期可以解决的问题：", "防止用户快速切换页面（A->B）。导致动态设置导航栏中的文字显示出现错误", "快速切换页面可能导致A页面中的异步数据还未返回，致使当切换到B页面的时候A数据才返回，使得导航栏显示的文字为A页面的导航栏标题。（即：A页面的导航栏标题为hello，B页面的导航栏标题为world,当快速由A->B,此时虽然在B页面，但是导航栏标题显示的是hello，而不是world）参考链接:", "小程序中的生命周期onHide和onUnload二、", "通信类如果说数据是汽车的话，传递的通道或方式就是汽车要行驶的道路。所以，数据驱动型的框架，我们少不了要学习如何建设这条\"道路\"，让\"汽车\"高速行驶。1.页面与组件通信1-1.页面传递内容给组件page为页面的属性名components", "为组件的外部属性名,", "用properties对象接收页面<!--", "Wxml", "-->", "<components-a", "components=\"{{page}}\"></components-a>", "<!--", "Js", "-->", "Page({", "data:", "{", "page:", "'父亲pages'", "}", "})", "组件父亲pages<!--", "Wxml", "-->", "<!--", "Js", "-->", "Component({", "/**", "*", "组件的属性列表", "*/", "properties:", "{", "components:", "{", "//", "属性名", "type:", "String", "}", "},", "/**", "*", "组件的方法列表", "*/", "methods:", "{", "onTap:", "function", "()", "{", "let", "page", "=", "this.data.components", "console.log(page)", "//", "我是父亲pages", "}", "}", "})", "1-2.组件传递内容给页面给组件设置myevent事件，通过this.triggerEvent('myevent',", "myEventDetail)", "触发该myevent事件并传递内容，在页面用onMyEventshi事件监听传递过来的数据。页面<!--", "Wxml", "-->", "<components-a", "bind:myevent=\"onMyEvent\"></components-a>", "<!--", "Js", "-->", "Page({", "//", "监听myevent事件", "onMyEvent:", "function", "(e)", "{", "console.log('接收a组件传递的内容:',", "e.detail)", "//", "'我是a组件'", "}", "})", "组件<!--", "Wxml", "-->", "<!--", "在自定义组件\"components-a\"中", "-->", "<button", "bindtap=\"onTap\">点击</button>", "<!--", "Js", "-->", "Component({", "properties:", "{}", "methods:", "{", "onTap:", "function(){", "var", "myEventDetail", "=", "'我是a组件'", "this.triggerEvent('myevent',", "myEventDetail)", "//", "触发组件上的“myevent”事件", "}", "}", "})", "2.组件与组件通信两个无任何关联的组件：通过全局变量或本地缓存传递数据两个有关联的组件(同一个父页面下)：", "通过上面的方法，用组件", "=>", "页面", "=>", "组件", "的方式传递数据。3.页面之间的通信3-1.使用全局变量", "app.globalData3-2.使用本地缓存", "wx.setStorageSync3-3.url传递//", "A页面-传递数据", "//", "需要注意的是，wx.switchTab", "中的", "url", "不能传参数。", "wx.navigateTo({", "url:", "'../pageD/pageD?name=raymond&gender=male'", "})", "//", "B页面-接收数据", "//", "通过onLoad的option", "<!--", "JS", "-->", "...", "Page({", "onLoad:", "function(option){", "console.log(option.name", "+", "'is'", "+", "option.gender)", "//", "raymond", "is", "male", "this.setData({", "option:", "option", "})", "}", "})3-4.后一级页面对前一级页面的数据的管理(通过获取到页面对象进行数据操作)这个方法的精髓，是通过获取到其他页面的对象原型，", "然后通过原型方法", "setData", "对当前对象管理的", "data", "进行修改", "，示例如下：//", "pageE.js", "Page({", "data:", "{", "index:", "1", "}", "})当跳转到下一个页面", "F", "之后，假定在", "F", "中有操作需要对", "E", "中的数据有修改，则可以使用以下方法：//", "pageF.js", "...", "Page({", "changeIndexInE:", "function(){", "var", "pages", "=", "getCurrentPages();", "var", "prevPage", "=", "pages[pages.length", "-", "2];", "prevPage.setData({", "index:", "0", "})", "}", "})这个方法可以操作页面堆栈里面的页面的数据，", "可以做到让后一级页面对上级页面群的数据管理", "。参考链接：", "爱范儿-页面之间的数据传递4.页面与模板之间的通信页面<!--", "Wxml", "-->", "<template", "is=\"msgItem\"", "data=\"{{...item}}\"/>", "<!--", "JS", "-->", "Page({", "data:", "{", "item:", "{", "index:", "0,", "msg:", "'this", "is", "a", "template',", "time:", "'2016-09-15'", "}", "}", "})", "传入模板的除了变量，还可以是事件方法对象。例如，模板中的点击事件，可以传递到使用模板的元素中。三", "、技巧类1.", "索引是变量，修改数组的值根据文档，采用'array[0].text':'changed", "data'的格式。但是我们实际应用中需要改变的索引值往往是动态的，所以，改装一下如下：示例代码：//", "修改某个数组的动态的值", "---", "提前将数组对象准备好", "//", "索引index是变量，", "value是变量", "var", "shipmentTypeObj", "=", "\"shipmentType[\"", "+", "index", "+", "\"].code\"", "this.setData({[shipmentTypeObj]:", "value})"]}
{"author": "Rolan", "title": "微信小程序利用canvas生成海报分享图片 ", "content": ["利用微信小程序canvas生成海报分享图片，这个生成图片排版和适配不同尺寸的手机是一个难点，特别是图片适应问题，我处理的方法是动态获取容器的宽度进行适应就是利用微信API", "wx.createSelectorQuery(),不知道还有没有更好的办法可以请教。微信截图_20180628174733.png这里就生成一个可以保存图片的海报了。"]}
{"author": "Rolan", "title": "【微信小程序】编译 .wxss 文件异常解决 ", "content": ["遇到问题", "博主最近又重新开始捡起微信小程序，想做点自己的东西。了解到最近小程序工具有做更新，就顺手更新了最新的版本，功能确实比之前强大了不少！", "更新归更新，更新后控制台就一直报下面这个错误：解决方案", "1", "在控制台输入命令", "openVendor()，回车执行", "2", "在打开的目录当中删除名为", "wcsc.exe", "的应用程序", "3", "重启微信小程序，错误已经不存在，程序正常执行"]}
{"author": "Rolan", "title": "微信小程序专题之setData ", "content": ["Page.prototype.setDatasetData", "函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的", "this.data", "的值（同步）。setData()", "参数格式setData(data,", "callback);", "//", "data需为可", "JSON", "化的数据，callback在", "setData", "对界面渲染完毕后调用setData()", "非常灵活setData()", "的第一个参数", "data", "是", "Object", "类型的数据，其中", "key", "可以非常灵活，可以以数据路径的形式给出，如", "array[2].message，a.b.c.d，并且不需要在", "this.data", "中预先定义。下面举个例子来说明：index.jsPage({", "data:", "{", "userInfo:", "{", "avatar:", "'https://images.example.com/default_avatar.png'", "},", "articleList:", "[{title:", "'init", "title'}]", "},", "onLoad:", "function", "()", "{", "let", "avatar", "=", "'https://images.example.com/avatar.png';", "let", "newTitle", "=", "'This", "is", "a", "new", "title';", "this.setData({", "'userInfo.avatar':", "avatar,", "'articleList[0].title':", "new", "Title", "})", "}", "})微信小程序这种给", "setData", "赋值的方式在原生", "JavaScript", "中显然是不行的，比如：let", "obj", "=", "{};", "obj['person.gender']", "=", "'male';", "//", "{'person.gender':", "'male'}从", "obj", "的结果我们可以看到两种赋值的差异。this.setData()", "失效？在某些情况的回调里面，直接使用", "this.setData", "会得到错误的结果，这个其实不是", "setData", "的问题，而是", "this", "指向的问题，这时候只需要提前把", "this", "赋值给另外一个变量，比如", "that，然后使用", "that.setData", "就可以了，或者使用", "ES6", "的箭头函数。代码", "Page({", "data:", "{", "starCount:", "0", "},", "onLoad:", "function", "()", "{", "//", "错误的写法", "wx.request({", "url:", "'/api/getStarCount',", "success:", "function", "(res)", "{", "this.setData({", "starCount:", "res.starCount", "});", "}", "});", "//", "正确的写法1", "let", "that", "=", "this;", "wx.request({", "url:", "'/api/getStarCount',", "success:", "function", "(res)", "{", "that.setData({", "starCount:", "res.starCount", "});", "}", "});", "//", "正确的写法2", "wx.request({", "url:", "'/api/getStarCount',", "success:", "res", "=>", "{", "this.setData({", "starCount:", "res.starCount", "});", "}", "});", "}", "})从代码中可以看到，第二种写法更加的简洁，这也是", "ES6", "带来的最大便利了，提高开发效率、减少代码量。实际开发中使用第一种和第二种都可以，取决于团队的开发规范和个人喜好。不过在微信小程序中，更推荐第二种写法，代码更少更简洁，也没有兼容问题，何乐而不为呢？"]}
{"author": "Rolan", "title": "小程序上传一张或多张图片到阿里云OSS ", "content": ["效果图：效果图", "一.准备工作1.登录阿里云服务器配置需要的参数AccessKeySecret和OSSAccessKeyId。2.Base64,hmac,sha1,crypto相关算法签名算法去下载3.WeUI组件上传图片（使用方法请参考https://www.jianshu.com/p/010cea4202b8）4.上传图片主要的代码为：", "uploadAliyun.js注意：在小程序的配置位置如图：项目中js的位置", "5.选图片的方法：点击确定上传到的代码（多张图片）：uploadImg.wxss代码：@import", "\"../../weui.wxss\";", "6.上传成功后的结果如图：结果", "其中images/http://tmp/wx1b4e5e756cd48af1.o6zAJsws4grEQvYrWTjBigy-6QaU.0llhudiKSF2V955a1c48350d9328ef064b4d36d12746.jpg", "就是在阿里云服务器的图片名称，拼接上\"http://yijiao.oss-cn-qingdao.aliyuncs.com/images/http://tmp/wx1b4e5e756cd48af1.o6zAJsws4grEQvYrWTjBigy-6QaU.0llhudiKSF2V955a1c48350d9328ef064b4d36d12746.jpg\"才是完整图片。该demo", "gitHub的下载地址：https://github.com/dt8888/uploadImage，如有疑问请发简信给我，定会回复。"]}
{"author": "Rolan", "title": "小程序•小故事——真机定位问题技巧 ", "content": ["开发者在开发小程序的时候可能会碰到一些这样的问题：问题1", "开发者工具上看效果没问题，但是在真机上测试不行？问题2", "有用户遇到小程序功能无法使用的问题，但无法快速定位解决？今天我们的小故事与大家分享一些真机定位的技巧，可以解决上面两个问题。1vConsole开发利器和远程调试功能针对问题1，我们提供了", "vConsole", "开发利器和远程调试功能，可以协助开发者在定位真机上的问题。vConsole", "的有四个Tab面板，可以先看下", "Log", "面板，看是否有异常信息，异常类型", "thirdScriptError", "是框架捕捉到的开发者的代码执行的异常，可以优先处理异常信息看是否可以解决问题。Log", "面板可以看到异常出现的文件和行数。除了异常日志，开发者还可以通过", "console.log接口在一些关键执行路径上打日志来定位问题，这些日志会呈现在", "Log", "面板上。vConsole", "默认是不开启的，可以通过下面2个方法来开启：1", "开发版和体验版可以点击小程序页面右上角的...按钮打开的菜单项“打开调试”来开启", "vConsole。2", "正式版没有“打开调试”的菜单项，可以先通过开发版和体验版来开启", "vConsole，然后再打开正式版。或者可以预埋一个隐藏操作，比如连续点击某个", "Button", "多次，然后调用", "API", "接口", "wx.setEnableDebug来打开。vConsole", "虽然强大，但在手机上查看大量的日志信息不方便，此外，vConsole", "没有断点调试、无法修改样式，定位复杂问题需要花费比较多的时间。小程序的业务逻辑运行在", "AppService", "层，页面渲染在", "WebView", "运行，并通过微信客户端通信，因此，我们想到了可以让", "AppService", "运行在开发者工具，页面渲染还是在手机", "WebView，两者通过网络来通信，这样借助开发者工具的调试能力，就可以实现远程调试功能。远程调试窗口通过手机客户端扫描开发者工具上生成的二维码来打开，无需像普通手机", "H5", "页面调试一样，需要在手机端进行一些设置。打开的远程调试界面和开发者工具的模拟器的调试界面很像，需要注意的是，要在", "Console", "里对小程序进行调试，需要将调试的上下文切换到", "VM", "Context", "1", "。更多的远程调试的使用方法请参考使用文档。2意见反馈能力对于问题2，小程序的使用反馈来自用户投诉，这种情况用户无法联系到开发者。我们遇见过有小程序功能出现问题，用户无法使用，但投诉无门的情况，而这些问题，开发者也没有途径去收集以及处理，这就导致了小程序服务质量下降，用户流失。为此，我们开发了“意见反馈”功能，当出现问题时，开发者可以引导用户使用“意见反馈”进行反馈，并上传日志来辅助开发者定位问题。操作过程如下：引导用户进入小程序帐号详情页面，具体可以在小程序界面点击右上角...按钮，选择关于菜单。接着在帐号详情页面点击右上角...按钮，选择意见反馈菜单进入页面。页面可以上传图片和日志，建议用户上传异常情况的截图，以及勾选允许开发者使用小程序日志选项上传日志，反馈信息越详细，越有助于定位问题。如果觉得上面的操作步骤太麻烦，开发者可以通过在页面", "WXML", "添加下面的按钮，用户点击按钮可以直接打开“意见反馈”页面。开发者需要定时处理用户的反馈，这样才能保证小程序的质量。开发者可以登录小程序管理后台，进入左侧菜单客服反馈，就可以看到用户的反馈内容以及下载日志来辅助定位问题。为了保证日志信息足够详细，开发者需要用下面的接口在代码的关键执行路径上写日志。wx.getLogManager", "接口的更详细使用请参考文档。希望通过这些小技巧，可以帮助大家顺畅地开发小程序。"]}
{"author": "Rolan", "title": "你有一份小程序产品设计心经，请查收 ", "content": ["微信月活用户在2018年一季度达到10.4亿人，日均登录用户在2017", "年9月就已经达到9.02亿人，从这两个数据可以看出微信的活跃人群覆", "盖率几乎占据了国内移动互联网的所有用户群体，微信已经成为人们", "在移动互联网上活动的最重要的工具，而小程序的出现会进一步强化", "微信在移动互联网中的地位，占据用户更多的使用时长。小程序陆陆续续提供越来越多服务、开放更多入口。小程序数量在下半年也将会倍加增长。那么知悉以下5点小程序接口并良好去应用，能让你的小程序level", "up", "up", "up~1.", "屏幕保持常亮状态设置是否保持常亮状态。对一些在使用时需要“待机运行”一段时间的小程序非常适用，如：直播类小程序。避免用户还处于使用状态时不能因某些客观因素造成体验差评。2.", "版本更新处理小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。什么是热启动？小程序文档的解释是：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；什么是冷启动？冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。版本更新机制就是在小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。下面以“小明、老王、小程序项目组”3大视角下看看如何避免冷启动时还是旧版本的情况“失败案例”小明：10月10日上午8点蹲马桶时打开了小程序a，此时版本为1.1.1，玩耍了一圈就溜了小程序项目组：10月10日上午11点提交了小程序a的一个新版本1.1.2，主要更新内容：小程序首页新增1个模块，用于跳转至其它小程序，此时并没有接入wx.getUpdateManager接口小程序审核团队：10月10日下午3点审核通过小程序a1.1.2版本小程序项目组：10月10日下午3点30分发布了小程序a1.1.2版本小明", "：10月10下午4点又打开了小程序a，由于没有接入wx.getUpdateManager，冷启动时未检查微信版本所以此时小程序a的版本在小明的微信上还是1.1.1版，所以小明不知道该小程序新增了一个模块。", "如果小明删掉小程序a，在搜索栏重新搜索小程序a名称进行打开重新打开的小程序a版本为1.1.2，这操作显得很不友好。老王：新来的老王之前没有打开过小程序a，10月10日下午4点老王搜索后打开了小程序a，此时版本号为1.1.2，老王可以看到新增的模块内容。“成功案例”小明：10月10日上午9点打开了小程序a，此时版本为1.1.1，玩耍了一圈也溜了小程序项目组：10月10日上午11点提交了小程序a的一个新版本1.1.2，主要更新内容：小程序首页新增1个模块，用于跳转至其它小程序，另外此时并接入wx.getUpdateManager接口小程序审核团队：10月10日下午3点审核通过小程序a1.1.2版本小程序项目组：10月10日下午3点30分发布了小程序a1.1.2版本小明：10月10下午4点又打开了小程序a，此时小明会收到提示，“新版本已经准备好，是否重新启动？”ps：小程序冷启动时自动触发wx.getUpdateManager接口，当检查到小程序有新版本，会主动触发下载操作，当下载完成后，会通过onUpdateReady告知开发者。如果小明在下载新版本时Wi-Fi断了，没有下载成功，也会通过另外一个接口onUpdateFailed进行通知。老王：新来的老王之前没有打开过小程序a，10月10日下午4点老王搜索后打开了小程序a，此时版本号为1.1.2，老王也可以看到新增的模块内容。案例结论：新版本上线时一方面避免新老用户短时间内解决信息不共识问题，另一方面化繁为简提高用户体验，避免右滑删除重新搜索等复杂流程。tips：由于小程序开发版和体验版没有「版本」概念，所以测试同学无法在开发版或体验版上测试更版本更新情况，测试需到正式版进行测试体验。3.", "监听用户截屏现在“截屏文化”深入各位机友民心，使用小程序时也有很多截屏后的使用场景。比如目前小程序内只能识别菊花码（小程序码），并不能识别普通二维码。监听用户截屏后", "触发识别二维码、触发转发等可借助该监听后的事件达到最理想的流程和结果。4.", "快速获取绑定微信的手机号截止2018年6月小程序用户游戏类占比达到34.6%，网络购物达到22.7%，此类小程序在注册、联系方式上均需要登记手机号码。对于目前对微信用户绝大多数均绑定手机号码，则可在页面上部署手机号码快速填写组件，用户点击组件，完成弹窗授权后，即可直接将微信绑定的手机号填入。（图片来源于网络）但考虑到微信号和手机号属于1对多的情况下，若绑定该微信对手机号码不想绑定在该小程序上，则需提供手动输入手机号码功能。5.", "内容安全如今小程序数量越来越多，代表在内容安全层面责任也越来越大，微信对踩红线对小程序从不手软。目前小程序对图片和文字有提供现成API供调用，确保绿色健康的微信环境（API调用限制：迸发限制1分钟2000次，次数限制1天一百万次）5.1", "图片违规校验一张图片是否含有违法违规内容。如：涉及拍照的工具类小程序(如黑咔相机小程序，识图类、肌肤测试类等应用)用户拍照上传；电商类小程序商品详情图片；媒体类小程序用户上传文章图片；社交类小程序用户上传的图片；各大小程序内用户头像检测等。5.2", "文字违规检查一段文本是否含有违法违规内容。如：各个类别用户个人资料违规文字；媒体类小程序用户发表文章／文字，各大小程序用户评论内容；游戏类用户编辑上传的素材(如答题类小游戏用户上传的问题及答案)检测等。", "本文由", "@动物园园长", "原创发布于人人都是产品经理。未经许可，禁止转载"]}
{"author": "Rolan", "title": "微信小程序填坑心路 ", "content": ["Android开发，不懂JS，不会CSS，直接上手微信小程序开发，记录心路历程。", "任务是翻版当前手机原生App到微信小程序中。模拟器与真机模拟器上面效果好好的，但是在真机上效果就会不一样。安卓和苹果效果不同，就算是苹果手机不同型号效果也不同。推送我们使用的是公众号推送，点击消息跳转小程序。直接进入小程序的某一页，不会有返回按钮，当然你可以自己写导航栏返回。点击公众号推送消息是直接跳进发布版，可以通过微信开发者工具模拟这一操作。同一个公众平台主体下，关注了公众号才能推送。pdf预览使用的是wx.openDocument(OBJECT)方法，需要先下载到本地并且指明文件类型，不支持进度跳转和进度记录。所以我们使用后的实现的web页面打开的pdf文件。下拉刷新推荐使用onPullDownRefresh，scroll-view会影响下拉，当scroll-view可以滚动的场合，下拉刷新无法响应。可以直接试用View来代替scroll-view，在真机上可以滚动。默认图片image标签，binderror绑定失败回调方法，在该方法中给src的url赋值默认图片的地址。src是空的时候不会回调binderror，需要额外的处理。富文本不要使用原本的api，兼容性很差，对富文本的格式要求很高，比如双引号，空格啥的。我们用的是wxParse。输入框输入框分为多行(textarea)和单行(input)，textarea不能和scroll-view一起使用。在真机上不会跟随scroll-view滚动。textarea会有padding，无法和view中的文字对齐，与view中的文字同一字号文字看起来也不同。模态对话框模态对话框，点击空白地方是可以被关闭的。小程序上架审核大约需要2-3小时，页面栈最多支持5层，超过5层无法后退，小程序最大2M。开发工具的代码提示功能很糟糕，没有后退功能（可能是被AndroidStudio惯坏了）。"]}
{"author": "Rolan", "title": "微信小程序使用code换openid的方法（JAVA、SpringBoot） ", "content": ["微信小程序序的代码中提示，使用code换取openid，但官方文档中没有给出进一步的说明。换取openid的要点：由于安全的原因，必须由自己小程序的服务器端完成。知道了这个要点，实现起来就简单了，服务器端写一个RestController，接收code参数，使用httpclient向微信的服务端换openid就行了。代码使用了SpringBoot，不会也不难理解。主要代码如下：package", "com.wallimn.iteye.sp.asset.common.controller;", "import", "java.util.Map;", "import", "org.slf4j.Logger;", "import", "org.slf4j.LoggerFactory;", "import", "org.springframework.beans.factory.annotation.Value;", "import", "org.springframework.web.bind.annotation.RequestBody;", "import", "org.springframework.web.bind.annotation.RequestMapping;", "import", "org.springframework.web.bind.annotation.RequestMethod;", "import", "org.springframework.web.bind.annotation.RequestParam;", "import", "org.springframework.web.bind.annotation.RestController;", "import", "com.fasterxml.jackson.databind.ObjectMapper;", "import", "com.wallimn.iteye.sp.asset.common.util.AesUtil;", "import", "com.wallimn.iteye.sp.asset.common.util.HttpUtil;", "@RestController", "@RequestMapping(\"/api/wx\")", "public", "class", "WeixinController", "{", "private", "static", "Logger", "log", "=", "LoggerFactory.getLogger(WeixinController.class);", "@Value(\"${wx.appId}\")", "private", "String", "appId;", "@Value(\"${wx.appSecret}\")", "private", "String", "appSecret;", "@Value(\"${wx.grantType}\")", "private", "String", "grantType;", "//", "wx.grantType=authorization_code", "@Value(\"${wx.requestUrl}\")", "private", "String", "requestUrl;", "//", "wx.requestUrl=https://api.weixin.qq.com/sns/jscode2session", "@RequestMapping(\"/session\")", "public", "Map<String,", "Object>", "getSession(@RequestParam(required", "=", "true)", "String", "code)", "{", "return", "this.getSessionByCode(code);", "}", "@SuppressWarnings(\"unchecked\")", "private", "Map<String,", "Object>", "getSessionByCode(String", "code)", "{", "String", "url", "=", "this.requestUrl", "+", "\"?appid=\"", "+", "appId", "+", "\"&secret=\"", "+", "appSecret", "+", "\"&js_code=\"", "+", "code", "+", "\"&grant_type=\"", "+", "grantType;", "//", "发送请求", "String", "data", "=", "HttpUtil.get(url);", "log.debug(\"请求地址：{}\",", "url);", "log.debug(\"请求结果：{}\",", "data);", "ObjectMapper", "mapper", "=", "new", "ObjectMapper();", "Map<String,", "Object>", "json", "=", "null;", "try", "{", "json", "=", "mapper.readValue(data,", "Map.class);", "}", "catch", "(Exception", "e)", "{", "e.printStackTrace();", "}", "//", "形如{\"session_key\":\"6w7Br3JsRQzBiGZwvlZAiA==\",\"openid\":\"oQO565cXXXXXEvc4Q_YChUE8PqB60Y\"}的字符串", "return", "json;", "}", "}用到了一个httpclient封闭的工具类，代码如下：package", "com.wallimn.iteye.sp.asset.common.util;", "import", "java.io.BufferedReader;", "import", "java.io.InputStream;", "import", "java.io.InputStreamReader;", "import", "java.net.URI;", "import", "java.util.ArrayList;", "import", "java.util.List;", "import", "java.util.Map;", "import", "org.apache.http.HttpResponse;", "import", "org.apache.http.NameValuePair;", "import", "org.apache.http.client.HttpClient;", "import", "org.apache.http.client.entity.UrlEncodedFormEntity;", "import", "org.apache.http.client.methods.HttpGet;", "import", "org.apache.http.client.methods.HttpPost;", "import", "org.apache.http.entity.StringEntity;", "import", "org.apache.http.impl.client.HttpClientBuilder;", "import", "org.apache.http.message.BasicNameValuePair;", "public", "class", "HttpUtil", "{", "private", "static", "final", "String", "Charset", "=", "\"utf-8\";", "/**", "*", "发送请求，如果失败，会返回null", "*", "@param", "url", "*", "@param", "map", "*", "@return", "*/", "public", "static", "String", "post(String", "url,", "Map<String,", "String>", "map)", "{", "//", "处理请求地址", "try", "{", "HttpClient", "client", "=", "HttpClientBuilder.create().build();", "URI", "uri", "=", "new", "URI(url);", "HttpPost", "post", "=", "new", "HttpPost(uri);", "//", "添加参数", "List<NameValuePair>", "params", "=", "new", "ArrayList<NameValuePair>();", "for", "(String", "str", ":", "map.keySet())", "{", "params.add(new", "BasicNameValuePair(str,", "map.get(str)));", "}", "post.setEntity(new", "UrlEncodedFormEntity(params,", "Charset));", "//", "执行请求", "HttpResponse", "response", "=", "client.execute(post);", "if", "(response.getStatusLine().getStatusCode()", "==", "200)", "{", "//", "处理请求结果", "StringBuffer", "buffer", "=", "new", "StringBuffer();", "InputStream", "in", "=", "null;", "try", "{", "in", "=", "response.getEntity().getContent();", "BufferedReader", "reader", "=", "new", "BufferedReader(new", "InputStreamReader(in,Charset));", "String", "line", "=", "null;", "while", "((line", "=", "reader.readLine())", "!=", "null)", "{", "buffer.append(line);", "}", "}", "catch", "(Exception", "e)", "{", "e.printStackTrace();", "}", "finally", "{", "//", "关闭流", "if", "(in", "!=", "null)", "try", "{", "in.close();", "}", "catch", "(Exception", "e)", "{", "e.printStackTrace();", "}", "}", "return", "buffer.toString();", "}", "else", "{", "return", "null;", "}", "}", "catch", "(Exception", "e1)", "{", "e1.printStackTrace();", "}", "return", "null;", "}", "/**", "*", "发送请求，如果失败会返回null", "*", "@param", "url", "*", "@param", "str", "*", "@return", "*/", "public", "static", "String", "post(String", "url,", "String", "str)", "{", "//", "处理请求地址", "try", "{", "HttpClient", "client", "=", "HttpClientBuilder.create().build();", "URI", "uri", "=", "new", "URI(url);", "HttpPost", "post", "=", "new", "HttpPost(uri);", "post.setEntity(new", "StringEntity(str,", "Charset));", "//", "执行请求", "HttpResponse", "response", "=", "client.execute(post);", "if", "(response.getStatusLine().getStatusCode()", "==", "200)", "{", "//", "处理请求结果", "StringBuffer", "buffer", "=", "new", "StringBuffer();", "InputStream", "in", "=", "null;", "try", "{", "in", "=", "response.getEntity().getContent();", "BufferedReader", "reader", "=", "new", "BufferedReader(new", "InputStreamReader(in,\"utf-8\"));", "String", "line", "=", "null;", "while", "((line", "=", "reader.readLine())", "!=", "null)", "{", "buffer.append(line);", "}", "}", "finally", "{", "//", "关闭流", "if", "(in", "!=", "null)", "in.close();", "}", "return", "buffer.toString();", "}", "else", "{", "return", "null;", "}", "}", "catch", "(Exception", "e)", "{", "e.printStackTrace();", "}", "return", "null;", "}", "/**", "*", "发送GET方式的请求，并返回结果字符串。", "*", "<br>", "*", "时间：2017年2月27日，作者：http://wallimn.iteye.com", "*", "@param", "url", "*", "@return", "如果失败，返回为null", "*/", "public", "static", "String", "get(String", "url)", "{", "try", "{", "HttpClient", "client", "=", "HttpClientBuilder.create().build();", "URI", "uri", "=", "new", "URI(url);", "HttpGet", "get", "=", "new", "HttpGet(uri);", "HttpResponse", "response", "=", "client.execute(get);", "if", "(response.getStatusLine().getStatusCode()", "==", "200)", "{", "StringBuffer", "buffer", "=", "new", "StringBuffer();", "InputStream", "in", "=", "null;", "try", "{", "in", "=", "response.getEntity().getContent();", "BufferedReader", "reader", "=", "new", "BufferedReader(new", "InputStreamReader(in,Charset));", "String", "line", "=", "null;", "while", "((line", "=", "reader.readLine())", "!=", "null)", "{", "buffer.append(line);", "}", "}", "finally", "{", "if", "(in", "!=", "null)", "in.close();", "}", "return", "buffer.toString();", "}", "else", "{", "return", "null;", "}", "}", "catch", "(Exception", "e)", "{", "e.printStackTrace();", "}", "return", "null;", "}", "}小程序中，使用wx.request(url:'https://域名/api/wx/session',....)，就可以拿到一个JSON对象，其中有openid。"]}
{"author": "Rolan", "title": "微信小程序模拟 cookie ", "content": ["开发背景现有系统已经有一套完整的接口，用户状态、验证都是基于", "cookie", "的。部分业务要上小程序版本，众所周知，微信小程序不支持", "cookie", "的。要上线的业务，最好的方式还是基于现有这套接口做，改动不大，也最快。模拟", "cookie通过浏览器的开发工具，Network", "栏查看请求，浏览器中的", "cookie", "会携带在每个", "http", "的", "Request", "Headers", "里面，用", "Cookie", "作为键名。那么，在微信官方请求方式", "wx.request", "中，我们设置", "header，添加一个", "Cookie", "应该可以得以模拟。问题又来了，怎么获取到服务器返回的", "cookie", "呢。通过登录接口(登录的时候，服务器端会植入", "cookie", "作为", "session)，查看", "http", "返回头。wx.request({", "url:", "'/api/login',", "success:", "(data)", "=>", "{", "if(data.statusCode", "===", "200)", "{", "console.log(data);", "//", "data", "中应该会有", "Set-Cookie", "或", "set-cookie", "的字样，嗯，那就是服务器种下的", "cookie", "}", "}", "})拿到", "cookie", "存入本地中，下次请求数据的时候直接塞进去，完美。格式化", "cookie原本以为", "cookie", "只需要一进一出就可以完美模拟，实际操作才发现，携带上去的", "cookie", "服务器无法识别。服务器返回的", "cookie", "中，会携带上很多储存用的字段，例如", "path=/;//", "服务器放回的", "cookie", "let", "cookie", "=", "'userKey=1234567890;", "Path=/;", "Expires=Thu,", "21", "Jun", "2018", "13:15:08", "GMT;", "HttpOnly,userId=111;", "Path=/;", "Expires=Thu,", "21", "Jun", "2018", "13:15:08", "GMT,nickName=;", "Path=/;", "Expires=Thu,", "21", "Jun", "2018", "13:15:08", "GMT,userName=111111;", "Path=/;", "Expires=Thu,", "21", "Jun", "2018", "13:15:08", "GMT,imgUrl=;", "Path=/;", "Expires=Thu,", "21", "Jun", "2018", "13:15:08", "GMT';", "//", "模拟的是需要的格式样式", "let", "virtualCookie", "=", "'userKey=1234567890;", "userName=111111;", "userId=111;';妈耶~要怎么过滤呢。简单粗糙的写了一个过滤方案。//", "cookie", "的本地存储位置", "const", "COOKIE_KEY", "=", "'__cookie_key__';", "/**", "*", "格式化用户需要的", "cookie", "*/", "const", "normalizeUserCookie", "=", "(cookies", "=", "'')", "=>", "{", "let", "__cookies", "=", "[];", "(cookies.match(/([\\w\\-.]*)=([^\\s=]+);/g)", "||", "[]).forEach((str)", "=>", "{", "if", "(str", "!==", "'Path=/;'", "&&", "str.indexOf('csrfToken=')", "!==", "0)", "{", "__cookies.push(str);", "}", "});", "wx.setStorageSync(COOKIE_KEY,", "__cookies.join('", "'));", "};csrfToken", "是接下来配合", "Egg.js", "用的，Path=/;", "在某些应用下会是", "path=/;normalizeUserCookie", "主要是过滤了", "xx=xxx;", "这样的数据，然后排除", "path=/;", "这样无意义的数据。在登录接口的时候，存上", "cookie，在接下来的请求中带上，那么，应该、没错、可能、可以模拟了。配合", "Egg.jsEgg", "内置的", "egg-security", "插件默认对所有『非安全』的方法，例如", "POST，PUT，DELETE", "都进行", "CSRF", "校验。Egg.js", "虽然可以在配置中关闭", "CSRF，但是，如果一定要使用呢？首先，要弄明白一件事，csrfToken", "怎么来的。经过多次验证得知，当", "http", "请求时，在约定位置没有携带上", "csrfToken", "值，此次请求会在返回的", "cookie", "中携带上一个新的", "csrfToken；当本次请求已携带上值，就不会产生成", "csrfToken。当约定位置带上的", "csrfToken", "与", "cookie", "里面的", "csrfToken", "一致时，通过验证。接上面的", "格式化用户需要的", "cookie", "操作，先抛开", "csrfToken", "单独处理用户状态等。在每次请求结束后，试着单独拿", "cookie", "中可能存在的", "csrfToken，有值就缓存，没值跳过用旧值。封装一个", "Ajax本次小程序是基于", "wepy", "的，所以使用了优化后的", "wepy.request;基于", "Egg.js", "的版本。可能与实际开发有点出入，适当修改。import", "wepy", "from", "'wepy';", "export", "const", "HTTP_HOST", "=", "'http://127.0.0.1:3000';", "export", "const", "HTTP_HOST_API", "=", "`${HTTP_HOST}/api/wxmp`;", "//", "cookie", "的本地存储位置", "const", "COOKIE_KEY", "=", "'__cookie_key__';", "//", "csrfToken", "的本地存储位置", "const", "CSRF_TOKEN_KEY", "=", "'__csrf_token__';", "/**", "*", "清除用户Cookie", "*/", "export", "const", "cleanUserCookie", "=", "()", "=>", "{", "wx.setStorageSync(COOKIE_KEY,", "'');", "}", "/**", "*", "格式化用户需要的", "cookie", "*", "@param", "{String}", "cookies", "*/", "export", "const", "normalizeUserCookie", "=", "(cookies", "=", "'')", "=>", "{", "let", "__cookies", "=", "[];", "(cookies.match(/([\\w\\-.]*)=([^\\s=]+);/g)", "||", "[]).forEach((str)", "=>", "{", "if", "(str", "!==", "'path=/;'", "&&", "str.indexOf('csrfToken=')", "!==", "0)", "{", "__cookies.push(str);", "}", "});", "wx.setStorageSync(COOKIE_KEY,", "__cookies);", "};", "/**", "*", "格式化", "token", "*/", "const", "normalizeCsrfToken", "=", "()", "=>", "{", "let", "__value", "=", "wx.getStorageSync(CSRF_TOKEN_KEY)", "||", "'';", "let", "__inputs", "=", "__value.match(/csrfToken=[\\S]*/)", "||", "[];", "let", "__key", "=", "__inputs[0];", "//", "csrfToken=1212132323;", "if", "(!!!__key)", "{", "return", "'';", "}", "//", "脱水", "return", "__key.replace(/;$/,", "'').replace(/^csrfToken=/,", "'');", "};", "/**", "*", "保存", "csrf", "的cookie", "*", "不一定每次请求都会更新", "cookie", "*", "@param", "{String}", "cookie", "*/", "const", "seveCsrfTokenCookie", "=", "(cookie)", "=>", "{", "if", "(cookie)", "{", "wx.setStorageSync(CSRF_TOKEN_KEY,", "cookie);", "}", "};", "/**", "*", "请求数据", "*", "@param", "{Object}", "opt", "*/", "export", "const", "doAjax", "=", "(opt)", "=>", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "let", "Cookies", "=", "wx.getStorageSync(COOKIE_KEY)", "||", "[];", "let", "csrf", "=", "normalizeCsrfToken();", "let", "url", "=", "opt.url;", "//", "整理", "Cookie", "Cookies.push(`csrfToken=${csrf};`);", "//", "设置请求头部", "opt.header", "=", "Object.assign(", "{", "'x-csrf-token':", "csrf,", "Cookie:", "Cookies.join('", "')", "},", "opt.header", "||", "{}", ");", "opt.success", "=", "(data)", "=>", "{", "seveCsrfTokenCookie(data.header['set-cookie']);", "//", "统一操作", "if", "(data.statusCode", "==", "200)", "{", "if", "(url", "===", "'/login')", "{", "normalizeUserCookie(data.header['set-cookie']);", "}", "resolve(data.data);", "}", "else", "{", "reject('未知错误，请重试一次');", "}", "};", "opt.fail", "=", "(err)", "=>", "{", "reject(err);", "};", "opt.url", "=", "`${HTTP_HOST_API}${opt.url}`;", "wepy.request(opt);", "});", "};原文阅读：微信小程序模拟", "cookie"]}
{"author": "Rolan", "title": "爱奇艺小程序陪你嗨一夏 ", "content": ["前言", "在炎热的夏天里最美滋滋的事情是什么呢，我觉得当然是宅在家里，吹着空调，吃着零食看电视剧电影里的帅气小哥哥、漂亮小姐姐了！在闲暇时光我会经常用爱奇艺小程序看视频，加上现在已经学习了一段时间小程序了，“啪”，动手模仿一个爱奇艺视频小程序的念头就产生了。虽然现在还是个小白，但是希望在这趟“爱奇艺小程序之旅”上为各位乘客朋友好好开车（划掉，好好介绍我的问题与经验hhh", "前期准备", "微信开发者工具", "小程序开发文档", "easy-mock：是一个前端接口模拟神器！此处放的是我的数据接口", "项目图片资源：如果想要get一下源码和图片，可以借鉴一下这篇文章哦", "两步快速获取微信小程序源码", "滴滴", "开始发车啦", "项目功能", "首页界面", "任意点击视频缩略图即可跳转到相关页面", "热点tab的下拉，上滑加载的基础功能", "搜索匹配电影名", "这是总的效果", "详细介绍", "1.首页的轮播图", "这里使用的是小程序的滑块视图容器swiper组件，用来做轮播图那叫一个简单方便", "使用过爱奇艺小程序的朋友会发现首页简单介绍视频信息的轮播图是布局在页面中间并且每一张图片都不相连的，滑动时很是简洁大方。一开始我是简单的使用，将swiper设置了宽高并使之居中，就产生了下面的结果：只有中间的内容在滑动，并不是想要的效果", "那看来即使swiper组件看起来简单也要好好研究一番哪,看了文档之后我发现swiper组件其实是swiper-item在滑动，并且它仅可放置在swiper组件中，宽高自动设置为100%。既然这样，那就去设置swiper-item的宽度好了", "swiper{", "width:100%;", "}", "swiper-item{", "width:80%;", "}", "结果就成了这个样子:", "emmm好像不太行，似乎每一个swiper-item总是那么分不开啊，那就去设置里面的内容的样式吧", ".info-box{", "width:", "100%;", "margin:", "0", "60rpx;", "}", "总算这样才做到了想要的效果。撒花~", "2.宣传图跟着轮播图改变", "在这里是使用了swiper的bindchange方法。只要滑动了就会触发，并且有一个current代表当时滑动到第几个。这样想来，swiper好像一个数组，里面包含着很多的swiper-item", "所以我们可以在js部分通过获取到这个current值，在对应的图片资源数组中遍历并取出地址，换成宣传图的地址即可", "//index.js", "moviepicChange(e)", "{", "const", "imgsUrlList", "=", "this.data.imgsUrlList;", "//图片资源", "let", "bigImg", "=", "this.data.bigImg;", "let", "video_id", "=", "this.data.video_id;", "for", "(let", "i", "=", "0;", "i", "<", "imgsUrlList.length;", "i++)", "{", "if", "(i", "==", "e.detail.current)", "{", "//如果current值与图片数组索引值匹配到了，则", "bigImg", "=", "imgsUrlList[i].thumbnail;", "//换掉宣传图片地址", "video_id", "=", "imgsUrlList[i].video_id;", "}", "}", "this.setData({", "bigImg:", "bigImg,", "video_id", "})", "}", "3.任意点击视频缩略图即可跳转到相关页面", "效果是这样子滴", "在这个功能里头，数据处理是我碰到的一大难题了，因为没有后端，我就想试图模拟一下点击一个图片就发送视频id,并由后端返回响应数据的操作，大致思路就是就是通过了一个“中间站”去处理。emmm", "可能有一点笨笨的=", "=。", "首先准备好来自Easy-Mock的数据接口", "然后在视频缩略图上绑定一下事件，用data-传递想要用于查询的参数", "<swiper-item", "data-vid=\"{{item.video_id}}\"", "data-title=\"{{item.title}}\"", "bindtap=\"openDetail\"></swiper-item>", "视频详情页面获取到传过来的id之后就可以发起请求，因为wx.request是个异步操作，需要一点时间，此处我对wx.request进行了封装，返回一个promise的办法就可以把异步操作变成了同步的啦ヾ(◍°∇°◍)ﾉﾞ", "//video-detail.js", "requestVideo:", "function(num", "=", "0)", "{", "util.request({", "//封装的util.request方法", "url:", "`https://www.easy-mock.com/mock/5b0c37bed0e51c310ce24ab0/iqiyi/media#!method=get`,", "//请求地址", "data:", "{", "//", "请求参数", "id:", "this.data.video_id,", "tag:", "'dramas',", "langs:", "'en'", "}", "})", ".then(res", "=>", "{", "//res是返回的数据", "//对数据进行处理，之后便可通过数据绑定在页面显示响应内容", "})", "}", "创建一个util工具文件夹，用于提供工具方法。这里就是我模拟后端传回响应数据的地方，先在util.js内获取所有的数据，再根据视频详情页面发送过来的参数对已经获得的数据进行处理，通过返回promise，.then的操作在视频详情页面获得由util.js处理之后的数据。", "//util.js", "let", "util", "=", "{", "request(opt)", "{", "let", "options", "=", "Object.assign({},opt);", "//花括号是目标对象，后面的opt是源对象。进行对象合并：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的", "let", "{", "url,", "data}", "=", "options;", "//结构成这两个变量", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "//向请求发起页面返回一个promise", "wx.request({", "//发送请求", "url,", "data,", "success(res)", "{", "//请求到数据之后对数据进行处理", "let", "returnRes", "=", "[];", "if", "(data.hasOwnProperty('tag'))", "{", "let", "arr", "=", "res.data[data.tag];", "if", "(data.hasOwnProperty('id'))", "{", "//如果请求参数中有tag，id则进行以下匹配", "console.log(arr)", "for", "(let", "i", "in", "arr)", "{", "if", "(arr[i].video_id", "===", "data.id)", "{", "returnRes", "=", "arr[i];", "//得到跟点击的缩略图相对应的视频资源", "}", "}", "resolve(returnRes)", "return;", "}", "returnRes", "=", "arr;", "}", "resolve(returnRes)", "},", "fail(err)", "{", "reject(err)", "}", "})", "})", "}", "}", "4.关键字搜索", "首先是在搜索页面获取到关键字，之后作为请求参数使用上述封装好util.request进行请求与数据处理", "在util.js内获取到所有数据之后，在众多数据中通过RegExpObject.test(string)实现关键字的遍历匹配", "//util.js", "if", "(data.hasOwnProperty('key'))", "{", "//如果请求参数是key", "const", "media", "=", "res.data;", "for", "(let", "i", "in", "media)", "{", "//遍历匹配电影名", "for", "(let", "j", "in", "media[i])", "{", "var", "re", "=", "new", "RegExp(data.key);", "if", "(re.test(media[i][j].title))", "{", "returnRes.push(media[i][j]);", "//得到匹配好的电影", "}", "}", "}", "resolve(returnRes)", "return;", "}", "resolve(returnRes)", "搜索页面使用util.request得到数据之后，搜索结果列表一项一项就可以显示出来。重点是(敲黑板),一般来说点击哪一项，在搜索结果页面那一项就会排在最上面，那我就想要不然再建一个由点击的的那一项作为第一项的查询结果数组，将它存在本地然后在下一个页面取出并显示！", "//search.js", "clickResult:", "function(e)", "{", "let", "index", "=", "e.currentTarget.dataset.num;", "//点击了第几项", "let", "searchVal", "=", "this.data.searchVal;", "//关键词", "let", "StorageResult", "=", "[];", "//", "用于存在本地的数组", "let", "temp", "=", "[];", "const", "result", "=", "this.data.result;", "for", "(let", "i", "=", "0;", "i", "<", "result.length;", "i++)", "{", "if", "(i", "==", "index)", "{", "temp", "=", "result.splice(i,", "1);", "//取出点击的那一项", "}", "}", "StorageResult", "=", "temp;", "for", "(let", "i", "in", "result)", "{", "StorageResult", "=", "[...StorageResult,", "result[i]]", "//将点击的那一项作为数组首位，其他搜索结果再依次放入", "}", "wx.setStorage({", "//在本地缓存搜索结果", "key:", "'searchResult',", "data:", "StorageResult,", "success:", "function(res)", "{", "wx.navigateTo({", "url:", "`search-result/search-result?key=${searchVal}`", "//跳转到下一个页面", "})", "}", "})", "}", "另外，搜索结果会顺带把集数罗列出来，那就需要实现点哪集就在视频详情页定位到哪集的功能", "先在wxml里通过data-把id、集数、标题传到下一个页面，在onload里头获取集数", "//video-detail.js", "onLoad:", "function(option)", "{", "this.setData({", "video_id:", "option.id,", "mediaList:", "null,", "})", "wx.setNavigationBarTitle({", "//设置导航条名称", "title:", "option.title", "})", "if", "(option.hasOwnProperty('num'))", "{", "//调用请求资源方法传入集数", "this.requestVideo(option.num);", "}", "else", "{", "this.requestVideo();", "}", "}", "请求所有视频资源之后并遍历，把当前播放地址设为选中的那集", "requestVideo:", "function(num", "=", "0)", "{", "//没有选择集数，则集数默认是0", "util.request({", "...(略)", "})", ".then(res", "=>", "{", "this.setData({", "mediaList:", "res,", "isLoading:", "false,", "playerUrl:", "res.drama_num[num].video_url", "//修改播放地址", "})", "this.pickNum(num);", "//改变集数选择状态", "})", "}", "用于改变集数选择状态", "pickNum:", "function(num)", "{", "for", "(let", "i", "of", "mediaList.drama_num)", "{", "i.selected", "=", "parseInt(i.drama_id)", "===", "parseInt(num)", "+", "1", "//如果选择的集数与视频资源的id一样就改变该集的选中状态", "if", "(i.selected)", "{", "playerUrl", "=", "i.video_url", "}", "}", "this.setData({", "mediaList,", "playerUrl", "})", "}", "结束语", "学习的时间比较短，做的项目还有超多不完善的，也很多没有学习到的！但是要我认为要勇于分享", "，才能更好进步(๑´ㅂ`๑)，希望能帮助一些人，也希望有人能多多指点我。", "如果说万事开头难，现在我迈出了第一步，写了第一个小程序，第一篇分享文章，就希望自己对技术能一直充满热情，多学习多钻研(握拳！", "最后厚脸皮的说喜欢这篇文章的可以点个赞吗！疯狂比心！还有这里是", "我的源码地址作者：是晕晕晕撒链接：https://juejin.im/post/5b23718be51d4558ac486eef来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]}
{"author": "Rolan", "title": "携程小程序初体验 ", "content": ["一场说走就走的旅行开始啦", "随着小程序的大热，作为一个程序猿，我也开始接触并且大概了解了一个制作小程序的一些过程，为了提高自己的动手能力，于是乎，我开始来仿写携程的小程序，来实现一些基本功能，在仿写的过程中，也遇到了一些难题，也有了一点收获，希望可以通过这篇文章与大家共同交流，共同进步。", "前言", "为了更好的开发，我们需要准备我们需要的工具：", "Vscode：这里主要用来具体代码的编写", "微信开发者工具：通过这个看效果图", "EasyMock:", "通过这个网站可以伪造一些数据来供我们使用，非常方便。这个是我的数据接口", "具体实现", "功能效果如下", "查询功能的实现", "1.首先需要在查询之前获取输入的所在城市以及到的城市，以及时间的选择，通过这些条件去筛选，所以需要在点击查询按钮的时候绑定一个时间，需要携带参数去进行查询", "<navigator", "class=\"search\"", "url=\"/pages/trainBuyContent/trainBuyContent?from={{from}}&to={{to}}&trainTime={{startDate}}\">查询</navigator>", "2.需要到跳转的页面接收参数通过onload事件的options获取", "var", "from", "=", "options.from;", "var", "to", "=", "options.to;", "var", "trainTime", "=", "options.trainTime;", "3.最重要的是筛选出相关数据，这里需要一个for循环的判断语句，在请求数据地址URL的时候，通过for循环和if语句找出相对应的数据文件里面所对应的json数据。", "wx.request({", "url:", "API_BASE,", "success:", "(res)", "=>", "{", "for(var", "i=0;i<res.data.data.trainList.length;i++){", "if", "(from", "==", "res.data.data.trainList[i].from", "&&", "to", "==", "res.data.data.trainList[i].to", "&&", "trainTime", "==", "res.data.data.trainList[i].trainTime){", "temp.push(res.data.data.trainList[i]);", "}", "}", "this.setData({", "searchedList:temp", "})", "}", "})", "4.这时候再在页面通过for循环输出就可以了", "wx:for=\"{{searchedList}}\"", "wx:key=\"{{item.id}}\"", "temp.push(res.data.data.trainList[i]);", "this.setData({", "searchedList:temp", "})", "*小程序页面传值的方式：1.url传值2.本地储存3.全局的app对象", "订单查询的实现", "这里我采用了全局的app对象保存", "1.先获取全局对象，然后在点击确定购买的success回调函数的时，去获取所有的信息，以一个json格式去获取", "const", "app", "=", "getApp();", "var", "trainedList", "=", "app.globalData.trainedList;", "var", "trainItem", "=", "{", "from:", "this.data.from,", "to:", "this.data.to,", "trainNum:", "this.data.trainNum,", "trainTime:", "this.data.trainTime,", "totalPrice:", "this.data.totalPrice", "};", "trainedList.push(trainItem);", "2.然后在相应的页面去获取这个全局的数组", "onLoad:", "function", "(options)", "{", "this.setData({", "trainedList:", "app.globalData.trainedList", "})", "},", "3.通过一个for循环让其输出在页面", "其他功能", "还有一部分功能未能展示或者未完善，请大家见谅。", "源码地址", "GitHub地址：github.com/yrq1429/yrq…", "小总结", "第一次发表文章有点小慌张，写的不好希望大家谅解，说实话，在我看来，这次所写的东西确实有点'糙'，但还是很开心自己能坚持写下来，功能方面以后会继续完善，希望能得到各位大佬们的意见和建议，没啥说的，继续努力吧，路漫漫其修远兮，Just", "do", "it!", "作者：YRQ1429链接：https://juejin.im/post/5b1bc7b26fb9a01e266b8a3d来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]}
{"author": "Rolan", "title": "『技术分享』—— 我的第一个微信小程序-趣闻 ", "content": ["我去年3月份写了一个小项目", "快毕业了，撸一个小项目(趣闻)", "作为自己的毕设项目，当时接触", "Android", "也才半年的时间，所以写的略简单，偏入门级别的，有兴趣的话可以", "clone", "看一下。", "趣闻小程序的火热程度我就不多说了，我之前对这个就蛮有兴趣的，于是花了大概5天的时间，完成了", "学习-入门-写项目", "这一套流程。作为前端", "0", "基础的我都这么快入门了，可想而知，微信小程序的封装是相当好的，基本上过一遍官方文档就可以进行编写了。项目预览话不多说，看一下项目的整体预览：", "建议在", "wifi", "进行查看整体的效果就是仿照之前的趣闻项目，基本的功能都是有的。其中包括四大模块：新闻、段子、历史上的今天和小爱同学。后面对每个模块的特点进行说明。新闻模块这里先声明一下，因为该项目涉及到文娱信息，需要上传相关资格证，所以就上不了线。不过我个人对此并不是很在意，因为之前的", "Android", "项目已经经历过上线失败了。。。而且这个小程序本身就是自己的练手项目，没有必要非得上线不可，达到目的不就行了，如果感兴趣的也是可以把项目", "clone", "下来预览一下的。看一下预览图功能：查看多种类型的实时新闻，点击新闻查看新闻里面的图片这里因为个人小程序是不支持外链的，因此不能查看新闻的详情。如果确实想看新闻的详情，可以点击", "url", "便可复制到剪贴板上，粘贴到本地浏览器进行查看。段子模块功能：查看最新的段子笑话，支持下拉刷新和上拉加载更多功能，并可以长按段子进行复制分享。历史上的今天功能：查看历史上今天的所有相关事件列表，支持下拉刷新，点击单个事件，查看事件的详情介绍。小爱同学其实跟小爱同学没有任何关系(快来欺负老实人)。。这里就是普通的机器人，不过可以智能记录上次的会话内容，比如，你跟他说", "「我叫小爱」，接着你再问", "「我叫什么」的时候回答出你上次记录的名字。项目知识点这里记录一下自己开发过程中遇到的对于我来说比较复杂的地方。对", "css", "和", "js", "零基础的我，只能在使用过程根据需要进行查找对应的使用方法，也是蛮坎坷的。布局当然是使用", "Flex", "布局，介绍两篇好的文章Flex1、Flex2，讲的很详细，足够日常的开发使用了。我这里大概总结一下。Flex-direction", "决定元素的排列方式Flex-wrap", "决定元素如何换行Flex-flow", "flex-direction", "和", "flex-wrap", "的简写Justify-content", "元素在主轴上的对齐方式Align-items", "元素在交叉轴的对其方式Flex-grow", "当有多余空间时，元素的放大比例flex-shrink", "当空间不足时，元素的缩小比例Flex-basis", "元素在主轴上占据的空间flex", "是", "grow", "shrink", "basis", "的简写Order", "定义元素的排列顺序Aligh-self", "定义元素自身的对其方式圆角和阴影border-radius", ":", "设置圆角box-shadow", ":", "设置圆角文字的显示行数限制word-break:", "break-all;", "display:", "-webkit-box;", "-webkit-box-orient:", "vertical;", "-webkit-line-clamp:", "3;", "overflow:", "hidden;其他的就是官方文档的组件使用，很详细就不多说了。总结从学习到开发完一个小的项目一共用了4天的时间，不得不承认官方的文档很详细，当然也会有不少的坑，但是我相信这些坑，官方会慢慢维护和完善的。根据这几天的学习开发说说我自己的心得和感受。学习来源官方文档", "(毋庸置疑，有全面、又详细)某客学院的", "vip", "视频(有需要私聊发给你)菜鸟教程", "(这个因为时间原因没看多少，但是干货还是蛮多的)数据来源数据同趣闻", "来源于聚合数据，不过我最近也在学后端，买了服务器，写了接口，不过还有许多需要完善的，就没有用，而且也是为了仿照之前项目，就直接拿聚合接口使用了。不过很有趣的是，单单一个新闻的接口就已经请求了", "50000+，而且聚合数据平台对免费用户设置了", "100次/天/接口", "的限制，为了能让项目正常运行，也是特定充了", "VIP", "进行续命，也是很无奈。迟早有一天我要把他的数据爬到自己的服务器！"]}
{"author": "Rolan", "title": "小程序的十万个为什么丨框架 ", "content": ["Q：小程序如何设置页面路径？", "Q：小程序如何设置默认页面窗口表现？", "Q：小程序如何设置底部tab表现？", "Q：小程序如何设置网络超时时间?", "Q：小程序如何进行数据绑定？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/data.html", "Q：小程序如何列表渲染？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html", "Q：小程序如何条件渲染", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html", "Q：小程序如何定义、使用模板？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/template.html", "Q：小程序事件使用详解？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html", "Q：小程序如何引用？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/import.html", "Q：小程序中如何注释？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/03annotation.html", "Q：小程序模块", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/01wxs-module.html", "Q：小程序变量", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/02variate.html", "Q：小程序运算符如何使用？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/04operator.html", "Q：小程序if、switch、for、whlie语句使用方法？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/05statement.html", "Q：小程序样式导入？", "https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html", "Q：小程序如何创建、使用自定义组件？", "https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/", "Q：小程序如何开发插件？", "https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html", "Q：小程序如何使用组件？", "https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/using.html", "Q：小程序如何使用分包加载？", "https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html", "Q：小程序兼容方式？", "https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html", "Q：小程序运行机制？", "https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html"]}
{"author": "Rolan", "title": "小程序的十万个为什么丨框架 ", "content": ["Q：小程序如何设置页面路径？", "Q：小程序如何设置默认页面窗口表现？", "Q：小程序如何设置底部tab表现？", "Q：小程序如何设置网络超时时间?", "Q：小程序如何进行数据绑定？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/data.html", "Q：小程序如何列表渲染？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html", "Q：小程序如何条件渲染？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html", "Q：小程序如何定义、使用模板？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/template.html", "Q：小程序事件使用详解？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html", "Q：小程序如何引用？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/import.html", "Q：小程序中如何注释？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/03annotation.html", "Q：小程序模块https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/01wxs-module.html", "Q：小程序变量https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/02variate.html", "Q：小程序运算符如何使用？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/04operator.html", "Q：小程序if、switch、for、whlie语句使用方法？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/05statement.html", "Q：小程序样式导入？https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html", "Q：小程序如何创建、使用自定义组件？https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/", "Q：小程序如何开发插件？https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/development.html", "Q：小程序如何使用组件？https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/using.html", "Q：小程序如何使用分包加载？https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html", "Q：小程序兼容方式？https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html", "Q：小程序运行机制？https://developers.weixin.qq.com/miniprogram/dev/framework/operating-mechanism.html"]}
{"author": "Rolan", "title": "mpvue开发小程序所遇问题及h5转化方案 ", "content": ["项目结构", "|---build", "|---pages.js文件目录", "|---src", "|---component子组件", "|---pages", "|---业务页面", "|---store，vuex储存", "|---utils", "|---请求api.js", "|---format格式化插件，小程序中不能使用vue自带的格式化只能手动修改后台返回的时间戳，价格，订单状态等", "|---request封装fly进行请求响应拦截", "|---wx.js", "环境及依赖", "less-loader,提供嵌套样式，谁用谁知道", "flyio提供请求便于请求模块的快速转化h5(flyio提供了h5,小程序的请求封装，参考mpvue中提供的一个例子写拦截器，用于处理后台返回未登录状态跳转页面)，自己在小程序中wx.request封装也一样，只是转h5又需要做一个axios。", "腾讯地图qqMap提供的reverseGeocoder(wx.getLocation只提供了经纬度定位，而产品需要的是确认定位后获取城市，进行同城商品检索)", "阿里云oss对象储存处理文件上传，比较意外的是腾讯对阿里云的oss域名前缀进行了封禁后台不能配置，解决方案是让后台将该域名进行服务器域名代理。提一嘴，最开始用七牛云没有出现这个问题，嫌麻烦的可以用七牛", "富文本处理，使用mpvue例子中提供的mpvue-wxparse，当然你也可以自己写", "小程序开发过程遇到的问题", "使用mpvue是一个非常爽的过程，vue的语法基本能正常使用但有几个需要注意的问题", "页面传递参数类似get请求?key=value，下一个页面采用$mp.query.key获取但是在同类型的页面如商品详情多次key的切换由于页面缓存key会保持不变，根据业务不同情况可能不同，我采取的方案是在onUnload中清除key，虽然mpvue文档官方不推荐用小程序的周期，但需要多次切换key的页面目前能够实现先这么处理吧。", "最开始仅打算做小程序，后来需要补充app，需要在开放平台关联小程序后使用unionId以使三端用户相同，没有做好产品定位，需要重新进行表结构设置。获取方法为利用wx.login获取iv，sessionkey解析encryptedData", "图片验证码需要带session，因此不能直接用img标签发送get请求，而是需要要通过filedownload请求地址下载二进制文件后转链接绑定给img", "input函数触发聚焦需要先设置:focus先为false再为true进行聚焦", "子组件因为只会绑定一次不会触发OnShow周期，父组件在onshow周期获取获取不到this.$children", "小程序在关闭5分钟内不会被清除部分页面还是需要下拉刷新这个功能，可以在main.js开启enablePullDownRefresh:", "true，但会与scroll-view中的下拉冲突，只能二选一", "我们可以通过swiper嵌套scroll-view进行tab栏组件制作，swiper这个组件的高度需要用js写定高度，高度通过getSystemInfo获取，如果通过弹性布局flex:1;可能导致部分ios旧版本高度撑不开,嵌套比较多就不贴代码了", "默认各种小程序原生自带图标是白色，如果背景色是白色，那么你可能一下子发现不了加载图消失的原因.window里配置backgroundTextStyle:'dark'", "小程序有不少保留字需要注意不要重复，查看Q&A", "前几次提交审核似乎是机器审核，代码异常也可以通过。", "watch全局vuex会在非当前页面执行，如果你拿了$mp里面的参数可能会全局报错", "！！！分享需要注意分享出来的是单页没有返回到首页，只能点击右上角三点，如果还没有进行过操作建议应该先带页面参数到首页，经过首页跳转到分享目的页面，这样会自然一点，目前我的项目基本完成，为不影响整个流程，我在几个关键页面中判断getCurrentPage().length>1?来判断是否为第一页，如果是第一页就显示一个返回首页的按钮，实属无奈", "转h5实践", "小程序与h5需要替换的大概30%页面渲染轻松，但组件替换需要花一定时间，比较复杂的包括以下vue项目常用部分，如果有一两个vue项目相信早就操作过这些部分，替换这些组件也就改改业务逻辑，采用的ui框架是接近weui的vux", "wx这个对象我们可以结合router和vux封装一下其中的navigateTo，redirectTo等路由及模态框和toast，并在webpack.base.conf配置wx指向该文件,这样我们就能直接使用wx这个对象面的方法不用修改", "/*webpack.base.conf*/", "resolve:", "{", "extensions:", "['.js',", "'.vue',", "'.json'],", "alias:", "{", "'vue$':", "'vue/dist/vue.esm.js',", "'@':", "resolve('src'),", "'wx':", "resolve('src/utils/wxSimulate.js')", "}", "},", "/*模拟wx的自己写的wxsimilate.js*/", "import", "router", "from", "'../router'", "import", "Vue", "from", "'vue'", "import", "{", "ConfirmPlugin,", "ToastPlugin", "}", "from", "'vux'", "Vue.use(ConfirmPlugin)", "Vue.use(ToastPlugin)", "const", "wx", "=", "{", "navigateTo", "({", "url", "})", "{", "console.log(url)", "router.push({", "path:", "url", "})", "},", "redirectTo", "({url})", "{", "router.replace({", "path:", "url", "})", "},", "navigateBack", "()", "{", "router.go(-1)", "},", "showToast", "({title})", "{", "Vue.$vux.toast.show({", "//", "组件除show外的属性", "text:", "title", "})", "},", "//", "模态框显示", "showModal", "({title,", "content,", "success})", "{", "Vue.$vux.confirm.show({", "title,", "content,", "//", "组件除show外的属性", "onConfirm", "()", "{", "success", "&&", "success({confirm:", "true,", "cancel:", "false})", "},", "onCancel", "()", "{", "success", "&&", "success({confirm:", "false,", "cancel:", "true})", "}", "})", "}", "}", "window.wx", "=", "wx", "export", "default", "wx", "地图(采用vue-amap)，不多说，面向api编程", "上下拉加载采用betterscroll封装一个scroll组件进行slot,slot文章参考点左边", "rpx采用less+flexible中@rpx代替，只需要把所有rpx换成@rpx即可，不懂的小伙伴可以去看一下rem相关/*mpvue*/", "<style", "scoped", "lang=\"less\">", "#index", "{padding:100rpx", "20rpx", "110rpx;}", "/*vue*/", "<style", "scoped", "lang=\"less\">", "@charset", "\"utf-8\";", "@rpx:", "117.188rem;", "#index", "{padding:100/@rpx", "20/@rpx", "110/@rpx;}", "flyio从mpvue搬过来基本不变", "刚才mpvue中提到的阿里云oss上传需要修改配置文件中的uploadFile为h5中的FormData进行文件上传", "两者的input聚焦函数业务不同，h5中ios不允许函数吊起聚焦需要用户自己手点，安卓还是可以的el.focus()进行。", "最后感谢美团的各位大佬，让我这个菜鸡舒舒服服的开发了小程序、业绩也达标了，对文章有问题的大佬请指正，希望大家都能顺顺利利开开心心的开发小程序，最近看到京东出了个taro又准备开启新的填坑之路啦。"]}
{"author": "Rolan", "title": "七天速成小程序--喜马拉雅 ", "content": ["很多新手都喜欢一个人完成项目，从项目的规划、搭建，到实施、debug、验收，一整套流程都是自己纯手完成，当然，对于提高自己的整体开发能力和自适应能力很有帮助。ok,不废话，下面开始介绍小白如何快速完成一个微信小程序。首先喜马拉雅App比较大，这里只完成部分重要功能。。。本文章使用的是以喜马拉雅电台App防成微信小程序的栗子。您可以从这篇文章中获得以下技能点：选择项目需要的合适工具如何快速分析项目功能并组成列表如何快速完成并搭建一张页面，并为复用提供良好的接口如何应对短时间内无法解决的bug如何规划每一天的工作量和调整工作心态提前准备工具工具是非常重要的，当然，也是很简单的。。。编辑器（我使用的是vscode）：@Visual", "Studio", "Code微信web开发者工具下载：", "@微信web开发者工具笔记（我使用的有道云）:", "@有道云笔记github（每日提交一下）:", "@githubmark", "Man（基本的页面样式标注，大公司都有专门的ps设计师，这里将就一下）mark", "Maniconfont（阿里巴巴字体图标库）@iconfontweui（微信样式框架/这项目中css纯手写，新手建议纯手写，实在无法写出可采用部分框架中的样式）@WEUI项目分析列表在这个例子中,我们只分析其中的一个小小的模块：基本页面及其简单功能首先，前提，喜马拉雅电台是一个音频分享有声读物的app，由于微信小程序的限制2M，我们这个模块不可能太大，功能也不可能齐全，所以我们要适当的缩减部分功能，--->>", "缩减功能然后，由于人数、时间、精力有限（单人完成），所以我们需要一个系统的流程来保证项目的顺利实施。--->>", "资源控制项目的提升空间和后续维护提供良好接口，--->>易于维护和升级页面模块流水分类页面喜马拉雅APP分类页面原图：思考：该页面采用顶部的固定搜索栏和swiper内容区俩个模块，俩个模块均可采用绝对定位，搜索栏flex布局，swiper内容区内swiper-item有分类，推荐，精品，直播和广播3.1分类模块：最近浏览：flex布局，固定位置，动态更改最近浏览数据，初始隐藏顶部推荐：固定数据，固定图片娱乐、知识、生活、特色相同布局，flex布局，采用wx:for循环，减少耦合和增加复用性swiper轮播图横向滑动，无缝滑动细节：1.", "整个页面的滚动条优化：::-webkit-scrollbar", "{", "width:", "0;height:", "0;color:", "transparent;", "}2.", "所有文字都不能贴边page{", "width:100vh;height:100vh;overflow:hidden;background-color:#f8f8f8;padding:0", "20rpx;}3.", "icon采用统一样式，增加class提供color更改颜色，提高复用、维护、可读性", "--（不过我这里使用的是图片，初始想用图标，但是微信引用是在无法引用http，页面由于是静态，所以可以使用图片）.iconfont", "{width:45rpx;height:45rpx;overflow:hidden;display:inline-block;color:#fff;}", ".iconfont-enjoy", "{", "color:#xxx;}", "自定义颜色", ".iconfont-knowl", "{", "color:#xx;}", "自定义颜色", ".iconfont-knowl", "{", "color:#xx;}", "自定义颜色4.", "字体：简书字体，平滑抗锯齿、font-family:", "\"lucida", "grande\",", "\"lucida", "sans", "unicode\",", "lucida,", "helvetica,", "\"Hiragino", "Sans", "GB\",", "\"Microsoft", "YaHei\",", "\"WenQuanYi", "Micro", "Hei\",", "sans-serif;-webkit-font-smoothing:", "subpixel-antialiase;5.", "swiper-item里结构最好细分模版<!--历史记录-->", "<view", "class=\"history\"></view>", "<!--列表顶部,三个列表使用js循环-->", "<view", "class=\"list", "list-bottom\"></view>", "<!--细节列表，多个列表，可以使用js和easyMock获取，不过经过多天观察，该页面的数据基本是静态，为了防止过度https请求，直接静态写死-->", "<view", "class=\"entertainment\"></view>", "<!--底部swiper-->", "<swiper>", "<swiper-item", "autoplay=\"true\"", "interval=\"4000\"", "duration=\"400\">", "...巴拉巴拉", "</swiper-item>", "</swiper>", "mark", "Man设计师小程序最终效果图:精选页面----由于页面过多就不演示过多不重要的流程了，如果想进一步了解的话可以去app直接观看原图细节：分类栏采用的的wx:for循环了数量、颜色、图片、如果需要，可以动态膝盖数据库中数据，无需修改html<block", "wx:for=\"{{choiceIcon1}}\"", "class=\"choice-menu__block\"", "wx:for-item=\"item\"", "wx:key=\"*this\">", "<navigator", "class=\"menu-warpper__nav\"", "url=\"{{item.navUrl}}\">", "<view", "class=\"menu-image\"", "style=\"background-color:{{item.backgroundColor}}\">", "<image", "src=\"{{item.imageUrl}}\"", "class=\"icon2\"></image>", "</view>", "<text>{{item.title}}</text>", "</navigator>", "</block>", "为所有的文字留下足够的空间，如果空间不足：overflow:", "hidden;white-space:", "nowrap;text-overflow:", "ellipsis;所有的图片都预留位置，并且优化边框和预留小图标，如果需要直接引用class或者增加一个模块，当然，使用vue时可以把它直接封装template模块<!--html-->", "<view", "class=\"FineQualityBac\">", "<image", "class=\"FineQuality-icon\"", "src=\"../images/recommend/皇冠.png\"></image>", "</view>", "<!--css-->", ".FineQuality-icon{width:", "18rpx;", "height:", "18rpx;", "position:", "absolute;", "left:", "-35rpx;", "top:5rpx;", "transform:", "rotate(-45deg);}", ".FineQualityBac{width:", "0;", "height:", "0;", "border-left:40rpx", "solid", "#ff4612;", "border-bottom:40rpx", "solid", "transparent;", "position:", "absolute;", "left:", "0;", "top:", "10rpx;}", "所有的循环都是用block块标签包裹循环，便于测试和维护每个模块之间没有直接联系，解耦方便半像素问题：<!--", "基本流程：样式放大俩倍,边框一像素，选择缩放点，scale缩放,确定盒子模型大小", "-->", "<!--", "一般用于伪元素设置边框分开上下内容", "-->", ".xxx:after{", "content:", "'';", "position:", "absolute;", "width:", "200%;", "height:", "200%;", "border:", "1px", "solid", "#888;", "top:1px;", "left:-1px;", "-webkit-transform-origin:", "0", "0;-moz-transform-origin:", "0", "0;-ms-transform-origin:", "0", "0;-o-transform-origin:", "0", "0;transform-origin:", "0", "0;", "-webkit-transform:", "scale(0.5,", "0.5);-ms-transform:", "scale(0.5,", "0.5);", "-o-transform:", "scale(0.5,", "0.5);transform:", "scale(0.5,", "0.5);", "-webkit-box-sizing:", "border-box;-moz-box-sizing:", "border-box;box-sizing:", "border-box;", "}", "以数据为中心的微信小程序缺陷：css的用户体验不是很好，看图说明：原图小程序是不是发现了什么，没错，底部的线滑动出现不同，在app中，当你滑动一点点的时候，导航底部线就会发生滚动，可以看出同时进行，而在微信小程序中，由于是数据为中心，我直接设置滑动后产生的效果就是增加一个数据关联current在绑定bindChange事件而已，但是中间的过度无法实现。当然实现也不是不可能，自己使用外部插件swiper，这样你的代码量和复杂度又得增加了好多，还有微信直接禁用了css多种选择器，你不得不增加很多class，哎..麻烦后期优化空间：图片区域如果未加载成功可以显示背景图，使用js控制每张图片的加载，如果未成功加载则显示一张未显示图片或者icon其余页面当然了，每日笔记必不可少呦...更多页面就不多显示了，懒...总结页面就是一个基本结构和一堆模块外加js交互组合起来的。快速完成一张复杂的页面只需要：绘制基本架构、增加功能模块、js交互三部就能完成。1.", "绘制基本架构：拿到设计稿，第一步看页面的基本构造，这时细节不重要，看总体架构，增加合适的class命名格式，这样可以为内部的模块提供合理的class命名格式，避免class混乱而造成页面样式混乱，维护css样式麻烦一定要打标注，在大的模块中一定要注明标注，css,html,js,都需要标注特定功能提示。如果需要，你可以绘制一张树形图，我认为图可以把一切复杂繁琐的事情抽丝剥茧成小小的步骤，而树形图是最直观的体现。微信小程序的各种限制阻遏了小程序的发展前景，css多种选择器、最大容量，用户权限、数据为中心的缺陷...以前一直认为微信这样做很吃亏。明明小程序很火，快速完成及其功能简洁开发成本低的优势使得它在这几年风生水起，既然这样，何不降低限制增加功能？？真的是这样么？？当然，以前接触不是很深，不懂太多道理，经济学，经融学太高深，现在也是模模糊糊的，涉及太深，感兴趣的请看大佬文章微信小程序，大多数人误解的8个问题在写这个小程序的时候，我觉得最大的感悟是页面的css重构和html页面结构的设计，他们都有一个共同点，就是有自己的思想。我必须在动手之前先在脑中描绘一幅图像，然后在用积木模块堆叠起来，堆叠中会有一些共同点，你可以选择合并样式，还是分割样式，这些都是经过思考后才动手的，想想建房子就明白了。一般的切图仔不会像那么多，只会从上到下直接敲，这是最耗时，也最累的，真心不建议这样做。当然，学无止境，还要学的东西还有好多，技术是一方面，更重要的是交流。这里我也不发表什么建议，自行体会吧...最后聊聊js。c++", "看不起java,java看不起python,python看不起js，js看不起php,php是最好的语言....,所以喽，咱们去学php吧！！！咳咳，开个玩笑，莫介意。怎么说，js在我看来其实也不难，也许我学的不深吧，但至少我自我感觉js不是很差。我是这么认为滴，首先js是一门工具，如果我要实现某个功能，比如对数据的懒加载,首先完成懒加载实现功能函数，然后封装代码防止污染、然后扩展功能增加错误处理解决预处理参数问题、然后提供用户接口、最后多次测试push提交。如果有时间的话，我可能会尝试完成架构，在用户使用和功能模块之间提供一个甚至多个过度嫁接，这个很耗时间，有兴趣的朋友可以私信我哦，毕竟我也是刚刚接触，一起学习吧，最后奉上我的源码，欢迎各位使用。"]}
{"author": "Rolan", "title": "小程序——带参返回上一页几种方法 ", "content": ["小程序的页面跳转API像wx.navigateTo()、wx.redirectTo()之类的，都是跳转到一个全新的页面，当这个页面是表单的时候，有时候需要跳转到其它页面选取信息后再跳转回来，那之前填的信息就必须得存在，这个时候可以当跳转到选择信息的页面，选中信息后设置设置上一页的data，然后再返回到上一页，这样数据都会存在。方法一", "把当前页面数据放入本地缓存（", "wx.setStorage（wx.setStorageSync），上一个页面再从缓存中取出（wx.getStorage（wx.getStorageSync））同时退出登录时要清除缓存（wx.clearStorage（wx.clearStorageSync））。方法二在当前页设置上一页的data,例如var", "pages", "=", "getCurrentPages();", "//", "获取页面栈var", "currPage", "=", "pages[pages.length", "-", "1];", "//", "当前页面", "var", "prevPage", "=", "pages[pages.length", "-", "2];", "//", "上一个页面", "prevPage.setData({", "mydata:", "{a:1,", "b:2}", "//", "假数据", "})当然这个“mydata”必须是上一页有的数据才行返回上一页的数据为：wx.navigateBack({", "delta:", "1", "})2、直接调用方法名来更新数据", "页面APage({", "data:", "{", "name:", "''", "},", "...", ",", "//更新name", "changeData:", "function(name){", "this.setData({", "name:", "name", "})", "}})页面B,假设有一个文本框用于输入姓名,点击返回按钮后更新页面A的namePage({", "//此方法用于文本框输入回调", "inputTyping:", "function", "(e)", "{", "//获取页面栈", "var", "pages", "=", "getCurrentPages();", "if(pages.length", ">", "1){", "//上一个页面实例对象", "var", "prePage", "=", "pages[pages.length", "-", "2];", "//关键在这里", "prePage.changeData(e.detail.value)", "}", "}})这样就可以实现数据传递给上一个页面，要注意页面A必须使用wx.navigateTo跳转到页面B，不能使用wx.redirectTo，这样会关闭上一个页面，导致页面B无法获取上一页Page实例。方法三", "在app.js中设置全局变量，当前页赋值，上一页取之方法为globalData:", "{", "userInfo:", "null,", "}注意：方法一，方法三，都需要重新刷新页面数据所走方法为：/**", "*", "生命周期函数--监听页面显示", "*/", "onShow:", "function", "()", "{", "},"]}
{"author": "Rolan", "title": "小程序开发心得 ", "content": ["今天是来杭州的第三个月后的十几天，正是的现在这份工作转正的日子。几天前转正面谈时", "CTO", "对于前几个月的工作给予了肯定，同时也提了几点建议。这也是这篇文章存在原因之一。要养成一些好的习惯、好的方法、并学会分享。这些好的习惯以后会跟着你走。来杭州三个月，也习惯了这里的生活。在新的公司做了两三个小项目，也研究了几个以前没有仔细研究的技术。小有收获。最近一周一直在忙两个项目，一是智能柜，二是景区。以下是我最近开发的一些心得和技巧：在开发微信小程序时，我们可以将小程序中常用的基本配置统一抽离出来放在一个config.js中如下：const", "SERVER_URL", "=", "'http://www.xxx.com/api';", "const", "TEST_SERVER_URL", "=", "'http://test.xxx.com/api';", "const", "CDN_URL", "=", "'http://cdn,xxx.com';", "const", "TEST_CDN_URL", "=", "'http://tcdn.xxx.com';", "export", "CONFIG_PRODUCT", "=", "{", "SERVER_URL,", "CDN_URL,", "DEBUG_FLAG:false,", "TEST_FLAG:false,", "}", "export", "CONFIG_TEST", "=", "{", "SERVER_URL:TEST_SERVER_URL,", "CDN_URL:TEST_CDN_URL,", "DEBUG_FLAG:true,", "TEST_FLAG:false,", "}然后按照开发需求引入这些配置信息（如", "控制console.log），在后期方便配置的统一管理和维护。对网络请求（wx.request）进行二次封装如下例：import", "{", "CONFIG", "}", "from", "'./config';", "import", "MD5", "from", "'./md5'/**", "*", "定制功能的网络请求方法", "*", "@param", "options", "object", "*", "@property", "url", "string", "请求的资源地址，在请求时会自动添加服务器地址。", "*", "@property", "data", "object", "请求所携带的参数", "*", "@property", "header", "object", "请求头", "*", "@property", "success", "function", "请求成功的回调", "*", "@property", "fail", "function", "请求失败的回调", "*", "@property", "complete", "function", "请求完成的回调", "*", "*", "功能简介：", "*", "传入与", "wx.request", "相同的参数，方法内部会对几个重要部分进行功能根据项目需求强化，如在", "header", "*", "中添加验证字段，对", "POST", "方法时将", "header", "的", "content-type", "改为对应参数。对特定的", "状态码（400）", "*", "，进行处理。", "*", "*/", "export", "default", "(options)", "=>", "{", "const", "{", "APP_CONFIG:", "{", "SERVER_URL,", "DEBUG_FLAG,SPEACAL_SERVER_URL", "}", "}", "=", "CONFIG;", "if", "(DEBUG_FLAG)", "{", "console.group('网络请求');", "console.log(options);", "}", "if", "(!options.anotherFlag)", "{", "wx.showLoading({", "title:", "'正在加载'", "})", "}", "if", "(options.anotherFlag)", "{", "let", "String1", "=", "''", "const", "{", "data:{query,mainData}", "}", "=", "options", "query.time", "=", "Math.ceil(Date.now()", "/", "1000);", "const", "dataKeyArray", "=", "Object.keys(query).sort();", "dataKeyArray.forEach((e,", "i)", "=>", "{", "if", "(i", "===", "0)", "{", "String1", "+=", "`${e}=${query[e]}`;", "}", "else", "{", "String1", "+=", "`&${e}=${query[e]}`;", "}", "})", "const", "String2", "=", "`${String1}&secret=yoursalt`;", "const", "token", "=", "MD5(String2);", "options.url", "=", "`${SPEACAL_SERVER_URL}token=${token}`;", "options.header", "=", "modifyHeader(options.header);", "options.header['Content-Type']", "=", "'application/json';", "options.method", "=", "'POST';", "options.data", "=", "mainData;", "}", "else", "{", "options.url", "=", "`${SERVER_URL}${(options.url)", "?", "'/'", "+", "options.url", ":", "''}`;", "options.header", "=", "modifyHeader(options.header);", "options.method", "=", "'POST';", "}", "if", "(typeof", "options", "===", "'object')", "{", "const", "success", "=", "options.success;", "const", "fail", "=", "options.fail;", "const", "complete", "=", "options.complete;", "options.success", "=", "success", "?", "res", "=>", "{", "if", "(DEBUG_FLAG)", "{", "console.log(res);", "console.groupEnd();", "}", "if", "(res.flag", "!==", "0", "&&", "!options.anotherFlag)", "{", "fail", "?", "fail(res)", ":", "'';", "}", "else", "{", "success(res);", "}", "}", ":", "null;", "options.fail", "=", "fail", "?", "res", "=>", "{", "if", "(DEBUG_FLAG)", "{", "console.log(res);", "console.groupEnd();", "}", "fail(res);", "}", ":", "null;", "options.complete", "=", "complete", "?", "res", "=>", "{", "if", "(DEBUG_FLAG)", "{", "console.groupEnd();", "}", "if", "(!options.anotherFlag)", "{", "wx.hideLoading();", "}", "complete(res);", "}", ":", "()", "=>", "{", "if(!options.anotherFlag){", "wx.hideLoading();", "}", "};", "}", "wx.request(options);", "}", "const", "modifyHeader", "=", "header", "=>", "{", "const", "token", "=", "wx.getStorageSync('token');", "if", "(token)", "{", "return", "{", "...header,", "token:", "`${token}`", "};", "}", "else", "{", "return", "(header)", "?", "header", ":", "{};", "}", "};当然也可以根据个人的开发习惯进行", "promise", "封装。这样封装的好处也显而易见，方便对所有的", "request", "进行监控，通用逻辑的修改，方便调试和开发。在写些小程序的条件动画时，也可以十分方便如下：//", "page.wxss", ".css-a{", "transform:translate3d(-100%,0,0);", "//", "将", "css-a", "元素上移全部高度", "transition:all", ".5s;", "}", ".css-a.show{", "transform:translage3d(0,0,0);", "//", "将", "css-a", "元素动画回原位", "}", "//", "page.wxml", "<view", "class='css-a", "{{showFlag", "?", "\"show\":\"\"}}'>动画DEMO</view>", "//", "page.js", "//", "触发的动画事件", "onTrigger(){", "this.setData({showFlag:true});", "}通过绑定点击、触摸事件，就能够实现很多简单的动画，提升人机交互的乐趣。"]}
{"author": "Rolan", "title": "没朋友(mpvue)，点个外卖，一个人也要好好吃饭 ", "content": ["每次写文章时，总会感慨万千。面对成功，我们总是抱以较高的期望，总想急不可耐就能得到胜利的果实。可每一次成功不可能轻而易举的就来到我们的面前。几乎每一次都需要我们付出极大的耐心和勤奋，甚至于近乎偏执狂般的傻傻坚持。自打小程序推出以来，我便开始转入这个市场。并不是因为他的热度而是一种学习兴趣吧，总想着去探索下新知识。也正是有了这种动力，才能让我一直坚持下来。距我上一篇文章《滴滴一夏，小程序专车来了》发表至今，已有半月之久。之间结识了好多好朋友。他们乐观开朗，诙谐。以自己最朴实的热忱对待他人。他们为我的征联不吝惜笔墨添彩，给我鼓励和修正。同时也感谢黄轶老师给我的面试机会还有慕课上的精彩课程。回归正题，今天给大家带来的是美团外卖微信小程序，基于mpvue开发。因为mpvue推出至今也才短短3个月，所有我会详细的讲解每一个细节，希望帮到在mpvue上步履艰难的你。前言学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会更加深刻。因此建议还是一定要去实践一波。项目使用的技术栈数据请求:", "flyio.js-", "同时支持浏览器、小程序、Node、Weex的基于Promise的跨平台http请求库。可以让您在多个端上尽可能大限度的实现代码复用css预编译器:", "stylus-基于Node.js的CSS的预处理框架数据来源:EasyMock-为测试提供模拟数据整体框架:", "mpvue地图:腾讯地图api下载启动步骤1、git", "clone", "https://github.com/WsmDyj/mpvue.git2、安装启动#", "install", "dependencies", "npm", "install", "#", "serve", "with", "hot", "reload", "at", "localhost:8080", "npm", "run", "dev", "#", "build", "for", "production", "with", "minification", "npm", "run", "build", "#", "build", "for", "production", "and", "view", "the", "bundle", "analyzer", "report", "npm", "run", "build", "--report3、小程序开发工具指向下面的dist目录效果图即使在优美的语言描述，还是也抵不过图片来的实际。一起欣赏下美团外卖吧！mpvue与小程序擦出的火花(采坑之旅)在写美团外卖小程序时，我跟大家一样步履蹒跚。总会遇到各种各样的问题以及徘徊在vue写法和mpvue写法中间不能自拔。mpvue刚出不久，有效的资源真的甚少，没有一套基本项目流程的介绍。所以我便萌发了这篇文章，通过这个完整的项目去构思整套mpvue开发。很多问题可能不能一一列举，但我会把最常见最常用的地方尽我所能的去阐述。乐于分享，帮助社区。一、mpvue中数据请求的封装写项目最重要的便是数据，有了数据整个页面就活起来了，数据的浇灌便需要http的请求。微信小法度榜样的就javascript运行情况和浏览器不合，页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的情况，所以不克不及裹足本中应用window，也无法裹足本中操作组件，JsCore中也没有XmlhttpRequest对象，所以jquery", "、zepto、axios这些在小法度榜样中都不克不及用，而此时，fly便担任了这一重任。1、安装flyio.jsnpm", "install", "flyio2、在util创建一个fly.js用于封装import", "Vue", "from", "'vue'", "var", "Fly=require(\"flyio/dist/npm/wx.js\")", "//wx.js为flyio的微信小程序入口文件", "var", "fly=new", "Fly();", "//创建fly实例", "//添加拦截器", "fly.interceptors.request.use((config,promise)=>{", "config.headers[\"X-Tag\"]=\"flyio\";", "//给所有请求添加自定义header", "return", "config;", "})", "//配置请求基地址", "fly.config.baseURL=\"https://www.easy-mock.com/mock/5aded45053796b38dd26e970/\"", "Vue.prototype.$http=fly", "//将fly挂载在vue上供全局使用", "export", "default", "fly3、在根目录的main.js下封装一个getList方法.用到请求数据的页面直接调用这个方法即可。提高代码复用率Vue.prototype.getList", "=", "function", "()", "{", "wx.showLoading({", "title:", "'加载中',", "})", "this.$http.get('sell#!method=get').then((res)=>{", "this.restaurant", "=", "res.data.data.restaurant;", "//商家数据", "this.goods", "=", "res.data.data.goods;", "//商品数据", "this.seller", "=", "res.data.data.seller;", "//商家详细数据", "this.ratings=", "res.data.data.ratings", "//评论数据", "wx.hideLoading();", "}).catch((e)=>{", "console.log(e)", "})", "}封装好了数据的请求，我们的项目就实现了一大半了。接下来就是如何利用这些数据来填充我们的页面完成交互。二、mpvue实用功能的详解接下来我将会一一介绍在mpvue中如何实现定位，位置搜索，上拉加载下拉刷新，物品之间的二级联动。让我们打起精神，一起focus下面的知识点。mpvue定位及位置搜索mpvue中定位及位置搜索跟小程序类似，大家可以先看看我上篇文章，那里又详细的地址解析，逆地址解析，关键词搜索等。官方拷贝下来的js放在utils下,这里要注意的是一定要将他的输出更改为export", "default", "QQMapWX;这样才可以在页面中使用，这里配合微信小程序提供的", "wx.getLocation()和", "wx.chooseLocation()API使用。", "import", "QQMapWX", "from", "\"../../utils/map\";", "//导入刚引入的js", "var", "qqmapsdk;", "qqmapsdk", "=", "new", "QQMapWX({", "key:'DHNBZ-2ZLKK-T7IJJ-AXSQW-WX5L6-A6FJZ'", "});mpvue上拉加载下拉刷新通过onPullDownRefresh和onReachBottom方法实现mpvue小程序下拉加载和上拉刷新//", "局部开启下拉刷新,就在文件下的main.js", "export", "default", "{", "config:", "{", "\"enablePullDownRefresh\":", "true,", "}", "}", "onReachBottom()", "{", "let", "nextPage", "=", "this.page", "+1;", "//定义每一页page，下来刷新新的一页+1", "this.page", "=", "nextPage", "//更新page", "this.$http.get('sell#!method=get').then((res)=>{", "this.restaurant", "=[...res.data.data.restaurant,...this.restaurant]//请求的新数据，解构出来渲染页面", "}).catch((e)=>{", "console.log(e)", "})", "},", "onPullDownRefreash(){", "this.isShow", "=", "!this.isShow", "}mpvue中实现二级联动实现该功能的思路：1", "左到右:通过点击左侧滑栏的某一项，获取到该元素携带的", "id", "，然后动态传给右侧滑栏的", "scroll-into-view", "，从而实现右侧滑栏对应的该元素运动置顶。2", "右到左:通过计算整个右侧滑栏滚动上去的高度", "与右侧滑栏中每一个分类距顶部的距离做比对，获取到该滚动置顶的分类的", "index", "。然后用获取到的", "index", "乘以左侧滑栏中某一项的高度，动态赋值给左侧滑栏内的", "scrollTop", "，控制左侧滑栏的联动。注意这几点：(1)", "小程序", "wxss", "中使用", "rpx，而", "js", "中", "scrollTop", "获取到的值是", "px，所以存在rpx", "转", "px", "的问题。以", "iPhone6", "为基准，转换公式：//", "percent", "为当前设备1rpx对应的px值", "var", "percent", "=", "res.windowWidth", "/", "750;(2)", "微信自带scroll-view", "UI组件，通过", "bindscroll=\"scroll\"", "绑定滚动事件；通过", "scroll-top=\"{{scrollTop}}\"", "动态控制", "左侧滑栏的被动滚动。代码就不一一贴出来,项目中有详细的注释。点这里查看三、mpvue组件分析，组件通信做完一个项目并不难，但做好一个项目却要经过无数次的思考。其中之一就是看文档，所谓书读百变，其义自现。的确，当你一遍又一遍的看文档后你会发现你写起来非常的顺手，用到即来。没事可以点击vue文档多看看。组件分析什么是组件分析？对mpvue来讲，组件是构成项目的基本单元。只要划分好了组件，项目写起来那是非常的快的。为了方便理解，这里定义两类组件：页面组件，功能组件。页面组件就是当前你看见的这个网页地址的完整显示，他将包含几个功能组件。美团外卖小程序功能组件很多，大致的列几个:评分组件，需要的props的值为：星星的大小，商家的评分购物车组件：", "需要的props：selectFoods，deliveryPrice，", "minPrice等公告组件：每个项目难免发布一些公告或者弹窗，把它抽出来当一个组件间距split组件：", "组件可以很大很多功能，也可能很少，只要在项目中经常用的就可以抽出来当一个组件。swiper组件：", "轮播图作为一个组件，可以减少我们一个页面成堆的代码，把它抽出来当一个组件，日后也更易维护。组件通信一、", "组件间可以通过props传递数据,这里以选物品", "->", "选择组件", "->", "购物车", "->", "订单详情一条线来详细描述组件间数据怎么传递的。1", "选择组件props:", "{", "food:", "{", "//接受一个food，代表选择的是哪个商品", "type:", "Object,", "}", "},", "addCart(event)", "{", "if(!this.food.count){", "this.$set(this.food,", "'count',", "1)", "//点击事件传递给父组件", "this.food.count", "=", "1;", "}else{", "this.food.count++", "//", "商品++", "}", "},2", "购物车通过props接受一个selectFood，这里把它放入小程序的本地中提供给订单页面", "try", "{", "wx.setStorageSync('selectFoods',", "this.selectFoods)", "}", "catch", "(e)", "{", "console.log(e)", "}3", "订单页面", "try", "{", "var", "value", "=", "wx.getStorageSync('selectFoods')", "//拿到存储的数据，使用同步的概念", "if", "(value)", "{", "this.isShow", "=", "false;", "//", "判断订单也是否有数据，没有数据则用v-show引用一个组件去渲染页面", "this.orderList=value;", "//数据渲染页面", "}", "}", "catch", "(e)", "{", "console.log(e)", "};二、父子组件间方法的调用可以通过$on,", "$emitvar", "Event", "=", "new", "Vue();//相当于又new了一个vue实例，Event中含有vue的全部方法", "Event.$emit('msg',this.msg);//发送数据，第一个参数是发送数据的名称，接收时还用这个名字接收，第二个参数是这个数据现在的位置", "Event.$on('msg',function(msg){//接收数据，第一个参数是数据的名字，与发送时的名字对应，第二个参数是一个方法，", "要对数据的操})---寄语很多东西想聊出来，比如mpvue小程序中引用图片一定要放在static文件目录下，组件的属性计算computed。以及vuex在全局数据的使用等等。但是一个人的精力真的有限，本人也是一个大三的学生，最近忙于找实习公司，同时也在研究下vue底层源码分析。所有可能到这里差不多就结束了。对其中一些内容比较喜欢的可以去我的github上下载，慢慢研究。这里附上我项目的地址mpvue美团外卖小程序。也希望有志同道和的可以加入一起讨论，如果有什么不懂得可以直接评论我，或者发我qq：972774037我也会第一时间帮你解答。也希望通过这个为我找实习增添色彩吧，下期将推出更加精彩的vue项目,持续关注我吧！！！"]}
{"author": "Rolan", "title": "【小程序】微信小程序绑定企业微信后怎样获取到用户信息 ", "content": ["一、获取access_token1、https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&corpsecret=SECRECTCorpid和secrect是唯一的", "access_token:有效期2小时二、获取code小程序调用wx.login获取临时登录凭证code，并回传到开发者服务器", "三、获取用户idhttps://qyapi.weixin.qq.com/cgi-bin/miniprogram/jscode2session?access_token=ACCESS_TOKEN&js_code=CODE&grant_type=authorization_code返回结果"]}
{"author": "Rolan", "title": "浅析微信小程序 App() 和 Page() 函数的内部实现 ", "content": ["在小程序开发中，", "App(...)", "和", "Page(...)", "是我们最熟悉也是最常用的两个函数，今天我们就来分析一下它们的内部实现，以及调用时的初始化流程。前一段时间，我们公众号转载了有赞技术团队的", "《从源码看微信小程序启动过程》", "，这篇文章记录了小程序框架的基本代码结构，启动流程，以及程序实例化过程，非常值得反复阅读。你也可以把本文理解为是这篇文章的读后感或总结。概览在微信开发者工具中，编译运行你的小程序项目，然后打开控制台，输入", "document", "并回车，就可以看到小程序运行时，WebView", "加载的完整的", "page-frame.html", "，如下图：通过分析这个", "HTML", "文件，我们可以得到小程序的启动执行流程大致如下：此图来自上述文章，我们这里不再重复赘述这些流程，下面我们来看一下其中的", "App()", "和", "Page()", "的细节。这两个函数在小程序框架", "WAService.js", "中定义，并在", "app.js", "和每个页面的", "page.js", "中进行调用实例化。在微信开发者工具的控制台中执行", "openVendor()", "方法，可以打开小程序框架所在目录，如下：/Users/用户名/Library/Application", "Support/微信web开发者工具/WeappVendor/基础库版本号目录", "本文以", "1.9.94", "基础库为例进行分析。", "WAService.js", "文件的结构如下：;(function(global)", "{", "//", "WeixinJSBridge", "的定义和加载", "//", "NativeBuffer", "的定义和加载", "//", "wxConsole", "的定义和加载", "//", "WeixinWorker", "的定义和加载", "//", "Reporter", "的定义和加载", "//", "__appServiceSDK__", "的定义和加载", "wx", "=", "__appServiceSDK__.wx,", "//", "exparser", "的定义和加载", "//", "__virtualDOM__", "的定义和加载", "//", "__appServiceEngine__", "的定义和加载", "Page", "=", "__appServiceEngine__.Page,", "Component", "=", "__appServiceEngine__.Component,", "Behavior", "=", "__appServiceEngine__.Behavior,", "__webview_engine_version__", "=", ".02,", "App", "=", "__appServiceEngine__.App,", "getApp", "=", "__appServiceEngine__.getApp,", "getCurrentPages", "=", "__appServiceEngine__.getCurrentPages,", "__createPluginGlobal", "=", "__appServiceEngine__.__createPluginGlobal,", "//", "__wxModule__", "的定义和加载", "definePlugin", "=", "__wxModule__.definePlugin,", "requirePlugin", "=", "__wxModule__.requirePlugin;", "//", "define", "方法的定义", "//", "require", "方法的定义", "global.App", "=", "App;", "global.Page", "=", "Page;", "global.Component", "=", "Component;", "global.Behavior", "=", "Behavior;", "global.__webview_engine_version__", "=", "0.02;", "global.getApp", "=", "getApp;", "global.getCurrentPages", "=", "getCurrentPages;", "global.wx", "=", "wx;", "global.definePlugin", "=", "__wxModule__.definePlugin;", "global.requirePlugin", "=", "__wxModule__.requirePlugin;", "})(this);", "我们发现，", "WAService.js", "中定义了", "WeixinJSBridge", "和", "wx", "这两个基础", "API", "集合，同时也包含的其他一些框架核心，如", "exparser", "，", "__virtualDOM__", "，", "__appServiceEngine__", "等。其中", "__appServiceEngine__", "提供了框架最基本的对外接口，如", "App，Page，Component，Behavior", "等方法；", "exparser", "提供了框架底层的能力，如实例化组件，数据变化监听，View", "层与逻辑层的交互等；", "__virtualDOM__", "则起着连接", "__appServiceEngine__", "和", "exparser", "的作用，如对开发者传入", "Page", "方法的对象进行格式化再传入", "exparser", "的对应方法处理。（此段分析摘自上述文章）由上可知，本文要分析的全局函数", "App()", "和", "Page()", "是对", "WAService.js", "中定义的", "__appServiceEngine__", "对象同名方法的引用。下面我们简要分析一下它们的内部实现和初始化流程。App()", "和", "getApp()", "函数根据微信小程序", "开发文档", "，", "App()", "函数用来注册一个小程序，接收一个", "object", "对象参数，其指定小程序的生命周期函数等。我们从微信开发者工具的函数提示可以知道，", "App()", "函数的声明如下：function", "App(options:", "_AppOptions):", "void", "对于入参", "object", "对象（_AppOptions）的属性说明如下：此外，全局的", "getApp()", "函数可以用来获取到小程序实例，它的声明如下：function", "getApp():", "object", "内部实现在", "__appServiceEngine__", "对象中，对", "App", "和", "getApp", "属性的定义如下：//", "其中的", "t", "就是", "__appServiceEngine__", "对象", "var", "i", "=", "n(17);", "Object.defineProperty(t,", "\"App\",", "{", "enumerable:", "!0,", "get:", "function()", "{", "return", "i.appHolder", "}", "}),", "Object.defineProperty(t,", "\"getApp\",", "{", "enumerable:", "!0,", "get:", "function()", "{", "return", "i.getApp", "}", "}),", "而这两个属性对应的实现分别为", "appHolder()", "和", "getApp()", "方法，定义如下：l", "=", "void", "0,", "t.appHolder", "=", "(0,", "i.surroundByTryCatch)(function(e)", "{", "l", "=", "new", "y(e)", "},", "\"create", "app", "instance\"),", "t.getApp", "=", "function()", "{", "return", "l", "},", "由上可知，在", "appHolder()", "方法中，把外部传入的", "object", "对象传给", "y(...)", "方法进行初始化一个小程序实例对象，并把结果赋给变量", "l", "缓存起来，而在", "getApp()", "方法中则直接", "return", "l，返回当前小程序对象。App", "实例初始化流程在上述", "page-frame.html", "中，我们知道，在", "app.js", "被加载完后，小程序框架会立即执行", "require('app.js')", "进行注册小程序实例，即对", "App()", "函数进行调用（开发者已经在", "app.js", "中定义好了入参对象），如下：<script", "src=\"./app.js\"></script>", "<script>require(\"app.js\")</script>", "在", "App()", "函数中，最终会调用", "y(...)", "方法进行初始化，其中", "y(...)", "的定义比较长，我们这里不再贴出代码，详情请自行查阅", "WAService.js", "，它的处理流程如下：声明", "App.getCurrentPage", "方法将被废弃，请使用", "getCurrentPages()", "全局方法；绑定生命周期函数，即把外部入参对象定义的属性绑定到小程序实例对象中，包括", "onLaunch，", "onShow", "，", "onHide", "，", "onUnlaunch", "和", "onPageNotFound", "；绑定开发者自定义的其他属性（包括数据和方法），并校验属性名是否为", "“getCurrentPage”，如果是则警告；根据外部是否有定义", "onError", "属性判断是否注册错误上报；检查启动参数（取自__wxConfig.appLaunchInfo）并依次调用", "onLaunch", "和", "onShow", "方法；注册前后台切换回调", "onShow", "和", "onHide", "；注册找不到页面的回调", "onPageNotFound", "；返回实例给", "App()", "函数进行缓存。Page()", "和", "getCurrentPages()", "函数根据", "文档", "，", "Page()", "函数用来注册一个页面，接收一个", "object", "对象参数，其指定页面的初始数据、生命周期函数、事件处理函数等。", "Page()", "函数的声明如下：function", "Page(page:", "PageOptions):", "void", "对于入参", "object", "对象（PageOptions）的属性说明如下：此外，", "getCurrentPages()", "函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。它的声明如下：function", "getCurrentPages():", "object[]", "内部实现同样地，在", "__appServiceEngine__", "对象中，对", "Page", "和", "getCurrentPages", "属性的定义如下：var", "r", "=", "n(2);", "Object.defineProperty(t,", "\"Page\",", "{", "enumerable:", "!0,", "get:", "function()", "{", "return", "r.pageHolder", "}", "}),", "Object.defineProperty(t,", "\"getCurrentPages\",", "{", "enumerable:", "!0,", "get:", "function()", "{", "return", "r.getCurrentPages", "}", "}),", "而这两个属性对应的实现分别为", "pageHolder()", "和", "getCurrentPages()", "方法，定义如下：var", "k", "=", "void", "0,", "//", "保存当前显示的页面（栈顶）", "x", "=", "[],", "//", "保存已加载过的页面历史栈数组", "//", "其中的", "t", "就是", "__appServiceEngine__", "对象", "t.getCurrentPage", "=", "function()", "{", "return", "k", "},", "t.getCurrentPages", "=", "function()", "{", "var", "e", "=", "[];", "return", "x.forEach(function(t)", "{", "e.push(t.page)", "}),", "e", "},", "M", "=", "{},", "//", "缓存所有已经注册的页面", "t.pageHolder", "=", "function(e)", "{", "if", "(!__wxRouteBegin)", "throw", "(0,", "f.error)(\"Page", "注册错误\",", "\"Please", "do", "not", "register", "multiple", "Pages", "in", "\"", "+", "__wxRoute", "+", "\".js\"),", "new", "a.AppServiceEngineKnownError(\"Please", "do", "not", "register", "multiple", "Pages", "in", "\"", "+", "__wxRoute", "+", "\".js\");", "__wxRouteBegin", "=", "!1;", "var", "t", "=", "__wxRoute;", "if", "(!A(t))", "throw", "(0,", "f.error)(\"Page", "注册错误\",", "__wxRoute", "+", "\"", "has", "not", "been", "declared", "in", "app.json.\"),", "new", "a.AppServiceEngineKnownError(__wxRoute", "+", "\"", "has", "not", "been", "declared", "in", "app.json.\");", "var", "n", "=", "\"undefined\"", "!=", "typeof", "__wxAppCode__", "?", "__wxAppCode__[t", "+", "\".json\"]", "||", "{}:", "{};", "if", "(\"Object\"", "!==", "(0,", "f.getDataType)(e))", "throw", "(0,", "f.error)(\"Page", "注册错误\",", "\"Options", "is", "not", "object:", "\"", "+", "JSON.stringify(e)", "+", "\"", "in", "\"", "+", "__wxRoute", "+", "\".js\"),", "new", "a.AppServiceEngineKnownError(\"Options", "is", "not", "object:", "\"", "+", "JSON.stringify(e)", "+", "\"", "in", "\"", "+", "__wxRoute", "+", "\".js\");", "(0,", "f.info)(\"Register", "Page:", "\"", "+", "t),", "void", "0", "!==", "n.usingComponents", "?", "(__virtualDOM__.Page(e),", "M[t]", "=", "exparser.Component._list[t])", ":", "M[t]", "=", "e", "},", "分析上述代码，我们可以总结", "pageHolder", "方法的处理流程如下：小程序在每加载一个页面前，会先设置", "__wxRouteBegin", "=", "true", "，用于标记防重；判断", "__wxRouteBegin", "是否为", "false", "，如果是，则抛出多次调用", "Page", "注册错误；设置", "__wxRouteBegin", "为", "false", "，避免被后续代码被重复执行；调用", "A(...)", "方法检查当前页面是否在", "app.json", "中定义，如果没有，则抛出错误；检查外部入参（PageOptions）是否为", "Object", "对象，如果不是，则抛出错误；判断当前页面是否使用了自定义组件（对于使用了自定义组件的", "Page", "对象会采用不同的配置），然后缓存当前", "Page", "的配置到", "M", "对象中。此外，我们可以发现，与", "App()", "不同的是，", "外部通过", "Page()", "函数传入的（生命周期）代码并不会在这里被执行，而是等待页面", "Ready", "并进入页面进行实例化后才执行。页面初始化流程同样地，根据", "page-frame.html", "的加载顺序，在", "app.js", "被加载并执行后，小程序之后会先依次按顺序加载所有的自定义组件代码（如果有）并自动注册。自定义组件（Component）在小程序开发中具有重要地位，它可以丰富小程序的基础功能，拥有的能力比", "赞赏", "邀请", "鲜花", "鸡蛋", "function", "errorhandle_clickhandle(message,", "values)", "{", "if(values['id'])", "{", "showCreditPrompt();", "show_click(values['idtype'],", "values['id'],", "values['clickid']);", "}", "}", "分享至", ":", "QQ空间", "window._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new", "Date()/36e5)];", "收藏", "【小程序】微信小程序绑定企业微信后怎样获取到用户信息", "【腾讯游戏人生】微信小程序开发总结", "原作者:", "Zubin's", "来自:", "Zubin's", "Blog", "/*700*200", "创建于", "2017/12/12*/", "var", "cpro_id", "=", "\"u3158955\";", "相关阅读", "•", "程序员开发实战系列《三》App()和Page()", "•", "小程序开发实用技巧——扩展", "Page", "页面对象", "1", "条回复", "Rolan", "2018-6-27", "09:44", "PS：页面小bug，本文余下内容在这里查看，造成不便，敬请谅解。", "页面初始化流程", "同样地，根据", "page-frame.html", "的加载顺序，在", "app.js", "被加载并执行后，小程序之后会先依次按顺序加载所有的自定义组件代码（如果有）并自动注册。自定义组件（Component）在小程序开发中具有重要地位，它可以丰富小程序的基础功能，拥有的能力比", "Page", "更强大，因此实现也更加复杂，篇幅有限，我们后续再单独写文章进行分析。", "在加载执行完自定义组件的代码后，小程序紧接着会依次按顺序加载每个页面的代码，并执行", "require(...)", "进行页面注册，如下：", "<script>__wxRoute", "=", "&quot;pages/index/index&quot;;__wxRouteBegin", "=", "true</script>", "<script>__wxAppCurrentFile__", "=", "&quot;pages/index/index.js&quot;</script>", "<script", "src=&quot;./pages/index/index.js&quot;></script>", "<script>require(&quot;pages/index/index.js&quot;)</script>", "<script>", "if(__wxRouteBegin)", "{", "console.group(&quot;Tue", "Jun", "26", "2018", "17:53:09", "GMT+0800", "(CST)", "page", "编译错误&quot;)", "console.error(&quot;pages/index/index.js", "出现脚本错误或者未正确调用", "Page()&quot;)", "console.groupEnd()", "}", "</script>", "<!--", "加载注册下一个", "Page", "-->", "设置", "__wxRoute", "为当前", "Page", "的路径，设置", "__wxRouteBegin", "为", "true；", "设置", "__wxAppCurrentFile__", "为当前加载的文件路径；", "加载页面代码并执行进行注册页面（参考上述", "pageHolder", "的处理流程）；", "判断", "__wxRouteBegin", "是否为", "false", "，来判断该页面是否被成功注册（因为在", "pageHolder", "方法中，成功执行是，会把", "__wxRouteBegin", "置为", "false", "）；", "依次加载其他", "Page；", "等待页面", "Ready", "和", "Page", "实例化，page", "Load", "由", "wx.onAppRoute", "事件触发。", "在", "page-frame.html", "中，当", "head", "中的所有", "JS", "代码都执行完毕后，会在", "body", "中触发", "DOCUMENT_READY", "事件，如下：", "<body>", "<script>", "if", "(document.readyState", "==", "'complete')", "{", "window.__global.alert('DOCUMENT_READY')", "}", "else", "{", "var", "fn", "=", "function(event)", "{", "window.__global.alert('DOCUMENT_READY')", "window.removeEventListener(&quot;load&quot;,", "fn)", "}", "window.addEventListener('load',", "fn)", "}", "</script>", "</body>", "在小程序框架", "WAService.js", "中，最终", "DOCUMENT_READY", "会转化为", "wx.onAppRoute", "事件（逻辑待验证），最终在", "wx.onAppRoute", "事件中进行页面的实例化或者页面切换。", "PS：关于一个小程序页面的完整初始化加载流程，我们将在下一篇文章中详解。", "回复", "updateseccode('cSWBoY7M',", "'<sec>", "<span", "id=\"sec<hash>\"", "onclick=\"showMenu(this.id);\"><sec></span><div", "id=\"sec<hash>_menu\"", "class=\"p_pop", "p_opt\"", "style=\"display:none\"><sec></div>',", "'portal::view');", "发表回复", "jQuery(function(){", "jQuery(\"#tedt", ".pt\").focus(function(){", "jQuery(this).addClass(\"bgchange\");", "}).blur(function(){", "jQuery(this).removeClass(\"bgchange\");", "});", "});", "推荐教程", "近两万字小程序攻略发布了2018-09-06轻松生成小程序分享海报2018-08-29微信小程序实现类3D轮播图2018-08-30小程序", "|", "注释级微信小程序demo，助你快速2018-08-29微信小程序可实时改变转速的css3旋转动画2018-08-30微信小程序有旋转动画效果的音乐组件2018-08-22使用mpvue开发github小程序总结2018-08-22如何在小程序wxml文件中编写js代码2018-08-22富文本解析-微信小程序", "rich-text", "组件2018-08-30", "最新Demo", "我想制作一个计算类小程序，求教2018-09-13各位大佬有心理咨询这种Demo吗？2018-09-07伯乐招聘Demo2018-08-24简单房贷计算2018-08-23小程序Demo--两天撸一个天气应用小程序2018-08-20小程序Demo：掘金小程序2018-08-20开源小程序实战教程2018-08-20点餐云小程序开发2018-08-19wordpress开源微信小程序2018-08-13", "jQuery(function()", "{", "jQuery(\"span\").click(function()", "{", "var", "thisEle", "=", "jQuery(\"#article_content\").css(\"font-size\");", "var", "textFontSize", "=", "parseFloat(thisEle,", "10);", "var", "unit", "=", "thisEle.slice(", "-", "2);", "var", "cName", "=", "jQuery(this).attr(\"class\");", "if", "(cName", "==", "\"bigger\")", "{", "if", "(textFontSize", "<=", "22)", "{", "textFontSize", "+=", "2;", "}", "}", "else", "if", "(cName", "==", "\"smaller\")", "{", "if", "(textFontSize", ">=", "12)", "{", "textFontSize", "-=", "2;", "}", "}", "jQuery(\"#article_content\").css(\"font-size\",", "textFontSize", "+", "unit);", "});", "});", "Copyright", "©", "2016-2017", "微信小程序联盟", "-", "鄂ICP备14019861号-2", "var", "_hmt", "=", "_hmt", "||", "[];", "(function()", "{", "var", "hm", "=", "document.createElement(\"script\");", "hm.src", "=", "\"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";", "var", "s", "=", "document.getElementsByTagName(\"script\")[0];", "s.parentNode.insertBefore(hm,", "s);", "})();", "(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){", "(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new", "Date();a=s.createElement(o),", "m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)", "})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');", "ga('create',", "'UA-98020757-1',", "'auto');", "ga('send',", "'pageview');", "返回顶部", "jQuery.noConflict();", "jQuery(function(){", "//首先将#back-to-top隐藏", "jQuery(\"#share\").hide();", "//当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失", "jQuery(function", "()", "{", "jQuery(window).scroll(function(){", "if", "(jQuery(window).scrollTop()>100){", "jQuery(\"#share\").fadeIn();", "}", "else", "{", "jQuery(\"#share\").fadeOut();", "}", "});", "//当点击跳转链接后，回到页面顶部位置", "jQuery(\"#totop\").click(function(){", "jQuery('body,html').animate({scrollTop:0},500);", "return", "false;", "});", "});", "});", "var", "tipsinfo", "=", "'58938621|X3.2|0.6||0||0|7|1536994924|e537e09e1aa7571aecb47e649d2dcdf4|2';"]}
{"author": "Rolan", "title": "微信小程序-封装请求（GET、POST） ", "content": ["使用：先导入到util.js", "最后在页面上导入util.js（路径自改）var", "util", "=", "require('../../util.js');", "使用示例GET：util.SEND(url,'GET',res=>,res=>);使用示例POST：util.SEND(url,'POST',res=>,res=>);", "使用实例：", "源码：", "1", "function", "SEND(url,", "method,", "data,", "success,", "fail)", "{", "2", "wx.request({", "3", "url:", "url,", "4", "header:", "{", "5", "'content-type':", "'application/json',", "6", "},", "7", "method:", "method,", "8", "data:", "data,", "9", "success(res)", "{", "10", "success(res);", "11", "},", "12", "fail(res)", "{", "13", "fail(res);", "14", "}", "15", "});", "16", "}"]}
{"author": "Rolan", "title": "浅谈微信小程序用setStorage和getStorage缓存和获取数据 ", "content": ["每个微信小程序都可以有自己的本地缓存，可以通过", "wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。同一个微信用户，同一个小程序", "storage", "上限为", "10MB", "。localStorage", "以用户维度隔离，同一台设备上，A", "用户无法读取到", "B", "用户的数据。数据常用于哪里？对于数据需求较小的历史记录、购物车事件等都可以使用", "storage", "进行缓存，", "Storage", "将数据存储在本地缓存中指定的", "key", "中，如果重复会覆盖掉原来该", "key", "对应的内容", "可以参照微信小程序开发手册中的Storage如何使用异步接口进行数据缓存？将数据存储在本地缓存中指定的", "key", "中，会覆盖掉原来该", "key", "对应的内容，这是一个异步接口。OBJECT参数说明：示例代码wx.setStorage({", "key:\"key\",", "data:\"value\"", "})当", "setStorage", "之后可以去到开发者工具里面查看", "这是没有保存值的情况可以看到是没有", "key值的", "那么当我们去进行输入搜索最后再去", "storage中查看获取到了一个", "key", "为", "history", "的", "Array数组", "那么再去进行搜索再看看", "storage得到了一个数组而且没有被覆盖，那么怎么实现的呢？", "先来看看代码search.wxml", "<view", "class=\"search-top-input\">", "<input", "type=\"text\"", "placeholder=\"搜索公司/职位\"", "auto-focus=\"true\"", "value=\"{{inputsearch}}\"", "bindconfirm=\"search\"", "bindinput=\"inputSearchTap\"", "data-index=\"{{index}}\"/>", "</view>", "<view", "class=\"search-history\"", "wx:if=\"{{status}}\">", "<view", "class=\"search-history-title\">", "<text>历史搜索</text>", "<image", "src=\"../../images/delete.png\"", "bindtap=\"deleteHistory\"></image>", "</view>", "<view", "class=\"search-history-detail\"", ">", "<view", "class=\"history-detail\"", "wx:for=\"{{history}}\"", "wx:key=\"{{item}}\"", "bindtap=\"historySearch\"", "data-index=\"{{index}}\">", "<text", "class=\"detail\"", ">{{item}}</text>", "</view>", "</view>", "</view>", "search.js", "设置data", "data:", "{", "status:false,", "inputsearch:'',", "job:[],", "history:[],", "},", "首先去获取storage中的值", "onLoad:", "function", "(options)", "{", "var", "that", "=this;", "wx.getStorage({", "key:", "'history',", "success:", "function(res){", "that.setData({", "history:res.data,", "})", "if(that.data.history.length==0){", "that.setData({", "status:false", "});", "}else{", "that.setData({", "status:true", "})", "}", "},", "fail:", "function(res)", "{", "console.log(res+'aaaaa')", "}", "});", "},", "进行搜索和缓存数据到storage中", "search:function(e){", "var", "that", "=this;", "var", "sear", "=this.data.inputsearch;", "var", "jobs=this.data.job;", "var", "input", "=", "new", "RegExp(sear);", "var", "temp", "=", "[];", "if(sear", "==", "''){", "wx.showToast({", "title:", "'请输入要搜索信息',", "icon:\"none\",", "duration:", "1000", "});", "return", "false;", "}else{", "this.data.history.unshift(sear);", "wx.setStorage({", "key:", "'history',", "data:", "that.data.history,", "success:", "function(res){", "that.setData({", "history:that.data.history,", "status:true", "})", "console.log(res.data);", "},", "})", "for(let", "i", "=0;i<jobs.length;i++){", "if(input.test(jobs[i].job)", "||", "input.test(jobs[i].company)", "||", "input.test(jobs[i].address)){", "temp.push(jobs[i]);", "var", "detail=temp;", "app.globalData.details=detail;", "}", "}", "if(temp", "==''){", "wx.showToast({", "title:", "'暂无此信息',", "icon:\"none\",", "duration:", "1000", "});", "this.setData({", "inputsearch:''", "})", "}else", "if(temp){", "wx.navigateTo({", "url:'../about/about'", "})", "this.setData({", "inputsearch:''", "})", "}", "}", "},将", "storage", "中的", "key", "值设为", "hisotrywx.setStorage({", "key:", "'history',", "data:", "that.data.history,", ")}定义一个数组", "history", "空数组去获取", "storage", "中的值,首先是去查询有没有该", "key", "值，如果没有则", "fail", "，那么", "history", "依然为空数组wx.setStorage({", "key:", "'history',", "data:", "that.data.history,", "success:", "function(res){", "that.setData({", "history:that.data.history,", "status:true", "})", "},", "})返回得到", "history", "之后再去将", "inputsearch", "的值添加到", "history", "中,这里有个误区", "可能你会将输入的值inputsearch", "push到一个新的空数组，然后再将这个新数组push到history数组中，但这个方法", "显然不可行，你添加之后新数组将会存放在history数组的第一个下标的数组下，", "对于history数组也就只有两个值好了，回到我要说的，那么如何将", "inputsearch", "添加到", "history", "中呢,可以使用", "unshift", "方法或者", "push", "方法，这里应该使用", "unshift", "应该将每个新增值存放在", "history", "的第一个位置，这是其实就是一个用户体验问题了var", "that", "=this;", "var", "sear", "=this.data.inputsearch;", "this.data.history.unshift(sear);", "wx.setStorage({", "key:", "'history',", "data:", "that.data.history,", "success:", "function(res){", "that.setData({", "history:that.data.history,", "status:true", "})", "console.log(res.data);", "},", "})好了，这样就不会出现“覆盖掉”原来的", "key", "值的问题了,是不是美滋滋当然还有", "setStorageSync", "同步接口的问题详情点击这里这里是项目地址查看点击这里如果你觉得对你有所帮助那么给我的", "github", "项目一个", "Star", "吧访问点击", "这里"]}
{"author": "Rolan", "title": "scroll-view组件的bindscroll实例应用：自定义进度条 ", "content": ["我们知道scroll-view组件作为滑动控件非常好用，而有时候我们想放置一个跟随滚动位置来运动的进度条，但又不想用进度条api该怎么办呢？（当然是自己写一个呗还能怎么办[自黑冷漠脸]）嗯，没错。自己写一个就好了啊。[厚脸皮点头]请看效果图那么如何做呢？我是通过scroll-view组件的bindscroll事件来自定义的。让我们先看看文档：请小伙伴们看看，滚动时会触发bindscroll事件，触发时会生成scrollLeft、scrollTop等的数据；好，那让我们console一下看看。没滚动时：可以看到scrollLeft的值为0滚动到最右边时：scorllLeft的值变为222.6多了这就说明滚动的总长度范围是0~222.6，那么，我们可以根据滚动范围来制定一个比例，动态的设置红线进度条的水平距离。贴上代码wxml//红线进度条的wxml，动态设置其left值", "<view", "class=\"scroll-line\">", "<view", "class=\"scrollMove\"", "style=\"left:{{viewleft}}rpx\"></view>", "</view>js//滚动触发函数scrollMove", "scrollMove:", "function(e)", "{", "//获取滚动距离", "var", "left", "=", "e.detail.scrollLeft;", "//将滚动距离（位移）动态添给进度条的left", "this.setData({", "viewleft:", "left", "})", "}也是很简易的一个小方法，欢迎各位提建议噢~附：我的", "github", "地址谢谢各位小伙伴~"]}
{"author": "Rolan", "title": "微信小程序---电商家具入门篇 ", "content": ["前言今年是小程序很火的一年，所以最近在自学微信小程序，所以打算自己撸一个小程序出来，由于自己才刚刚自学不久。就做了一个相对简单的家具小程序。当然在这其中也遇到了一些问题和bug,在这就和大家分享一下，这样才能帮助更多的朋友。如有不足之处，希望大家提出宝贵的建议哈。这样才能一起成长，一起进步。简单介绍一下微信小程序众所周知，随着越来越多的app出现在了App商城，导致手机下载多了app会导致手机卡，所以这时微信小程序腾空而出。只要用户扫一扫或者搜索一下就能打开应用，减少了我们下载app的次数。开发环境：WXML(HTML),WXSS(CSS),Javascript开发工具：vscode，微信开发者工具开发流程：下载微信开发者工具之后注册一下就会有自己的AppID，微信小程序有官方的微信小程序开发文档", "开发文档接下来说说我做的小程序吧万事开头难，关键是踏出第一步。在这里我将分享一下我实现过程以及在实际过程中遇到的坑。", "首先先看看首页效果吧代码实现，主页东西也不多，主要是布局问题。", "wxss代码：.img-box", "image{", "width:", "100%;", "height:", "100%;", "}", ".img-box", "image:after{", "content:", "\"\";", "position:", "absolute;", "bottom:", "0;", "width:", "100%;", "color:", "#fff;", "padding:", "50px", "20px;", "}1：家具的轮播效果实现小程序的轮播实现是用了swiper组件，滑块视图容器里面有indicator-dots,autoplay,setinterval等属性，可以设置自动播放，时间间隔。", "插入的图片可以用wx:for来循环。wxml代码：<swiper", "class=\"section", "\"indicator-dots=\"{{true}}\"", "autoplay=\"autoplay\"", "setInterval=\"3000\"", "duration=\"500\">", "<view", "class=\"img-box\">", "<block", "wx:for=\"{{slides}}\"", "wx:key=\"id\">", "<swiper-item>", "<image", "src=\"{{item.image}}\"", "mode=\"aspectFill\"", "/>", "</swiper-item>", "</block>", "</view>", "</swiper>我这里把图片放在了js里面遍历。效果如图所示2：navigate的跳转问题在点击加入购物车以后，加入绑定事件本该跳转到另一个页面的，但是迟迟没有出现效果也没有报错，我以为我拼写或路径有问题，但我检查之后没有问题啊，后来终于发现了一个坑。", "这里要跳转的是tabBar的页面，按照默认的跳转是不允许的，查看了一下开发文档才发现了问题的所在。解决办法：把navigateTo换成switchTab就可以了", "跳转有很多种方法，具体可以查看开发文档。跳转页面的api3：商品如何加入购物车之后如何控制购买商品的数量并计算价格本来想做的是点击图片进入详情再点击加入购物车就能保存到后台的购物车里", "但是由于自学的知识有限，后端目前还没学，只能加入一个绑定事件跳转到购物车。接下来计入正题：如何控制购物车购买的数量和计算总价？先在js里面定义一个cart空的数组，我们先把这个值赋给这个空数组，之后再取这个值。之后给商品的状态默认为选择状态，点击一下，就可以把状态变为取消。话不多说，之后计算出选择商品的总价。先看这个效果吧js代码：selectList(e){", "let", "selectAllStatus", "=", "this.data.selectAllStatus;", "const", "index=e.currentTarget.dataset.index;", "let", "carts=this.data.carts;", "const", "selected=carts[index].selected;", "carts[index].selected=!selected;", "selectAllStatus", "=", "carts[index].selected;", "//", "if(", "carts[index].selected=!selected){", "//", "selectAllStatus:false;", "//", "}", "this.setData({", "carts,", "selectAllStatus,", "});", "this.getTotalPrice();", "},", "deleteList(e)", "{", "const", "index", "=", "e.currentTarget.dataset.index;", "let", "carts", "=", "this.data.carts;", "carts.splice(index,1);", "this.setData({", "carts:", "carts", "});", "if(!carts.length){", "this.setData({", "hasList:", "false", "});", "}else{", "this.getTotalPrice();", "}", "},", "addCount", "(e){", "const", "index", "=", "e.currentTarget.dataset.index;", "let", "carts", "=", "this.data.carts;", "let", "num", "=", "carts[index].num;", "num++;", "carts[index].num", "=", "num", "this.setData({", "carts", "})", "this.getTotalPrice();", "},", "minuCount(e){", "const", "index", "=", "e.currentTarget.dataset.index;", "let", "carts", "=", "this.data.carts;", "let", "num", "=", "carts[index].num;", "if(num<=1)", "return", "false;", "num--;", "carts[index].num", "=", "num", "this.setData({", "carts", "});", "this.getTotalPrice();", "},", "selectAll(e){", "let", "selectAllStatus", "=", "this.data.selectAllStatus;", "selectAllStatus", "=", "!selectAllStatus;", "let", "carts", "=this.data.carts;", "for(let", "i=0;i<carts.length;i++){", "if(", "carts[i].selected=!selectAllStatus){", "selectAllStatus:false", "}", "carts[i].selected=selectAllStatus;", "}", "this.setData({", "carts,", "selectAllStatus", "})", "this.getTotalPrice();", "},", "getTotalPrice(){", "let", "carts", "=", "this.data.carts;", "let", "total", "=", "0;", "for(let", "i", "=0;i<carts.length;i++){", "//", "total", "+=", "carts[i].num", "*carts[i].price;", "if(carts[i].selected){", "total+=", "carts[i].num", "*", "carts[i].price;", "}", "}", "this.setData({", "totalPrice:total.toFixed(2)", "})", "}4：如何获取登录微信的用户的头像和信息使用wx.getUserInfo直接获取微信头像，昵称。我们在使用小程序wx.login", "API进行登录的时候，直接使用wx.getUserInfo是不能获取更多的信息的，如微信用户的openid。", "我这里是用的第一种方法wxml代码：<view", "class=\"userinfo\">", "<button", "wx:if=\"{{!hasUserInfo", "&&", "canIUse}}\"", "open-type=\"getUserInfo\"", "bindgetuserinfo=\"getUserInfo\">", "获取头像昵称", "</button>", "<block", "wx:else>", "<image", "bindtap=\"bindViewTap\"", "class=\"userinfo-avatar\"", "src=\"{{userInfo.avatarUrl}}\"", "background-size=\"cover\"></image>", "<text", "class=\"userinfo-nickname\">{{userInfo.nickName}}</text>", "</block>", "</view>", "js代码：", "onLoad:", "function", "()", "{", "if", "(app.globalData.userInfo)", "{", "this.setData({", "userInfo:", "app.globalData.userInfo,", "hasUserInfo:", "true", "})", "}", "else", "if", "(this.data.canIUse){", "//", "由于", "getUserInfo", "是网络请求，可能会在", "Page.onLoad", "之后才返回", "//", "所以此处加入", "callback", "以防止这种情况", "app.userInfoReadyCallback", "=", "res", "=>", "{", "this.setData({", "userInfo:", "res.userInfo,", "hasUserInfo:", "true", "})", "}", "}", "else", "{", "//", "在没有", "open-type=getUserInfo", "版本的兼容处理", "wx.getUserInfo({", "success:", "res", "=>", "{", "app.globalData.userInfo", "=", "res.userInfo", "this.setData({", "userInfo:", "res.userInfo,", "hasUserInfo:", "true", "})", "}", "})", "}", "},", "getUserInfo:", "function(e)", "{", "console.log(e)", "app.globalData.userInfo", "=", "e.detail.userInfo", "this.setData({", "userInfo:", "e.detail.userInfo,", "hasUserInfo:", "true", "})", "}整体效果最后这个小程序还有一些功能还没有实现，比如购物车，用户信息的保存在后台的问题，以后等自学完后端的一些知识，我还是得把这个小程序完整的做出来，喜欢的话大家可以关注我的github，我们可以一起学习，一起搞基哈，也希望可以给我提出一些宝贵的意见源文件:github地址", "期待你的star和fork哦第一次写文章，项目可能不是很好，表达的也未必清楚，请给新手多一点的鼓励，点个赞，留下你的建议吧"]}
{"author": "Rolan", "title": "wepy+weappx开发小程序遇到的坑以及解决方案 ", "content": ["从小程序的发布，到现在已经有一年多的时间了，从当时信誓旦旦的要替代APP，到近期实现了APP和小程序互跳的功能，定位也悄然变为APP的一个补充，都是现实给逼的，就像当时卸载了摩拜和美团的APP，觉得只用小程序就行的同事，最后都又把APP装了回来，为什么呢？因为小程序只是实现了原有APP的部分功能，最后发现还是APP用着方便，毕竟现在手机内存基本都是32g起，一个APP也占不了多少地方。技术无止境，人生莫等闲，开启正文。技术栈微信小程序WePYweappx微信小程序官方文档已经很详细了，经过多次的更新，目前小程序已经支持自定义组件，引入其他开发者的插件和外部的资源，还有了一套小程序的语言wxs,据官方文档的说法在IOS上的运行速度比JavaScript要快2~20倍，组件和API也是越来越完善。WePY是腾讯一团队出的一个小程序组件化开发框架，第一次更新是在2016.11.23，比小程序的发布时间2017.1.9还早，也就是说小程序在腾讯内测的时候，某个喜欢Vue大佬用了之后，发现这玩意开发起来不够爽呀，连组件都不支持，然后这个大佬就拉了一帮人，说兄弟们咱弄个框架出来吧，让大家能用类Vue的开发方式去开发小程序，然后你应该懂了，如果你会Vue，上手这个那是分分钟的事，它支持组件", "Props", "传值，自定义事件、组件分布式复用Mixin、计算属性函数computed、模板内容分发slot等等。weappx是一个小程序的状态管理框架，wepy和原生小程序都可以使用，", "API和Dva，Vuex挺像，但是比它们两个要简单的多，Dva已经把APi的数量精简到6个，它更狠才4个API就能上手，API虽然少但作为状态管理框架，该有的功能都是有的，开发起来还是相当的爽的，详细的介绍请看文档，相比Dva现在的9000多个star，weappx的50多个star显的有点寒酸，如果用了之后觉得挺不错的童鞋，都star下，精神上支持下作者。遇到的坑以及开发注意点1.", "repeat标签嵌套两级以及以上组件传值给自组件传值问题这个问题其实是wepy的一个bug，在github上已经有好多人提过Issues，官方并没有给出解释，经过自己的摸索，有两种解决方式：对于纯组件用小程序原生的模板template代替子组件中第二层循环采用此写法，直接使用template<template", "wx:key=\"{{index}}\"", "wx:for=\"{{item.giftBoxs}}\"", "wx:for-item=\"giftBoxsItem\"", "data=\"{{...giftBoxsItem}}\"", "is=\"indexMoItem\"></template>在主页面中引入此模板<import", "src=\"../../components/giftIndex/indexMoItem.wxml\"/>wepy最终会把所引用的组件代码，都打包到一个主页面中的,所以在主页面引入模板即可第一种方法可以解决这个问题，并且还节省了代码量，但这属于wepy和原生小程序混写，后面又发现另一种解决办法对于第二层循环要传的值，用repeat标签包裹一层<repeat", "for=\"{{", "[item]", "}}\"", "key=\"item.orderNo\"", "index=\"index\"", "item=\"itemval\">", "<giftItem", ":itemval=\"itemval\"", "></giftItem>", "</repeat>已经在wepy的Issues中做了回答，并有一个老铁点了赞，应该是帮他解决了这个问题2.", "向子组件传类似Object.key这样的值正常传值//", "数据", "data", "=", "{", "textMsg1:", "'text1',", "textMsg2:", "{", "text:", "'text2'", "},", "}", "//", "组件", "<child", ":msg=\"textMsg1\"></child>界面展示传对象中的值<child", ":msg=\"textMsg2.text\"></child>界面展示没有报错但是值也无法传递，这个问题也是Issues中提的比较多的,可采用下面方法解决<repeat", "for=\"{{", "[textMsg2.text]", "}}\">", "<child", ":msg=\"item\"></child>", "</repeat>3.", "小程序开发工具变慢在开发过程城中，随着项目文件的越来越大，会发现小程序的开发工具越来越慢，甚至一个跳转都要等几秒钟才能跳转过去，这个时候需要把小程序打包出来的文件dist文件夹删掉，然后重新打包，会快很多，wepy也提供了命令，直接运行", "npm", "run", "clean", "也能达到同样的效果。4.", "小程序在手机上预览，出现卡顿现象出现这种情况有多方面的原因，如果你之前用过原生小程序开发过项目，那么直接点击开发工具上的预览按钮，然后用手机扫码预览是一个常见的操作，但是在使用wepy过程中，你使用npm", "run", "dev", "命令后，是出于开发环境，dist文件夹中的代码并没有进行压缩，优化，所以手机预览的时候会显得很慢，运行", "npm", "run", "build打成生产包预览，可以解决。5.", "数据更新了，UI视图没有更新这个也与开发环境和生成环境有关系，这种情况出现的比较少，在开发选择地址模块的时候，在开发工具上选择地址后，并改变了model中的数据，但是视图并没有更新，这种现象只在开发环境中出现，生产环境一切正常。6.", "个别手机样式错乱出现这种问题，是因为wepy脚手架中并没有配置样式自动补全，需要自己手动配置，在wepy.config.js添加下面代码即可，", "插件地址module.exports.plugins", "=", "{", "'autoprefixer':", "{", "filter:", "/\\.wxss$/,", "config:", "{", "browsers:", "['last", "11", "iOS", "versions']", "}", "}", "}7.", "通一个页面多次使用同一个组件数据传递问题同一个页面多次使用同一个组件，要为这个组件起不同的名字，这个官方文档有介绍，需要注意的是，WePY中的组件都是静态组件，是以组件ID作为唯一标识的，每一个ID都对应一个组件实例，当页面引入两个相同ID的组件时，这两个组件共用同一个实例与数据，当其中一个组件数据变化时，另外一个也会一起变化。这个与wepy的组件机制有关，//", "data", "data", "=", "{", "textMsg1:", "'text1',", "textMsg3:", "'text3',", "textMsg2:", "{", "text:", "'text2'", "},", "}", "//", "组件", "<child", ":msg=\"textMsg1\"></child>", "<child", ":msg=\"textMsg3\"></child>按照正常的逻辑，最终显示结果肯定是text1和text3,但是我们查看编译后的代码<view", "class=\"containers\">", "<view>我是子组件</view>", "传递来的数据：{{$child$msg}}", "</view>", "<view", "class=\"containers\">", "<view>我是子组件</view>", "传递来的数据：{{$child$msg}}", "</view>在开发工具中的AppData中我们能看到相信大家已经明白了，wepy中的组件其实就是把组件中的代码copy到引入的页面中，组件中使用的变量，名字被改成$+组件名字+变量名字，在组件引用页中的data其实就是一个对象，对象的属性值，后面会覆盖前面，页面渲染过程，大致如下data", "=", "{", "}", "//", "渲染第一个组件", "data.$child$msg", "=", "'text1'", "//", "渲染第二个组件", "data.$child$msg", "=", "'text3'将第二个组件注释掉，第一个就会显示正常我们给组件起不同的名字后显示就能如预期那样渲染//", "挂载组件", "components", "=", "{", "child1:", "Child,", "child2:", "Child", "};", "<child1", ":msg=\"textMsg1\"></child1>", "<child2", ":msg=\"textMsg3\"></child2>", "//", "编译后", "<view", "class=\"containers\">", "<view>我是子组件</view>", "传递来的数据：{{$child1$msg}}", "</view>", "<view", "class=\"containers\">", "<view>我是子组件</view>", "传递来的数据：{{$child2$msg}}", "</view>我们可以看到显示正常了，查看data也会看到8.", "weappx中更改state数据报错在使用weappx过程中，只能在mutations中更改state中的数据，如果在其他地方更改数据就会报错，Uncaught", "(in", "promise)", "TypeError:", "Cannot", "assign", "to", "read", "only", "property", "'count'", "of", "object", "'#'，这句话的意思是，count为只读属性，不能进行设置，如果一个页面要使用其他model中的数据，最好是深度clone一份，以免无意中修改数据，出现上述错误使用感受1.采用类Vue语法，对于新手比较友好，上手比较快,", "但还需要学习小程序的api，框架不是很完善，有不少坑要填2.使用状态管理框架,集中管理逻辑代码，实现不同页面状态的共享，提升开发效率3.代码结构清晰，接口，逻辑代码和静态页面分离，便于多人合作和后期的维护4.引入库比较多，导致项目体积过大"]}
{"author": "Rolan", "title": "找工作怎么办，拉勾小程序来帮你 ", "content": ["现在的前端有各种各样的新知识和新框架，小程序才出生几年，就已经火到这种程度了，所以作为前端学习者，这个新技能我们是一定要尽快get到的。学习小程序最好的方法就是自己手写一个小程序，能从中找到自己的不足之处。于是我便萌发了一个新想法，自己手撸一个拉勾小程序。刚开始的时候，起步是有点难的，不知道怎么把学的东西转化成自己想要写的东西，但谢了一点后，感觉有点入迷了，停不下来。希望我写的东西能够帮助社区的学习者，如果写的不好，也欢迎你指正。开发工具与资源平台微信web开发者工具：用于敲网页代码，但是最主要用来进行手机效果预览。VsCode:主要用于布局排版，也是敲代码的主战场，真心觉得这个编辑器不错，快捷输入和排版，大大提高了开发效率，使用简单，一学就会。Iconfont-阿里巴巴矢量图标库", "：提供项目中的所有图标，资源丰富。微信小程序开发者文档:微信小程序开发的文档，资源库，以及API规范Easy", "Mock:", "可以模拟我们想要的数据，非常方便。这里是部分数据预览图片功能展示数据请求拉勾里面有非常多的数据，所以我在easy", "mock里面创建了很多接口，在页面需要用到的时候去", "请求数据，如果每一次都要用wx.request，而且到处都是异步请求，处理时会遇到很多的麻烦，", "es6中的promise可以将异步变成同步(vue中的async和await也可以)，封装一个request在以后", "的开发中也用得到的封装的requestfunction", "request(params)", "{", "return", "new", "Promise((resolve,", "reject)", "=>", "{", "wx.request({", "url:", "params.url,", "method:", "params.method", "||", "'get',", "data:", "params.data,", "header:", "{", "'content-type':", "'application/json'", "},", "success:", "resolve,", "error:", "err", "=>", "{", "console.log(\"请求出错:\"", "+", "err.errMsg);", "}", "})", "})", "}", "export", "default", "request》import", "request", "from", "'../../utils/request.js'", "需要请求数据引入request.js查看页面详情查看页面详情就是讲你点击的那个id传过去，但是我在这里遇到了一个坑，我在寻找点击的那个id的详情时，发现我匹配不了我的数据，后来我一步一步打印找事哪一步有问题，发现我用easymock造的数据，传的id是个字符串而不是数字，所以我将传过来id转化成数字在去进行匹配，得到了想要点击的详情页。getActive(id)", "{", "const", "url", "=", "'https://www.easy-mock.com/mock/5b06da4872643c7a5c4edcd1/api/desc#!method=get';", "var", "params", "=", "{", "url:", "url,", "method:", "'GET',", "};", "let", "position", "=", "[];", "let", "currentDesc", "=", "this.data.currentDesc;", "request(params).then(res", "=>", "{", "//异步变同步", "position", "=", "res.data.data.position;", "}).then(()", "=>", "{", "for", "(let", "i", "=", "0;", "i", "<", "position.length;", "i++)", "{", "if", "(i", "===", "id)", "{", "let", "that", "=", "this;", "that.setData({", "currentDesc:", "position[i]", "})", "console.log(that.data.currentDesc)", "}", "}", "}", ");", "},", "onLoad:", "function", "(options)", "{", "let", "id", "=", "options.id", "-", "0;", "//将id转化成number", "this.getActive(id);", "//请求数据匹配id", "},搜索因为是用markdown造的假数据，数据不是很多，而且这不是像有后端的那样，可以传给后端参数，让后端给你提供符合的数据，所以还是得要自己干。刚开始实现时，第一时间想到的是用indexOf()去判断，如果不含有我输入的字符串，就返回-1，通过这点去判断。写这个只要知道大概的想法，一般是不怎么会出错的。onInput(e)", "{", "let", "value", "=", "e.detail.value;", "//", "console.log(value);", "const", "job", "=", "this.data.job;//匹配的数组", "var", "list", "=", "[];", "for(var", "i", "=", "0;", "i", "<", "job.length;", "i++){", "if(job[i].indexOf(value)>-1){//不包含value就返回-1", "list.push(job[i]);", "}", "}", "this.setData({", "list:", "list,", "['search.content']:", "value", "});", "},我这一部分之前是有小bug的，页面从后一个页面回来时，搜索的记录会变成历史记录，同时搜索的值还会在input上，但是同样列表还显示在下面，这样就会造成用户体验及不良好，所以我给整个的搜索匹配到的列表一个三元运算符，点击跳转之前就会将其设为false，然后列表就会隐藏起来，从后一个页面返回时也不会出现那种状况。<view", "class=\"item-lists", "{{isShoeLists?'hidden':''}}\">", "<view", "class=\"weui-cell", "border-botton\"", "wx:for=\"{{list}}\"", "wx:key=\"index\"", "bindtap=\"positionSearch\"", "data-index=\"{{index}}\">", "<view", "class=\"weui-cell__hd", "\">", "<image", "src=\"../../images/job-search-pic.png\"", "style=\"margin-right:", "5px;vertical-align:", "middle;width:30px;", "height:", "30px;\"></image>", "</view>", "<view", "class=\"weui-cell__bd", "job-desc\">{{item}}</view>", "<view", "class=\"weui-cell__ft\"></view>", "</view>", "</view>positionSearch(e)", "{", "//", "console.log(e)", "let", "list", "=", "this.data.list", "let", "index", "=", "e.currentTarget.dataset.index;", "let", "value", "=", "list[index];", "let", "history", "=", "this.data.history;", "history.push(value);", "//将搜索的记录放入到历史搜索中", "this.setData({", "['search.content']:", "value,", "history,", "isShowLists:", "true", "//", "将lists隐藏", "})", "wx.navigateTo({", "url:", "`../related/related?value=${value}`,", "})", "},scroll-view会碰到的问题请勿在scroll-view之中使用", "textarea、map、canvas、videoscroll-into-view的优先级高于scroll-viewscroll-view需要给scroll-view一个固定的宽度或高度，设置属性scroll-x或scroll-y,并且设置样式white-space:nowrap;（这个很重要，不设置这个样式，无法完成scroll-view的效果如果要下拉刷新时，请使用scroll-view组件自带的方法，在scroll-view中滚动是不会触发onPullDownRefresh事件的页面返回传值跳转页面的时候，可以通过navigateTo将要传递参数放在url上，但是返回原页面时，就得换过一种传参方法。一种是在app.js中设置golbaldata，然后在你想要传值的地方去设置golbaldata就可以了，或者你将数据储存在stroage里面。还有一种就是", "getCurrentPages()", "，getCurrentPages()", "函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。不要尝试修改页面栈，会导致路由以及页面状态错误。changecity(e)", "{", "var", "value", "=", "e.target.dataset.value;", "var", "pages", "=", "getCurrentPages();", "var", "currPage", "=", "pages[pages.length", "-", "1];", "//当前页面", "var", "prevPage", "=", "pages[pages.length", "-", "2];", "//上一个页面", "prePage.setData({", "location:", "value,", "city:", "value", "});", "wx.navigateBack({", "delta:", "1", "})", "},编辑简历用weui去写微信小程序去写节省我们一部分的时间。这个功能这里也有一个需要将值传回来的，我在这里是将参数传入stroage里面，因为我想换一种方式去实现。在个人信息中，有一个表单验证，在这里，我除了一个大亏。先贴代码，看看我写的表单验。<view", "class=\"container\">", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__hd\">", "<view", "class=\"weui-label\">真实姓名</view>", "</view>", "<view", "class=\"weui-cell__bd\">", "<input", "class=\"weui-input", "name-input\"", "type=\"text\"", "value=\"{{val}}\"", "bindinput=\"nameChange\"", "placeholder=\"请输入\"", "/>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__bd\">性别</view>", "<view", "class=\"weui-cell__ft\">", "<picker", "bindchange=\"bindSexChange\"", "value=\"{{index}}\"", "range=\"{{arraySex.sex}}\"", "class=\"name-input\">", "<view", "class=\"selectPick\"", "wx:if=\"{{!arraySex.isPickSelect}}\">", "<text>请选择</text>", "</view>", "<view", "wx:else", "class=\"picker\">", "{{arraySex.sex[arraySex.index]}}", "</view>", "</picker>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__bd\">出生日期</view>", "<view", "class=\"weui-cell__ft\">", "<picker", "mode=\"date\"", "value=\"{{date}}\"", "start=\"1949-10-01\"", "end=\"2018-06-01\"", "bindchange=\"bindDateChange\">", "<view", "class=\"picker\">", "{{date}}", "</view>", "</picker>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__bd\">最高学历</view>", "<view", "class=\"weui-cell__ft\">", "<picker", "bindchange=\"bindEducationChange\"", "value=\"{{index}}\"", "range=\"{{arrayEducation.education}}\">", "<view", "class=\"selectPick\"", "wx:if=\"{{!arrayEducation.isPickSelect}}\">", "<text>请选择</text>", "</view>", "<view", "wx:else", "class=\"picker\">", "{{arrayEducation.education[arrayEducation.index]}}", "</view>", "</picker>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__bd\">工作经验</view>", "<view", "class=\"weui-cell__ft\">", "<picker", "bindchange=\"bindExperienceChange\"", "value=\"{{index}}\"", "range=\"{{arrayExperience.experience}}\">", "<view", "class=\"selectPick\"", "wx:if=\"{{!arrayExperience.isPickSelect}}\">", "<text>请选择</text>", "</view>", "<view", "wx:else", "class=\"picker\">", "{{arrayExperience.experience[arrayExperience.index]}}", "</view>", "</picker>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__hd\">", "<view", "class=\"weui-label\">手机号码</view>", "</view>", "<view", "class=\"weui-cell__bd\">", "<input", "class=\"weui-input", "name-input\"", "type=\"number\"", "value=\"{{val}}\"", "bindinput=\"telChange\"", "placeholder=\"请输入\"", "/>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__hd\">", "<view", "class=\"weui-label\">联系邮箱</view>", "</view>", "<view", "class=\"weui-cell__bd\">", "<input", "class=\"weui-input", "name-input\"", "type=\"email\"", "value=\"{{val}}\"", "bindinput=\"mailChange\"", "placeholder=\"请输入\"", "/>", "</view>", "</view>", "</view>", "<view", "class=\"weui-cells", "weui-cells_after-title", "name\">", "<view", "class=\"weui-cell", "weui-cell_input\">", "<view", "class=\"weui-cell__bd\">所在城市</view>", "<view", "class=\"weui-cell__ft\"", "bindtap=\"cityChange\">", "<view", "wx:if=\"{{!isChooseCity}}\"", "class=\"changeCity\">", "<text>请选择</text>", "</view>", "<view", "wx:else", "class=\"changeCity\">{{city}}</view>", "</view>", "</view>", "</view>", "<view", "class=\"bgft\">", "<view", "class=\"introduction\">", "<view", "class=\"intro\">", "<text>一句话介绍自己</text>", "<view", "class=\"wordNum\">{{num}}/60</view>", "</view>", "<view>", "<textarea", "placeholder=\"说出你的心声\"", "value=\"{{value}}\"", "maxlength=\"60\"", "class=\"input\"", "bindinput=\"inputChange\"", "/>", "</view>", "</view>", "<button", "class=\"btnEdit\"", "bindtap=\"formSubmit\">保存</button>", "</view>", "</view>formSubmit(e)", "{", "//验证是否输入名字", "let", "nameVal", "=", "this.data.nameVal;", "if", "(!this.errorInput(nameVal,", "'请输入你的名字'))", "{", "return", "false;", "};", "console.log(nameVal)", "//验证是否选择性别", "let", "sex", "=", "this.data.arraySex.sex[this.data.arraySex.index];", "if", "(!this.error(this.data.arraySex.isPickSelect,", "'请选择你的性别'))", "{", "return", "false;", "};", "console.log(sex)", "//验证是否选择了出生日期", "let", "date", "=", "this.data.date;", "if", "(date", "===", "'1999-01-01')", "{", "w"]}
{"author": "Rolan", "title": "appium+python自动化56-微信小程序自动化（摩拜为例） ", "content": ["前言", "最近微信的小程序越来越多了，随之带来的问题是：小程序如何做自动化测试？", "本篇以摩拜小程序为例，介绍如何定位小程序里面的元素运行环境：android", "7.0", "appium", "v1.7.1webview进程1.小程序和微信公众号还不太一样，基本思路差不多，先配置：chromeOptions'chromeOptions':", "{'androidProcess':", "'com.tencent.mm:appbrand0'}2.androidProcess进程可以通过adb", "shell去查看，先点开摩拜小程序，然后进adb", "shellC:\\Users\\admin>adb", "shellHWBND-H:/", "$", "dumpsys", "activity", "top", "|", "grep", "ACTIVITY", "ACTIVITY", "com.tencent.mm/.plugin.appbrand.ui.AppBrandUI", "d0f2ff4", "pid=9104HWBND-H:/", "$", "ps", "9104USER", "PID", "PPID", "VSIZE", "RSS", "WCHAN", "PC", "NAMEu0_a119", "9104", "495", "2706272", "283720", "0", "0000000000", "S", "com.tencent.mm:appbrand0HWBND-H:/", "$3.com.tencent.mm:appbrand0", "这个就是我们要找到的了摩拜小程序", "1.先点开微信首页，下滑页面，出现小程序菜单后点击‘摩拜’2.代码实现：def", "swipeDown(driver,", "t=500,", "n=1):", "'''向下滑动屏幕'''", "l", "=", "driver.get_window_size()", "x1", "=", "l['width']", "*", "0.5", "#", "x坐标", "y1", "=", "l['height']", "*", "0.25", "#", "起始y坐标", "y2", "=", "l['height']", "*", "0.75", "#", "终点y坐标", "for", "i", "in", "range(n):", "driver.swipe(x1,", "y1,", "x1,", "y2,t)向下滑动swipeDown(driver)", "小程序操作", "1.进入小程序后点右下角的头像，这里可以通过坐标去点击由于每个手机分辨率不一样，这里可以直接去计算下图标在屏幕的比例2.接着点击“发红包赚赏金”#", "注意，这里是不需要切换的，别踩坑了！！！！！！#", "driver.switch_to.context('WEBVIEW_com.tencent.mm:tools')", "#", "不要加这行time.sleep(3)#", "tap触摸右下角那个菜单坐标", "[873,1654],", "[1080,1861]driver.tap([(873,", "1654),", "(1080,", "1861)],", "500)#", "点发红包赚赏金driver.find_element_by_accessibility_id(\"发红包赚赏金\").click()参考代码#", "coding:utf-8from", "appium", "import", "webdriverfrom", "appium.webdriver.common.touch_action", "import", "TouchActionimport", "timedesired_caps", "=", "{", "'platformName':", "'Android',", "'platformVersion':", "'7.0',", "'deviceName':", "'A5RNW18316011440',", "'appPackage':", "'com.tencent.mm',", "'appActivity':", "'.ui.LauncherUI',", "'automationName':", "'Appium',", "#", "'unicodeKeyboard':", "True,", "#", "'resetKeyboard':", "True,", "'noReset':", "True,", "'chromeOptions':", "{'androidProcess':", "'com.tencent.mm:appbrand0'}", "}driver", "=", "webdriver.Remote('http://localhost:4723/wd/hub',", "desired_caps)time.sleep(10)def", "swipeDown(driver,", "t=500,", "n=1):", "'''向下滑动屏幕'''", "l", "=", "driver.get_window_size()", "x1", "=", "l['width']", "*", "0.5", "#", "x坐标", "y1", "=", "l['height']", "*", "0.25", "#", "起始y坐标", "y2", "=", "l['height']", "*", "0.75", "#", "终点y坐标", "for", "i", "in", "range(n):", "driver.swipe(x1,", "y1,", "x1,", "y2,t)#", "向下滑动swipeDown(driver)time.sleep(2)#", "点开小程序driver.find_elements_by_id(\"com.tencent.mm:id/r9\")[0].click()time.sleep(4)print(driver.contexts)#", "注意，这里是不需要切换的，别踩坑了！！！！！！#", "driver.switch_to.context('WEBVIEW_com.tencent.mm:tools')time.sleep(3)#", "tap触摸右下角那个菜单坐标", "[873,1654],", "[1080,1861]driver.tap([(873,", "1654),", "(1080,", "1861)],", "500)#", "点发红包赚赏金driver.find_element_by_accessibility_id(\"发红包赚赏金\").click()"]}
{"author": "Rolan", "title": "Atom 微信小程序文件代码高亮 ", "content": ["Atom", "微信小程序文件代码高亮小程序相关的文件后缀名是", ".wxml,", ".wxss,", ".wxs", "，可是", "Atom", "编辑器默认不会自动识别这些类型的文件，打开这些文件只能看到反人类的黑白代码。一个优雅的方案是，通过修改", "Atom", "的配置，使", "Atom", "把", ".wxml", "当成", ".html,", "把", ".wxss", "当成", ".css,", "把", ".wxs", "当成", ".js.", "这样在打开这些类型的文件时就会看到彩色的代码了。操作步骤1、打开", "config.cson", "配置文件同时按下快捷键", "Command", "+", "Shift", "+", "P", "唤起命令面板,", "输入", "Application:", "Open", "Your", "Config", ",", "点击回车键", ",", "将会打开文件", "config.cson2、修改", "config.cson", "配置文件在", "core", "下面添加customFileTypes:", "'text.html.basic':", "[", "'wxml'", "]", "'source.css':", "[", "'wxss'", "]", "'source.js':", "[", "'wxs'", "]", "文件大致结构\"*\":", "core:", "customFileTypes:", "'text.html.basic':", "[", "'wxml'", "]", "'source.css':", "[", "'wxss'", "]", "'source.js':", "[", "'wxs'", "]", "这个文件中可能还有很多其他的属性，因为有些插件会自动将配置加到这个文件中配置完成！", "重新打开", ".wxml,", ".wxss,", "wxs", "后缀的文件，将会看到彩色的代码。原理其实，Atom", "并不是把", "wxml", "文件识别成", "html文件，而是用和", "html", "文件一样的语法规则去高亮显示", "wxml", "文件中的代码。text.html.basic,", "source.css,", "source.js", "就是相应的语法规则名称，这些名称可以在", "language-xxx", "这样的", "Atom", "内置或第三方的", "Package", "中找到。参考：flight-manual.atom.io/using-atom/…flight-manual.atom.io/using-atom/…"]}
{"author": "Rolan", "title": "小程序: moveable-area 和 movealbe-view ", "content": ["代码Github地址一.", "movable-areamovable-view的可移动区域。属性说明二.", "movalbe-view可移动的视图容器，在页面中可以拖拽滑动注意点movable-view必须设置width和height。不然就会默认为10px.movable-view必须在<movable-area/>组件中，并且必须是直接子节点，否则不能移动movable-view", "默认为绝对定位，top和left属性为0px当movable-view小于movable-area时，movable-view的移动范围是在movable-area内；当movable-view大于movable-area时，movable-view的移动范围必须包含movable-area（x轴方向和y轴方向分开考虑）三.", "可运行的代码wxml<view", "class='container'>", "<view", "class=\"section_title_less\">", "movable-view区域小于movable-area", "</view>", "<movable-area", "class=\"area_less\"", "scale-area>", "<movable-view", "class=\"view_less\"", "direction=\"all\"", "scale", "inertia", "out-of-bounds", "x=\"{{x}}\"", "y=\"{{y}}\"", "damping=\"1\"", "friction=\"200\"", "bindchange=\"change\"", "bindscale=\"scale\"></movable-view>", "</movable-area>", "<view", "class=\"section_title_more\">", "movable-view区域大于movable-area", "</view>", "<movable-area", "class=\"area_more\"", "scale-area>", "<movable-view", "class=\"view_more\"", "direction=\"all\">", "<text>可移动的view</text>", "</movable-view>", "</movable-area></view>wxss.container", "{", "display:", "flex;", "flex-direction:", "column;", "align-items:", "center;}.section_title_less", "{", "font-size:", "28rpx;}.area_less", "{", "height:", "200px;", "width:", "200px;", "background-color:", "red;}.view_less", "{", "height:", "50px;", "width:", "50px;", "background-color:", "yellow;}.section_title_more", "{", "font-size:", "28rpx;", "margin-top:", "50px;}.area_more", "{", "height:", "50px;", "width:", "50px;", "background-color:", "red;}.view_more", "{", "height:", "200px;", "width:", "200px;", "border-color:", "green;", "border-width:", "2px;", "borderjsPage({", "/**", "*", "页面的初始数据", "*/", "data:", "{", "x:", "\"100px\",", "y:", "\"10px\"", "},", "/**", "*", "生命周期函数--监听页面加载", "*/", "onLoad:", "function", "(options)", "{", "},", "change:", "function", "(event)", "{", "//", "console.log(event);", "},", "scale:", "function", "(event)", "{", "//", "console.log(event);", "},", "vtouchmove:", "function", "(event)", "{", "console.log(\"纵向\");", "},", "htouchmove:", "function", "(event)", "{", "console.log(\"横向\");", "}})"]}
{"author": "Rolan", "title": "小程序效果--星星评价（网页通用） ", "content": ["先看效果图（忽略我家猫）效果图", "原理是需要两张图片", "一张选中的黄色，一张未选中的灰色选中", "未选中", "1、循环image标签五次", "2、绑定点击事件", "3、获取点击下标，并赋值给score变量", "4、三目运算判断score变量于index", "的关系", "动态更改图片路径", "5、此方法网页也可用", "通用//wxml<image", "class=\"start\"", "wx:for=\"{{5}}\"", "data-index=\"{{index}}\"", "bindtap='selectIndexNum'", "src=\"{{score", ">=", "index", "?", "'/utils/img/big_star_s@3x.png'", ":", "'/utils/img/big_star_n@3x.png'}}\"/>//普通版本", "jsselectIndexNum(e){", "this.setData({", "score:", "e.currentTarget.dataset.index", "-", "0", "})},或者增强版效果//点两次相同分数取消选择", "jsselectIndexNum(e){", "let", "i", "=", "e.currentTarget.dataset.index;", "if(i", "==", "this.data.score){", "this.setData({", "score:", "-1", "})", "}else", "{", "this.setData({", "score:", "e.currentTarget.dataset.index", "-", "0", "})", "}},"]}
{"author": "Rolan", "title": "JS实现监控微信小程序 ", "content": ["《使用模块化工具打包自己开发的JS库》", "文章中有提到，当时需要写一个SDK，监控小程序的后台接口调用和页面报错，今天就来说下实现原理吧！原理之前也做过浏览器web端的SDK数据埋点上报，其实原理大同小异：通过劫持原始方法，获取需要上报的数据，最后再执行原始方法，这样就能实现无痕埋点。举个例子：我希望监控所有web页面的ajax请求，每次发送ajax，都需要在控制台打印出发送的url平时我们开发，发送ajax一般用的都是封装好的库，例如jQuery,Axios等，然而这些库，底层仍然用的是浏览器原生的XMLHttpRequest对象，因此，我们只需要修改XMLHttpRequest对象即可注意：由于JS的灵活性，修改原生方法是一件很容易的事，然而并不鼓励这样做！//", "把这段代码放在所有JS代码之前，我们就实现了拦截ajax的需求", "window.XMLHttpRequest.prototype.open", "=", "(function(originOpen)", "{", "return", "function(method,", "url,", "async)", "{", "console.log('发送了ajax，url是:", "',", "url);", "return", "originOpen.apply(this,", "arguments);", "};", "})(window.XMLHttpRequest.prototype.open);在这个立即执行函数中，我们把原生的", "open", "方法通过", "originOpen", "暂时存储起来，然后在外面包裹一层函数，实现了打印输出url的功能，最后通过", "originOpen.apply", "让原生方法运行，这样就实现了无痕拦截。监控小程序拦截wx.request小程序的运行环境并没有", "window", "和", "document", "对象，它只暴露了一个", "wx", "全局对象，发送网络请求则是通过wx.request这个api，因此，这次我们需要拦截的就是", "wx.request", "方法我们试着更改一下", "wx.requestwx.request", "=", "function()", "{", "console.log('66666');", "}这时控制台会报错", "TypeError:", "Cannot", "set", "property", "request", "of", "#<Object>", "which", "has", "only", "a", "getter这是因为，", "wx.request", "这个属性，只有", "get", "方法而没有", "set", "方法，我们可以通过", "Object.getOwnPropertyDescriptor", "验证：const", "des", "=", "Object.getOwnPropertyDescriptor(wx,", "'request');", "//", "des", "{", "//", "configurable:", "true,", "//", "enumerable:", "true,", "//", "get:", "f(),", "//", "set:", "undefined", "//", "}我们可以换种方式修改：const", "originRequest", "=", "wx.request;", "Object.defineProperty(wx,", "'request',", "{", "configurable:", "true,", "enumerable:", "true,", "writable:", "true,", "value:", "function()", "{", "const", "config", "=", "arguments[0]", "||", "{};", "const", "url", "=", "config.url;", "console.log('发送了ajax，url是:", "',", "url);", "return", "originRequest.apply(this,", "arguments);", "}", "});这次就实现拦截功能了！监控异常小程序的注册函数", "App", "有个全局的", "onError", "方法，我们可以在小程序的入口文件", "app.js", "先注册一个该方法:App({", "onError:", "function(err)", "{", "console.log('上报错误啦！');", "wx.request({", "url:", "'http://monitor.com/monitor/error',", "data:", "err", "})", "}", "})", "App({", "//", "其他逻辑", "})不过需要注意的是：如果后续的程序重写了onError的话，将会导致之前注册的onError失效。解决方法可以是：我们监控SDK可以暴露一个接口，让接入方自己在onError中调用我们的接口。App({", "onError:", "function", "(err)", "{", "monitor.notifyError(err)", "}", "})上报数据收集好需要的数据后，当然就要上报后台。怎么上报？当然还是用的", "wx.request", "发送请求。这里就容易出现一个", "死循环", ":", "如果用之前被我们包装过的", "wx.request", "上报数据，那么上报数据这个ajax请求，也会被我们认为是普通的ajax请求，然后又会触发上报，这样来来回回，无穷无尽的发送上报数据。解决方法有多种，比如：方案1可以在包装", "wx.request", "的时候，判断发送的url如果是上报接口，那么就不再上报了。const", "originRequest", "=", "wx.request;", "Object.defineProperty(wx,", "'request',", "{", "configurable:", "true,", "enumerable:", "true,", "writable:", "true,", "value:", "function()", "{", "const", "config", "=", "arguments[0]", "||", "{};", "const", "url", "=", "config.url;", "if", "(url.indexOf('http://monitor.com')", ">", "-1)", "{", "//", "直接发送请求，不上报", "return", "originRequest.apply(this,", "arguments);", "}", "console.log('上报ajax数据啦!');", "wx.request({", "url:", "'http://monitor.com/monitor/ajax',", "data:", "config.data", "})", "return", "originRequest.apply(this,", "arguments);", "}", "});方案2在包装", "wx.request", "之前，保留一份最原始的", "wx.request", "方法，所有的上报请求，就不走被包装过的方法，而走最原始的方法。const", "myRequest", "=", "wx.request;", "const", "wrapRequest", "=", "function", "()", "{", "const", "originRequest", "=", "wx.request;", "Object.defineProperty(wx,", "'request',", "{", "configurable:", "true,", "enumerable:", "true,", "writable:", "true,", "value:", "function()", "{", "const", "config", "=", "arguments[0]", "||", "{};", "const", "url", "=", "config.url;", "console.log('上报数据啦!');", "//", "使用最原始的request方法", "myRequest({", "url:", "'http://monitor.com/monitor/ajax',", "data:", "config.data", "})", "return", "originRequest.apply(this,", "arguments);", "}", "});", "}", "wrapRequest();其他事项实际开发中当然还有更多的细节，比如监控项目的鉴权，SDK的代码结构，上报前的数据收集和聚合等等，本文就不详细展开了。"]}
{"author": "Rolan", "title": "微信小程序 open-data更改样式 open-data 显示头像 圆形 ", "content": ["废话不多说，直接看效果：效果一：代码如下：", "<view", "class='zhubo'>", "<view", "class='zhuboLeft'>", "<view", "class='zhubo-avater'>", "<image", "class='zhuboIcon'", "src='../../image/video-list/avater.jpg'></image>", "</view>", "<view", "class='zhuboDes'>", "<view", "class='zhubo-name'>东辰-寒冰</view>", "<view", "class='zhubo-from'>来自虎牙直播</view>", "</view>", "</view>", "<view", "class='zhubo-Right'>关注</view>", "</view>/*主播信息", "*/.zhubo{", "margin:", "0", "28rpx", "0;", "height:", "144rpx;", "display:flex;", "justify-content:space-between;", "align-items:", "center;}.zhuboIcon{", "width:80rpx;", "height:", "80rpx;", "border-radius:", "50%;", "overflow:", "hidden;}.zhuboLeft{", "display:", "flex;}.zhubo-avater{", "padding-right:", "20rpx;", "display:", "flex;", "align-items:", "center;}.zhubo-name{", "font-weight:", "700;}.zhubo-from{", "color:", "#A6A6A6;}效果二：<view", "class=\"userinfo\">", "<view", "class=\"userinfo-avatar\">", "<open-data", "type=\"userAvatarUrl\"></open-data>", "</view>", "<open-data", "type=\"userNickName\"></open-data></view>.userinfo", "{", "position:", "relative;", "width:", "750rpx;", "height:", "320rpx;", "color:", "#fff;", "display:", "flex;", "flex-direction:", "column;", "align-items:", "center;", "}", ".userinfo-avatar", "{", "overflow:hidden;", "display:", "block;", "width:", "160rpx;", "height:", "160rpx;", "margin:", "20rpx;", "margin-top:", "50rpx;", "border-radius:", "50%;", "border:", "2px", "solid", "#fff;", "box-shadow:", "3px", "3px", "10px", "rgba(0,", "0,", "0,", "0.2);", "}", ".userinfo{", "/*", "color:", "#fff;", "*/", "font-size:", "14px;", "background-color:", "#c0c0c0;", "border-radius:40%;", "}", "以上就是对新组件open-data样式更改的总结，希望我的文章能够帮助到你！"]}
{"author": "Rolan", "title": "小程序中如何接入人脸融合功能 ", "content": ["效果图创建一个AI应用https://ai.qq.com/cgi-bin/console_overview", "登录腾讯AI，创建并勾选相关接口即可。记得复制APPID", "APPKEY使用Java接入该功能创建一个SpringMVC工程，包含上传相关jar。或者SpringBoot工程也行。鄙人后端还在完善并没有完全开源。具体可以参考https://gitee.com/xshuai/xai", "项目Java调用腾讯AI接口。小帅丶已经封装成SDK。也是开源的", "https://gitee.com/xshuai/taip", "如果使用maven搭建。直接pom引入即可哦<!--", "https://mvnrepository.com/artifact/cn.xsshome/taip", "-->", "<dependency>", "<groupId>cn.xsshome</groupId>", "<artifactId>taip</artifactId>", "<version>4.2.1</version>", "</dependency>FaceMergeController（后端处理代码）import", "java.util.Iterator;", "import", "org.apache.log4j.Logger;", "import", "org.springframework.context.annotation.Scope;", "import", "org.springframework.stereotype.Controller;", "import", "org.springframework.web.bind.annotation.RequestMapping;", "import", "org.springframework.web.bind.annotation.RequestMethod;", "import", "org.springframework.web.multipart.MultipartFile;", "import", "org.springframework.web.multipart.MultipartHttpServletRequest;", "import", "cn.xsshome.taip.ptu.TAipPtu;", "/**", "*", "人脸融合接口", "*", "url:http://www.xxx.com/facemerge/uploadFM", "*/", "@Controller", "@RequestMapping(value=\"/facemerge\")", "@Scope(\"prototype\")", "public", "class", "FaceMergeController", "extends", "BaseController{", "private", "static", "final", "Logger", "logger", "=", "Logger.getLogger(FaceMergeController.class);", "/**", "*", "人脸融合", "*", "@throws", "Exception", "*/", "@RequestMapping(value=\"/uploadFM\",method=RequestMethod.POST)", "public", "void", "UploadBDANIMAL()throws", "Exception{", "TAipPtu", "aipPtu", "=", "new", "TAipPtu(\"APPID\",", "\"APPKEY\");", "String", "model", "=", "request.getParameter(\"model\");", "logger.info(\"model的值是====\"+model);", "String", "model", "=", "request.getParameter(\"model\");", "logger.info(\"model的值是====\"+model);", "String", "result", "=", "\"\";", "MultipartHttpServletRequest", "mpRequest", "=", "(MultipartHttpServletRequest)this.request;", "Iterator", "iter", "=", "mpRequest.getFileNames();", "MultipartFile", "file", "=", "null;", "while", "(iter.hasNext())", "{", "file", "=", "mpRequest.getFile((String)iter.next());", "if", "((file", "!=", "null)", "&&", "(file.getSize()", "!=", "0L)){", "byte[]", "image", "=", "file.getBytes();", "String", "apiPtuResult", "=", "aipPtu.faceMerge(image,Integer.parseInt(model));", "PrintUtil.printJson(this.response,", "apiPtuResult);", "}", "else", "{", "logger.error(\"请检查上传文件是否正确\");", "result", "=", "\"{\\\"result\\\",", "\\\"FAIL\\\",\\\"msg\\\":\\\"服务器开小差了\\\"}\";", "PrintUtil.printJson(this.response,", "result);", "}", "}", "}", "}", "BaseController(基类)import", "java.util.Map;", "import", "javax.servlet.http.HttpServletRequest;", "import", "javax.servlet.http.HttpServletResponse;", "import", "org.springframework.web.bind.annotation.ModelAttribute;", "/**", "*", "基类Controller", "*", "一些参数", "*", "Title:", "BaseController", "*", "@author", "小帅丶", "*", "@version", "1.0", "*/", "public", "class", "BaseController", "{", "public", "Map", "session;", "public", "String", "openId;", "public", "String", "errMsg;", "public", "String", "jsonParam;", "public", "String", "callback;", "protected", "HttpServletRequest", "request;", "protected", "HttpServletResponse", "response;", "/**", "*", "每次请求都会带上", "*", "@param", "jsonParam", "*", "@param", "callback", "*", "@param", "openId", "*/", "@ModelAttribute", "public", "void", "setReqAndRes(Map", "session,", "String", "openId,", "String", "errMsg,", "String", "jsonParam,", "String", "callback,", "HttpServletRequest", "request,", "HttpServletResponse", "response)", "{", "this.session", "=", "session;", "this.openId", "=", "openId;", "this.errMsg", "=", "errMsg;", "this.jsonParam", "=", "jsonParam;", "this.callback", "=", "callback;", "this.request", "=", "request;", "this.response", "=", "response;", "}", "public", "Map", "getSession()", "{", "return", "session;", "}", "public", "void", "setSession(Map", "session)", "{", "this.session", "=", "session;", "}", "public", "String", "getOpenId()", "{", "return", "openId;", "}", "public", "void", "setOpenId(String", "openId)", "{", "this.openId", "=", "openId;", "}", "public", "String", "getErrMsg()", "{", "return", "errMsg;", "}", "public", "void", "setErrMsg(String", "errMsg)", "{", "this.errMsg", "=", "errMsg;", "}", "public", "String", "getJsonParam()", "{", "return", "jsonParam;", "}", "public", "void", "setJsonParam(String", "jsonParam)", "{", "this.jsonParam", "=", "jsonParam;", "}", "public", "String", "getCallback()", "{", "return", "callback;", "}", "public", "void", "setCallback(String", "callback)", "{", "this.callback", "=", "callback;", "}", "public", "HttpServletRequest", "getRequest()", "{", "return", "request;", "}", "public", "void", "setRequest(HttpServletRequest", "request)", "{", "this.request", "=", "request;", "}", "public", "HttpServletResponse", "getResponse()", "{", "return", "response;", "}", "public", "void", "setResponse(HttpServletResponse", "response)", "{", "this.response", "=", "response;", "}", "public", "String", "getRealPath(String", "path)", "{", "return", "request.getSession().getServletContext().getRealPath(path);", "}", "}", "PrintUtil(响应类)import", "java.io.IOException;", "import", "java.io.PrintWriter;", "import", "java.io.Writer;", "import", "javax.servlet.http.HttpServletResponse;", "/**", "*", "输出结果", "*", "@author", "小帅丶", "*", "*/", "public", "class", "PrintUtil", "{", "public", "static", "void", "printXml(HttpServletResponse", "response,String", "result){", "try", "{", "response.setContentType(\"text/xml;", "charset=UTF-8\");", "PrintWriter", "sos", "=", "response.getWriter();", "sos.write(result);", "sos.flush();", "sos.close();", "}", "catch", "(IOException", "e)", "{", "//", "TODO", "Auto-generated", "catch", "block", "e.printStackTrace();", "}", "}", "/**", "*", "采用json", "或", "jsonp", "*", "@param", "callback", "*", "@param", "response", "*", "@param", "result", "*/", "public", "static", "void", "printJson(String", "callback,HttpServletResponse", "response,String", "result){", "boolean", "jsonP", "=", "false;", "if", "(callback", "!=", "null)", "{", "jsonP", "=", "true;", "response.setContentType(\"text/javascript;charset=utf-8\");", "}", "else", "{", "response.setContentType(\"application/x-json;charset=utf-8\");", "}", "try", "{", "Writer", "out", "=", "response.getWriter();", "if", "(jsonP)", "{", "out.write(callback", "+", "\"(\");", "}", "out.write(result.toString());", "if", "(jsonP)", "{", "out.write(\");\");", "}", "out.flush();", "out.close();", "}", "catch", "(Exception", "e)", "{", "//", "TODO", "Auto-generated", "catch", "block", "e.printStackTrace();", "}", "}", "public", "static", "void", "printJson(HttpServletResponse", "response,String", "result){", "try", "{", "response.setCharacterEncoding(\"UTF-8\");", "response.setContentType(\"application/json;", "charset=utf-8\");", "PrintWriter", "sos", "=", "response.getWriter();", "sos.write(result);", "sos.flush();", "sos.close();", "}", "catch", "(IOException", "e)", "{", "//", "TODO", "Auto-generated", "catch", "block", "e.printStackTrace();", "}", "}", "}", "微信小程序代码实现小帅一点资讯小程序代码是开源的哦学习并使用了微信小程序scroll-view组件相关代码请移步gitee查看", "https://gitee.com/xshuai/weixinxiaochengxu", "微信小程序上传限制为2048kb。相关图片过多超了限制。因此需要用到云存储。使用阿里云", "腾讯云都可以哦。在亲测的情况下发现。即使云储存域名不在小程序里面添加也是可以正常访问哦截图以上就是接入的整体流程", "可以扫码体验哦"]}
{"author": "Rolan", "title": "世界杯来了！小程序赛事操作来一波~ ", "content": ["NBA总决赛结束还没一周，马上世界杯就如期而至。大家在熬夜看球，而我关在小黑屋默默码字（可怜脸）。在体验到小程序的", "方便快捷省内存", "之后，前段时间的“骑勇大战”果断用了小程序观看。由于体验不错，又正在学习小程序知识，马上就想动手实践学习一下“腾讯体育”小程序的制作。到目前为止，只想说一句“选择是好的，过程是一言难尽的”，虽然还没全部完成，但也遇到不少问题，希望此分享可以给你带来帮助。效果图（干巴巴的开讲，还不如先来波动图）问题及解决方案1、scroll-view组件让我们先来看看开发文档scroll-x在此项目中，首页——世界杯的头部是一个横向滑动的", "scroll-view", "组件，在设置了", "scroll-x", "属性后，并未达到预期效果，scroll-view中的每个部分还是自成一行。在一番简单搜索后得出，设置", "white-space:", "nowrap;", "样式就可使其在同一行。scroll-yNBA赛事详情页中有5个sroll-view，虽然内容有点少，但还是看得出有scroll的效果的。同样的，在制作竖向滚动效果时，需要设置", "sroll-y", "属性，在官方的文档中也特别说明了使用竖向滚动时，需要给", "scroll-view", "一个固定高度，通过", "WXSS", "设置", "height。那么问题来了，在", "scroll-view", "并非占满全屏的情况下，如何确定其高度呢？首先想到，把包含选项卡和", "scroll-view", "的大盒子固定宽度后，在遵循文档流的情况下，将", "scroll-view", "高度设置为", "100%不就好了吗？但是，在如此一番设置之后，", "scroll-view", "的高度变成了大盒子的高度？？？（黑人问号脸），最重要的是", "scroll-view", "中的内容不能完全显示，这就头疼了。随后马上想到可以使用弹性布局，固定其选项卡的高度，下方的", "scroll-view", "设置", "flex:", "1，这难道还解决不了吗？是的，bug永相随。下图可以看到，选项卡的高度明显变小，要是scroll-view的内容再多一点，选项卡就被挤到窒息了。最后无奈只好将scroll-view的高度逐渐调整到屏幕底部的高度，简直不要太粗暴，缺点是在不同屏幕尺寸设备上查看，效果不一。如果有大佬可提供较好解决方案，恳请指教。2、swiper组件开发文档是好朋友，让我们再来看看。swiper", "组件在小程序中非常常见，它可在有限的区域展示更多内容，还能增加页面的视觉动态效果，总之就是好。（但，好东西也是有槽点的啦）1）", "从上面动图可看出，NBA赛事详情页中也使用到了", "swiper", "组件，并且与头部的导航进行了绑定，滑动", "swiper", "可改变导航栏的状态，点击导航栏选项可切换", "swiper-item", "。这个实现较为简单，步骤如下：在", "data", "中添加一个表示下标的变量", "curIndex", "；将此变量绑定到导航栏各个选项，同时使用一个三目运算符进行", "wx:if", "条件渲染，若", "curIndex", "等于当前选项的下标，则在其底部添加一个伪元素表示选中；将", "curIndex", "绑定到", "swiper", "的", "current", "属性中，通过选项卡的", "bindtap", "事件和", "swiper的", "bindchange", "事件实时切换", "swiper-item", "。话不多说，贴上代码：//nbaMatches.wxml", "<view", "class=\"info_hd\">", "<view", "class=\"headerMenu", "{{curIndex===index?'on':''}}\"", "wx:for=\"{{nbaMenu}}\"", "data-index=\"{{index}}\"", "bindtap=\"switchSort\">", "<view", "class=\"nbaSort\">{{item.nbaSort}}</view>", "</view>", "</view>", "<view", "class=\"info_bd\">", "<swiper", "current=\"{{curIndex}}\"", "bindchange=\"bindswiper\">", "...", "</swiper>", "</view>//nbaMatches.js", "bindswiper(e)", "{", "this.setData({", "curIndex:", "e.detail.current", "})", "},", "switchSort(e)", "{", "console.log(e.currentTarget.dataset.index);", "this.setData({", "curIndex:", "e.currentTarget.dataset.index?e.currentTarget.dataset.index:", "0", "})", "}2）", "此项目的“热门”页也使用了一个", "swiper", "组件，相比普通", "swiper", "的使用，这个更为复杂。此处的", "swiper", "不再是与有限个的选项进行交互，而是与无限个的日期进行交互。难道一年365天就要365个", "swiper-item", "？", "吓得老夫虎躯一震。经过一场“猪脑子”风暴后，还是没有想出完美的解决方案，只好设置有限个", "swiper-item", "来初步实现所需效果。还是贴代码吧！//swiper的bindchange事件", "changeMatch(e)", "{", "const", "current", "=", "e.detail.current;", "//获取当前位置", "const", "befInd", "=", "this.data.swiperCurIndex;", "//获取滑动前的位置", "const", "index", "=", "current", "-", "befInd;", "if", "(index", "<=", "-1)", "{", "//判断左滑右滑", "this.preDay();", "//日期切换至前一天", "}", "else", "if", "(index", ">=", "1)", "{", "this.nextDay();", "//日期切换至后一天", "}", "else", "{", "return", "}", "}//", "nextDay()", "方法类似", "preDay()", "{", "let", "day", "=", "this.data.day;", "let", "month", "=", "this.data.month;", "let", "week=", "this.data.week;", "let", "i", "=", "this.data.i;", "if", "(i<=0)", "{", "//周一至周日的循环切换", "i", "=", "6;", "}else", "{", "i--;", "}", "if(day<=1)", "{", "//日期本月第一天时，将日期切换至上月最后一天", "month--;", "day", "=", "this.data.daysCountArr[month-1];", "}else", "{", "day--;", "//否则切换至前一天", "}", "this.setData({", "swiperCurIndex:", "this.data.swiperCurIndex-1,", "month,", "day,", "i,", "week:", "this.data.weekArr[i],", "curDate:", "month+'月'+day+'日'+'", "'+this.data.weekArr[i]", "})", "}如果大佬们有解决方案欢迎交流讨论。详细代码查看可点击", "这里", "。3、选项卡天啦噜！你连选项卡都要说？（笑哭）听我解释。通常我们使用的选项卡中的选项都是", "2", "到", "4", "个，如果不嫌麻烦，我们只要将选项卡和其对应的内容逐个在", ".wxml", "中写出来就好了。但是，一旦选项变多，若逐个写出，那", ".wxml", "中的代码将跟“懒婆娘的裹脚布”似的。此时，使用", "wx:for", "来循环输出选项就非常有必要了。另外，如果每个选项中的内容都是类似的就更好了，可通过选项卡的点击事件获得当前选项的", "id", "，根据", "id", "使用", "wx:if", "条件渲染来决定当前选项卡显示的数据。在这又要cue一下我们的", "NBA赛事详情页", "，此页面中的球员榜这个", "swiper-item", "就包含了一个有", "5", "个选项的选项卡。详细代码查看可点击", "这里", "。4、自定义日历为了更好的体验，体育赛事总要加入日历，方便用户查看赛事安排。若使用", "picker", "组件，用户体验可能差强人意，那么如何自定义一个日历呢？在参照了各路大神的方法后得出以下分析：可左右切换月份并显示当月日历。腾讯体育官方小程序的日历可左右滑动切换，与“热门”页类似。由于还没有解决方案，在这里没有使用", "swiper", "组件。日历主体中的每月日期是一个二维数组，每月的周数则为数组的length，因此wxml中的日期输出需要使用两重", "wx:for", "。部分代码如下：<view", "class=\"calendar_box\"", "wx:for=\"{{dateList}}\"", "wx:for-item=\"week\"", "wx:key=\"{{index}}\"", "style=\"{{index==0?'justify-content:", "flex-end;':''}}\">", "<view", "wx:for=\"{{week}}\"", "data-date=\"{{item}}\"", "class=\"weekday_label", "{{item.value==selectedDate?'active_label':''}}\"", "bindtap=\"selectDate\">", "<view", "class=\"date\">", "<text>{{item.date}}</text>", "</view>", "<view", "class=\"gameNumBox\">", "<text", "class=\"gameNum\">{{item.gameNum}}</text>", "<text>场比赛</text>", "</view>", "</view>", "</view>默认高亮显示当天日期，点击具体日期高亮显示。这个实现起来较为简单，只需得到通过点击事件获取当前点击日期，在", ".wxml", "中使用三目运算符判断获取日期与数据中的日期是否相同，从而达到高亮显示的效果。返回今天。点击“返回今天”可回退至“热门”页并显示当天的赛事。使用小程序自带", "API", "——", "wx.navigateBack(OBJECT)", "即可返回上一页面，以下为文档截图：值得注意的是：wx.navigateTo", "和", "wx.redirectTo", "不允许跳转到", "tabbar", "页面，只能用", "wx.switchTab", "跳转到", "tabbar", "页面"]}
{"author": "Rolan", "title": "Web直播，你需要先知道这些 ", "content": ["转自IMWeb社区，作者：Terrance，原文链接一、直播知识小科普一个典型的直播流程：录制->编码->网络传输（推流->服务器处理->CDN分发）->解码->播放IPB：一种常用的视频压缩方案，用I帧表示关键帧，B帧表示前向差别帧，P帧表示双向差别帧GOP", "(Group", "of", "Pictures)：GOP", "越长（I帧之间的间隔越大），B", "帧所占比例越高，编码的率失真性能越高。虽然B帧压缩率高，但解码时CPU压力会更大。音视频直播质量好坏的主要指标：", "内容延时", "、", "卡顿（流畅度）", "、", "首帧时长音视频直播需要克服的主要问题：网络环境、多人连麦、主辅路、浏览器兼容性、CDN支持等MSE", "(Media", "Source", "Extensions)：W3C", "标准API，解决", "HTML5", "的流问题（HTML5", "原生仅支持播放", "mp4/webm", "非流格式，不支持", "FLV），允许JavaScript动态构建", "<video>", "和", "<audio>的媒体流。可以用MediaSource.isTypeSupported()", "判断是否支持某种MINE类型。在ios", "Safari中不支持。文件格式/封装格式/容器格式", "：一种承载视频的格式，比如flv、avi、mpg、vob、mov、mp4等。而视频是用什么方式进行编解码的，则与Codec相关。举个栗子，MP4格式根据编解码的不同，又分为nMP4、fMP4。nMP4是由嵌套的Boxes", "组成，fMP4格式则是由一系列的片段组成，因此只有后者不需要加载整个文件进行播放。Codec", "：多媒体数字信号编码解码器，能够对音视频进行压缩（CO）与解压缩(", "DEC", ")", "。CODEC技术能有效减少数字存储占用的空间，在计算机系统中，使用硬件完成CODEC可以节省CPU的资源，提高系统的运行效率。常用视频编码", "：MPEG、H264、RealVideo、WMV、QuickTime。。。常用音频编码", "：PCM、WAV、OGG、APE、AAC、MP3、Vorbis、Opus。。。二、现有方案比较RTMP协议基于TCPadobe垄断，国内支持度高浏览器端依赖Flash进行播放2~5秒的延迟RTP协议Real-time", "Transport", "Protocol，IETF于1996提出的一个标准基于UDP实时性强用于视频监控、视频会议、IP电话CDN厂商、浏览器不支持HLS", "协议Http", "Live", "Streaming，苹果提出的基于HTTP的流媒体传输协议HTML5直接支持(video)，适合APP直播，PC断只有Safari、Edge支持必须是H264+AAC编码因为传输的是切割后的音视频片段，导致内容延时较大flv.jsBilibli开源，解析flv数据，通过MSE封装成fMP4喂给video标签编码为H264+AAC使用HTTP的流式IO(fetch或stream)或WebSocket协议流式的传输媒体内容2~5秒的延迟，首帧比RTMP更快WebRTC协议1、Google力推，已成为W3C标准2、现代浏览器支持趋势，X5也支持（微信、QQ）3、基于UDP，低延迟，弱网抗性强，比flv.js更有优势4、支持Web上行能力5、编码为H264+OPUS6、提供NAT穿透技术（ICE）实际情况下，当用户数量很大时，对推流设备的性能要求很高，复杂的权限管理也难以实现，采用P2P的架构基本不可行。对于个别用户提供上行流、海量用户只进行拉流的场景，腾讯课堂实现了一种P2S的解决方案。", "进一步学习可阅读jaychen的系列文章《WebRTC直播技术》。三、小程序+直播技术方案基于RTMP，官方说底层使用HTTP/2的一种内部传输机制，但又说是基于UDP的，这就搞不懂了。。。live-pusher", "和", "live-player", "没有限制第三方云服务可直接使用腾讯云视频直播能力，只需配置好推流url、播放url即可推流url：播放url：下面是我根据官网教程搭建的一个音视频小程序，搭建过程简单，同一个局域网下直播体验也很流畅（读者也可直接搜索", "腾讯视频云", "小程序进行体验）：前端核心代码还是相当简洁的：live-pusher组件：设置好url推流地址（仅支持", "flv,", "rtmp", "格式）等参数即可，使用bindstatechange获取播放状态变化<view", "id='video-box'>", "<live-pusher", "id=\"pusher\"", "mode=\"RTC\"", "url=\"{{pusher.push_url}}\"", "autopush='true'", "bindstatechange=\"onPush\">", "</live-pusher>", "</view>", "复制代码live-player组件：设置后src音视频地址（仅支持", "flv,", "rtmp", "格式）等参数即可，使用bindstatechange获取播放状态变化<view", "id='video-box'>", "<live-player", "wx:for=\"{{player}}\"", "id=\"player_{{index}}\"", "mode=\"RTC\"", "object-fit=\"fillCrop\"", "src=\"{{item.playUrl}}\"", "autoplay='true'", "bindstatechange=\"onPlay\">", "</live-player>", "</view>", "复制代码能否和WebRTC同时使用?对于腾讯课堂的应用场景，老师上课推流采用的是RTMP协议，考虑到WebRTC目前只能用于PC端拉流，那么在移动端能否让用户可以直接通过小程序来观看直播课呢？我觉得在技术层面可行的，接入小程序直播对于扩大平台影响力、社交圈分享、提高收费转化都会产生很大的帮助。难点在于复杂的权限控制、多路音视频流、多人连麦等问题，比如权限控制只能单独放到房间控制逻辑中完成，而音视频流本身缺乏这种校验；主辅路的切换还需要添加单独的信令控制，同时在小程序中加入相应的判断逻辑。"]}
